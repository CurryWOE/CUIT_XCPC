# 逆元
## 定义
模 $p$ 意义下，一个数 $a$ 可能有唯一的与之对应的

乘法逆元(Multiplicative inverse modulo) $x$

使得$a*x\equiv 1 \pmod p$

$x$ 记为 $a^{-1}$

## 逆元存在充分必要条件
$gcd(a,p)=1$，此时逆元唯一存在

## 用处
模 $p$ 意义下，1个数 $a$ 如果有逆元 $x$ ，那么除以 $a$ 相当于乘以$x$ ，即

$(a/b)\%p=(a\%p*inv(b)\%p)\%p$

## 逆元求法

1. exgcd

### 时间复杂度
$O(ln(n))$   (单次最优)

### 原理

求 $a$ 的逆元相当于求解$ax=1 \pmod p$

这个方程可以转化为 $ax-py=1$

然后套用求二元一次方程的方法，

用扩展欧几里得算法求得一组 $x_0,y_0$ 和 $gcd$

```c++
long long exgcd(long long a,long long b,long long &x,long long &y)
{
	if(!b)
	{
		x=1;
		y=0;
		return a;
	}
	long long r=exgcd(b,a%b,y,x);
	y-=x*(a/b);
	return r;
}
long long inv(long long a,long long n)
{
    long long x,y;
    if(exgcd(a,n,x,y)==1ll)
        return (x%n+n)%n;
    else
        return -1;
}
```

2. 费马小定理及欧拉定理

欧拉定理

### 时间复杂度
$O(\sqrt n+log_2n)$

### 原理
$a^{-1}\equiv a^{φ(n)-1} \pmod p$

```c++
long long euler(long long n)
{
    long long res=n,a=n;  
    for(long long i=2;i*i<=a;i++)
    {  
        if(a%i==0)
        {  
            res=res/i*(i-1);//先除后乘是为了防止中间数据的溢出
            while(a%i==0)
                a/=i;
        }
    }
    if(a>1)
        res=res/a*(a-1);
    return res;
}
long long qpow(long long base,long long power,long long n)
{
    long long result=1;
    while(power>0)
    {
        if(power&1)
            result=result*base%n;
        base=base*base%n;
        power>>=1;
    }
    return result;
}
long long inv(long long a,long long n)
{
    long long ie=qpow(a,euler(n)-1,n);
    if(ie*a%n==1ll)
        return ie;
    else
        return -1;//逆元不存在
}
```

费马小定理
### 时间复杂度
$O(log_2n)$

$a^{-1}\equiv a^{n-2} \pmod p$

```c++
long long qpow(long long base,long long power,long long n)
{
    long long result=1;
    while(power>0)
    {
        if(power&1)
            result=result*base%n;
        base=base*base%n;
        power>>=1;
    }
    return result;
}
long long inverse_element(long long a,long long n)
{
    return qpow(a,n-2,n);
}
```


3. 逆元打表

在模质数 $p$ 下，求 $[1,n]$ 逆元，$n < p$ ( $p$ 是奇质数)
### 时间复杂度
$O(n)$

### 原理
设$t=p/i$,$k=p\%i$

$t*i+k\equiv 0 \pmod p$

$-t*i\equiv k \pmod p$

$-t*inv(k)\equiv inv(i) \pmod p$

$inv(i)=(p-p/i)*inv(p\%i)\%p$

$inv(1)=1$

```c++
const int N = 1e5 + 5;
int inv[N];
void inverse(int n, int p) 
{
    inv[1] = 1;
    for(int i=2; i<=n; ++i)
        inv[i] = (ll) (p - p / i) * inv[p%i] % p;
}
```