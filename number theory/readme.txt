这是导读
数论主要研究整数的整除问题
定理证明省略，因为基本用不到
本导读尽量不让人去搜索除给出的网址外的东西，如果不懂，说明笔者写的不好，请发个issue或者qq联系
前几节根据原博客改编，但改动不少，请先看本导读
https://www.cnblogs.com/fzl194/p/9015989.html
1、整除性
    a和b都为整数，a整除b是指b是a的倍数，a是b的约数（因数、因子），记为a|b。
    整除有如下性质：
    i)  任意性，若a|b，则对于任意非零整数m，有a*m|b*m。
    ii) 传递性，若a|b，且b|c，则a|c。
    iii) 可消性，若a|b*c，且a和c互素(互素的概念下文会讲到)，则a|b。
    iv) 组合性，若c|a，且c|b，则对于任意整数m、n，有c|(m*a+n*b)。

    下面一个例题概括了整除的性质。
    【例题】(1987年初二数学竞赛题) x，y，z均为整数，若11｜（7x+2y-5z），求证：11｜（3x-7y+12z）。 
    令a = （7x+2y-5z），b = （3x-7y+12z），
    通过构造可以得到一个等式：4a + 3b = 11（3x-2y+3z），则3b = 11（3x-2y+3z） - 4a。
    11整除a，任意性得11整除4a
    11整除前面那个，组合性得出 11 |（11（3x-2y+3z） - 4a） = 11|3b。
    可消性，由于11和3互素，得出 11 | b，证明完毕。

2、素数
    a.素数与合数
    素数（又称质数）
    大于等于2，并且除了1和它本身外，不能被其它任何自然数整除；
    其它的数称为合数；
    注意：1既非素数也非合数。

    b.素数判定    
    如何判定一个数是否为素数？
    i) 对n做[2, n)范围内的余数判定(C++中的'%'运算符),如果有至少一个数用n取余后为0,则表明n为合数,否则n为素数，算法复杂度O(n)。

    ii) 假设一个数能整除n，即a|n，那么n/a也必定能整除n，
    不妨设a <= n/a，则有a^2 <= n，即a <= sqrt(n)（sqrt表示对n开根号），
    所以在用i)的方法进行取余的时候，范围可以缩小到sqrt(n)，所以算法复杂度降为O( sqrt(n) )。
    请根据此小节学习判断质数.cpp part 1,并自行在不看资料的情况下实现，如果不能，说明没有理解

    iii) 如果n是合数，那么它必然有一个小于等于sqrt(n)的素因子，只需要对sqrt(n)内的素数进行测试即可，
    需要预处理求出sqrt(n)中的素数，假设该范围内素数的个数为s，那么复杂度降为O(s)。

    iV) 大数判定素数 
    常规方法不起作用了，米勒拉宾可解
    请根据此小节学习判断质数.cpp part 2

    c.素数定理
    当x很大时，小于x的素数的个数近似等于x/ln(x)，其中ln(x)表示x的自然对数。
    这个定理说明iii)在多次查询的时候比ii)至少低一个数量级
    所以单次查询用ii),多次查询用iii)

    d.素数筛选法    
    常用线性筛，埃氏筛的思想会用到（求原根用到一次）
    请根据此小节学习线性筛.cpp part 1,并自行在不看资料的情况下实现，如果不能，说明没有理解

3、因数分解
    a、算术基本定理
    算术基本定理可以描述为：对于每个整数n，都可以唯一分解成素数的乘积，即
    N=P1^a1*P2^a2*P3^a3*......*Pn^an，这里P1<P2<P3......<Pn均为质数，其中指数ai是正整数

    b、质因数分解
    给定一个数n，如何将它拆分成素数的乘积呢？
    还是用到上面讲到的试除法，
    然后通过枚举[2, sqrt(n)]的素数，如果能够找到一个素数p，使得n mod p == 0（mod 表示取余数、也称为模）。
    于是m = n/p，这时还需要注意一点，因为m中可能也有p这个素因子，所以如果p|m，需要继续试除，
    令m' = m/p，直到将所有的素因子p除尽，统计除的次数e，于是我们得到了 n = (p^e) * n'，然后继续枚举素数对n'做同样的试除。
    枚举完[2, sqrt(n)]的素数后，
    这时有两种情况：
    i)  S == 1，则素数分解完毕；
    ii) S > 1, 根据算术基本定理，S 必定为素数，而且是大于sqrt(n)的素数，并且最多只有1个，这种情况同样适用于n本身就是素数的情况，这时n = S。
    这样的分解方式称为因数分解。算法时间复杂度为O( s )，s为sqrt(n)内素数的个数。
    请自行在不看资料的情况下实现，如果不能，说明没有理解

    c、求所有因数
        分解质因数，所有因数可以通过质因数相乘得出，例如24=2^3*3^1,24的因子有1,2,3,4,6,8,12,24
        A={2^0,2^1,2^2,2^3}
        B={3^0,3^1}
        2^0*3^0=1,2^1*3^0=2,2^2*3^0=4,2^3*^0=8
        2^0*3^1=3,2^1*3^1=6,2^2*3^1=12,2^3*^1=24
        这样就不遗漏不重复的求出了所有因数，而且可以扩展到更多个质因数的情况
        原理是算术基本定理，“唯一性”
    请自行在不看资料的情况下实现，如果不能，说明没有理解

    d、因子个数
    i) 如果m为n的因子，那么必然n/m也为n的因子，不妨设m <= n/m，则有m <= sqrt(n)，
    所以只要枚举从[1, sqrt(n)]的因子然后计数即可，复杂度为O(sqrt(n))。

    ii) 分解质因数，每个质因数可以取的个数为[0,ai],n的因子个数就是(1 + a1) * (1 + a2) * ... * (1 + ak)。时间复杂度为O( s )

    iii) 线性筛筛选
    学习线性筛.cpp part 3

    e、因子和
    i)把c小节下的A,B改写成
    A={a,b,c,d}
    B={e,f}
    因子和就是a*e+b*e+c*e+d*e+a*f+b*f+c*f+d*f
    =(a+b+c+d)*e+(a+b+c+d)*f
    =(a+b+c+d)*(e+f)
    所以得到因子和=(p1^0+p1^1+p1^2+……+p1^a1)*(p2^0+p2^1+p2^2+……+p2^a2)*……*(pi^0+……+pi^ai)
    =(p1^(a1+1)-1)/(p1-1)*……*(pi^(ai+1)-1)/(pi-1)
    也可以不写成上式，用倍增加速
    设sum(p,a)=Σ(a,0)p^i={
            sum(p,a-1) + p^a ,if n is even but not 0
            (1+p^((a+1)/2))*sum(p,a/2) ,if n is odd
            1 ,if n=0
    }
    请自行在不看资料的情况下实现倍增写法，如果不能，说明没有理解

    ii) 线性筛筛选
    学习线性筛.cpp part 3

4、最大公约数和最小公倍数
    两个数a和b的最大公约数(Greatest Common Divisor)是指同时整除a和b的最大因数，记为gcd(a, b)。
    特殊的，当gcd(a, b) = 1，我们称a和b互素（又称互质）（上文谈到整除的时候略有提及）。
    两个数a和b的最小公倍数(Leatest Common Multiple)是指同时被a和b整除的最小倍数，记为lcm(a, b)。
    gcd是基础数论中非常重要的概念，求解gcd一般采用辗转相除法。
    而求lcm通过lcm(a, b) = ab / gcd(a, b)求解。
    请学习欧几里得算法&拓展欧几里得.cpp part 1

    【例题】三个未知数x, y, z，它们的gcd为G，lcm为L，G和L已知，求(x, y, z)三元组的个数。
    三个数的gcd可以参照两个数gcd的指数最值表示法，只不过每个素因子的指数上是三个数的最值（即min{x1, y1, z1}），
    那么这个问题首先要做的就是将G和L分别进行素因子分解，然后轮询L的每个素因子，对于每个素因子单独处理。
    假设素因子为p，L分解式中p的指数为l，G分解式中p的指数为g，那么显然l < g时不可能存在满足条件的三元组，
    所以只需要讨论l >= g的情况，
    对于单个p因子，问题转化成了求三个数x1, y1, z1，满足min{x1, y1, z1} = g且max{x1, y1, z1} = l，
    更加通俗的意思就是三个数中最小的数是g，最大的数是l，另一个数在[g, l]范围内，
    这是一个排列组合问题，三元组{x1, y1, z1}的种类数当l == g时只有1中，否则答案就是 6(l - g)。
    最后根据乘法原理将每个素因子对应的种类数相乘就是最后的答案了。

5、欧拉函数
    一个重要的函数，表示小于n且与n互素的正整数的个数
    符号为φ(n)，希腊字母phi
    性质1：质数p,φ(p^n)=(p-1)*p^(n-1)
    性质2：a|x,φ(a*x)=a*φ(x)
    性质3：gcd(a,b)=1,φ(a)*φ(b)=φ(a*b)
    单次求法见欧拉函数.cpp,筛法见线性筛.cpp
    这个函数与后面许多内容都联系紧密

6、快速幂
    严格来说不算数论，但之后知识会用到
    （数论是研究整数的整除问题，不是数学都算数论）
    计算幂，可以用倍增加速（这里只是让你初次认识倍增，之后rmq和lca还会碰到倍增）
    a^n={
            a^(n-1) * a ,if n is odd
            a^(n/2) * a^(n/2) ,if n is even but not 0
            1 ,if n=0
    }
    也可以用二进制加速
    但是日常用二进制加速版快速幂
    请学习other快速幂.cpp
    矩阵快速幂涉及线性代数-矩阵乘法，理解快速幂后可以学习linear algebra矩阵快速幂.cpp

7、同余
    a、模运算
    给定一个正整数p，任意一个整数n，一定存在等式n = kp + r； 其中k、r是整数，且满足0 <= r < p，
    称k为n除以p的商， r为n除以p的余数，表示成n % p = r (%表示取模运算)。
    对于正整数和整数a, b, 定义如下运算：
    取模运算：a % p，表示a除以p的余数。
    模p加法：(a + b) % p = (a%p + b%p) % p
    模p减法：(a - b) % p = (a%p - b%p) % p
    模p乘法：(a * b) % p = ((a % p) * (b % p)) % p
    模p除法：(a / b) % p = ((a % p) * (inv(b) % p)) % p
    inv()表示逆元，之后学习
    幂模p  ：(a ^ b) % p = ((a % p) ^ b) % p
    幂模可以用快速幂加速
    模运算满足结合律、交换律和分配律。
    a≡b (mod n) 表示a和b模n同余，即a和b除以n的余数相等。

    【例题】一个n位十进制数(n <= 1000000)必定包含1、2、3、4四个数字，现在将它顺序重排，求给出一种方案，使得重排后的数是7的倍数。
    取出1、2、3、4后，将剩下的数字随便排列得到一个数a，令剩下的四个数字排列出来的数为b，那么就是要找到一种方案使得(a*10000 + b) % 7等于0。
    但是a真的可以随便排吗？也就是说如果无论a等于多少，都能找到这样的b满足等式成立，那么a就可以随便排。
    我们将等式简化：
    (a*10000 + b) % 7 = (a*10000%7 + b%7) % 7
    令 k = a*10000%7 = a*4%7，容易发现k的取值为[0, 7)，如果b%7的取值也是[0, 7)，
    那这个问题就可以完美解决了，很幸运的是，的确可以构造出7个这样的b

8、欧拉定理&费马小定理
    请学习欧拉定理&费马小定理.cpp

9、线性同余方程（又称模线性方程）
    a.线性同余方程
    线性指未知数都是一次的方程
    最基本的同余方程，
    即a*x≡b (mod n)，其中a、b、n都为常量，x是未知数，
    这个方程可以进行一定的转化，
    得到：ax = kn + b,这里的k为任意整数，
    于是我们可以得到更加一般的形式即：ax + by + c = 0，
    这个方程就是二维空间中的直线方程，但是x和y的取值为整数，所以这个方程的解是一些排列成直线的点集。
    可以用拓欧求解
    请学习欧几里得算法&拓展欧几里得.cpp part 2

10、逆元
    请学习逆元.cpp

11、线性同余方程组
    可以用CRT求解
    请学习中国剩余定理.cpp part 1,2

12、BSGS
    请学习bsgs.cpp part 1,2

13、原根
    请学习原根.cpp

14、狄利克雷卷积
    狄利克雷卷积：
    定义在数论函数间一种二元运算，可这样定义：
        (f*g)(n)=Σ[x*y=n] f(x)*g(y)   []内是x和y满足的条件
    也常常等价地写作：
        (f*g)(n)=Σ[d|n] f(d)*g(n/d)

    为了之后讨论方便，先定义一些常用的数论函数的符号：
    单位函数ε(n)={1,while n=1
                 0,otherwise}
    符号是希腊字母epsilon
    幂函数Id[k](n)=n^k.
    k=1时为恒等函数Id(n)
    k=0时为常数函数1(n)
    除数函数σ[k](n)=Σ[d|n] d^k
    k=1时为因数和函数σ(n)
    k=0时为因数个数函数σ[0](n)
    符号是希腊字母sigma
    欧拉函数φ(n)
    符号是希腊字母phi

    这些函数都是积性函数，前二者还是完全积性函数
    积性函数之间的狄利克雷卷积有一个重要性质：
    若f,g是积性函数，则f*g也是积性函数
    因此，可以得到一些数论函数之间的联系:
    常用，牢记

    除数函数与幂函数
        Id[k]*1=σ[k]
    欧拉函数与恒等函数
        φ*1=Id
    注意：1此时是常数函数

    狄利克雷卷积的一些性质：
    交换律，结合律
    下面涉及到群论的一些知识，请移步combinatorial math的burnside引理&polya定理.cpp的第一个分割线以前的内容
    对函数加法的分配律，即
    (f*(g+h))(n)=(f*g)(n)+(f*h)(n)
    单位元是单位函数ε
    狄利克雷逆存在必要条件是f(1)!=0
    英文是Dirichlet inverse，但是已有乘法逆元Multiplicative inverse modulo，所以翻译成这样

    需要指出，积性函数必然存在狄利克雷逆，且狄利克雷逆仍是积性函数。

15、莫比乌斯反演
    常数函数 1 的狄利克雷逆，称之为莫比乌斯函数 μ
    μ(n)={ 1,while n=1
           (-1)^m,while n=p1*p2*……*pm
           0,otherwise
    }
    其中p1，p2，……，pm是质数，
    所以当n存在一个质因数次数>=2，μ(n)=0

    莫比乌斯反演公式：
    g(n)=Σ[d|n] f(d) ⇔ f(n)=Σ[d|n] μ(d)*g(n/d)
    狄利克雷卷积写法：
    g=f*1 ⇔ f=g*u
    倍数形式：
    g(n)=Σ[n|N] f(N) ⇔ f(n)=Σ[n|N] g(N)*μ(N/n)
    //第一种是因数形式

    莫比乌斯函数计算见线性筛.cpp part 2

    在竞赛中，莫比乌斯反演常常涉及到两个小技巧：提取公因数，整除分块
    下面这个博客写的很好，包括里面的例题讲解（其实是太多公式要用latex写，写在这里影响理解）
    https://zhuanlan.zhihu.com/p/138038817
