- 对拍
- 开栈
- 快速排序&快速选择
- IO
- 三分
- 编程方法
# 对拍

## 不适用

1. TLE 和 MLE，对拍只能保证正确性
2. 正解就是暴力的题目，你可能暴力写不对
3. corner case

## 注意事项

所有文件需在同一文件夹的同一层里

编数据时最好不要用原题数据，暴力会卡死，毕竟只是保证正确性，数据小一点就好

修改 cpp 文件后要重新编译，因为调用的是 exe 文件

## 实操

以斐波那契数列为例，这里设递归为暴力，迭代为正解

先写出前 4 个程序并编译再运行最后一个程序

正解

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,f0,f1,f2;
    freopen("data.txt","r",stdin);
    scanf("%d",&n);
    f0=1;
    f1=1;
    if(n<2)
        printf("1");
    else
    {
        for(;n>=2;--n)
        {
            f2=f0+f1;
            f0=f1;
            f1=f2;
        }
        printf("%d",f2);
    }
    return 0;
}
```

暴力

```cpp
#include<bits/stdc++.h>
using namespace std;
int f(int n)
{
    if(n<2)
        return 1;
    return f(n-1)+f(n-2);
}
int main()
{
    int n;
    freopen("data.txt","r",stdin);
    scanf("%d",&n);
    printf("%d",f(n));
    return 0;
}
```

数据生成

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    freopen("data.txt","W",stdout);
    srand(time(0));
    //必加，否则生成数据不随机
    int n,l,r;
    l=0,r=20;
    n=rand()%r+l;
    //rand()函数用来生成随机数
    //n的范围在[l,r-1+l]
    printf("%d\n",n);
    return 0;
}
```

检查

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    t=10;
    //测试数据的组数
    while(t--)
    {
        system("dataGenerator.exe > data.txt");
        system("positiveSolution.exe < data.txt > ps.txt");
        system("bruteForce.exe < data.txt > bf.txt");
        if(system("fc ps.txt bf.txt"))
            break;
        //fc是file compare的缩写,当两个文件不同时输出1，否则0
        //system函数执行失败会返回-1，我自己电脑常规方式运行不了，要用coderunner插件
    }
    if(t==-1)
        printf("No errors were found.");
    else
        printf("Errors found.");
    return 0;
}
```

# 开栈

```cpp
#pragma comment(linker, "/STACK:102400000,102400000")
```

# 快速排序

```cpp
void Quicksort(int a[], int low, int high)
{
	if (low >= high)
	{
		return;
	}
	int first = low;
	int last = high;
	int key = a[first];
	while (first<last)
	{
		while (first < last && a[last] >= key)
		{
			--last;
		}
		a[first] = a[last];
		while (first < last && a[first] <= key)
		{
			++first;
		}
		a[last] = a[first];
	}
	a[first] = key;
	Quicksort(a, low, first - 1);
	Quicksort(a, last + 1, high);
}
#include<stdlib.h>
int cmp(const void *a, const void *b)
{
    return(*(int *)a-*(int *)b);  //升序
    return(*(int *)b-*(int *)a); //降序
}
qsort(s,n,sizeof(s[0]),cmp);
//s数组名或开始排序的首地址，n被排序的元素个数
int cmp(const void * a, const void * b)
{
     return((*(double*)a-*(double*)b>0)?1:-1);
}
/*这里做个注释，本来是因为要判断如果a==b返回0的，
但是严格来说，两个double数是不可能相等的，
只能说fabs(a-b)<1e-6之类的这样来判断，所以这里只返回了1和-1*/
```

# 快速选择

```cpp
//O(n)求第K个最大的元素
int findKthLargest(vector<int>& v, int k)
{
    srand(time(NULL));
    return findKthLargest(v,0,v.size()-1,k);
}
int findKthLargest(vector<int>& v,int l,int r,int k)
{
    int index=partition(v,l,r);
    if(index+1==k) return v[index];
    else if(index+1>k) return findKthLargest(v,l,index-1,k);
    else return findKthLargest(v,index+1,r,k);
}
int partition(vector<int>& v,int l,int r)
{
    swap(v[l],v[rand()%(r-l+1)+l]);
    int first=l,last=l+1;
    for(;last<=r;++last)
    {
        if(v[last]>v[l])
            swap(v[++first],v[last]);
    }
    swap(v[first],v[l]);
    return first;
}
```

# 快读快写

```cpp
template <typename T>
inline void read(T &x)
{
    T sum = 0, f = 1;
    char c = getchar();
    while (!isdigit(c))
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (isdigit(c))
    {
        sum = sum * 10 + c - '0';
        c = getchar();
    }
    x = sum * f;
}
inline void read(double &x)
{
    double z = 0, t = 0;
    int s = 0, f = 1;
    char c = getchar();
    while (!isdigit(c))
    {
        if (c == '-')
            f = -1;
        if (c == '.')
            goto readt;
        c = getchar();
    }
    while (isdigit(c) && c != '.')
    {
        z = z * 10 + c - '0';
        c = getchar();
    }
readt:
    while (c == '.')
        c = getchar();
    while (isdigit(c))
    {
        t = t * 10 + c - '0';
        ++s;
        c = getchar();
    }
    x = (z + t / pow(10, s)) * f;
}
inline void read(string &x)
{
    x = "";
    char ch = getchar();
    while (ch == ' ' || ch == '\n' || ch == '\r')
        ch = getchar();
    while (ch != ' ' && ch != '\n' && ch != '\r')
        x += ch, ch = getchar();
}
inline void readline(string &x)
{
    x = "";
    char ch = getchar();
    while (ch == ' ' || ch == '\n' || ch == '\r')
        ch = getchar();
    while (ch != '\n' && ch != '\r')
        x += ch, ch = getchar();
}
template <typename T, typename... Args>
inline void read(T &t, Args &...args)
{
    read(t);
    read(args...);
}
template <typename T>
inline void write(T x)
{
    if (x < 0)
        putchar('-'), x = -x;
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}
inline void write(double x, int k = 6)
{
    ll n = pow(10, k + 1);
    if (x == 0)
    {
        putchar('0'), putchar('.');
        for (int i = 1; i <= k; ++i)
            putchar('0');
        return;
    }
    if (x < 0)
        putchar('-'), x = -x;
    ll y = (ll)(x * n) % n;
    x = (ll)x;
    write((ll)x), putchar('.');
    int bit[20], p = 0, i;
    if (y % 10 >= 5)
        y = y / 10 + 1;
    else
        y = y / 10;
    for (; p < k; y /= 10)
        bit[++p] = y % 10;
    for (i = p; i > 0; i--)
        putchar(bit[i] + 48);
}
inline void write(string x)
{
    for (int i = 0; x[i] != '\0'; i++)
        putchar(x[i]);
}
template <typename T>
inline void write(const char ch, T x)
{
    write(x);
    putchar(ch);
}
template <typename T, typename... Args>
inline void write(const char ch, T x, Args... args)
{
    write(ch, x);
    write(ch, args...);
}
```

# 读取一行，一行有未知个数

```cpp
pair<int, int> solve(string s)
{
    int c = s[0] == '+' ? 1 : -1;
    int res = 0, len = s.size();
    for (int i = 1; i < len; i++)
        res = res * 10 + s[i] - '0';
    return {res, c};
}
string s;
getline(cin, s);
stringstream ss;
ss << s;
while (ss >> s)
{
    auto res = solve(s);
}
```
# 三分
求单峰函数的极大值
>单峰函数：先单调增再单调减的函数

设该函数为 $f$，比较相邻点的值大小关系，如果左点大于右点，答案在右点左边，反之在左点右边

对于整数和实数的边界处理不一样
```cpp
//整数
while(l<=r)
{
    mid=(l+r)/2;
    if(check(mid)<check(mid+1))
    {
        l=mid+1;
        ans=mid;
    }
    else
        r=mid-1;
}
```
```cpp
//实数
int times=100;
while(times--)
{
    mid=(l+r)/2;
    if(check(mid)<check(mid+eps))
    {
        l=mid;
        ans=mid;
    }
    else
        r=mid;
}
```
对于二元函数，如果固定一元，另一元都是单峰函数，可以三分套三分，当然，可以进一步推广到更多元函数
# 常见的编程方法
1. 贪心
2. DP
3. 二分
4. 构造
5. 模拟
6. 暴力
7. 搜索，回溯
8. 递推
# 思考方式
Polya 介绍了 5 种手段：普通话、特殊化、类比、分解、重组

考虑辅助问题，比如中学数学中平面几何的辅助线

归谬

双轨迹模型：问题归结成点，把条件分成两半，对每一半，未知点形成轨迹，轨迹交点即为所求

聪明的解题者会发现我们表中的问题与建议很有用。然而他并不能真正的理解，除非他亲自碰到过该问题在他工作中所试图引起的做法，同时在体验了问题有用以后，亲自发现了其正确用法（不去实践的思考永远都是浮于表面的）。

建立方程

回到定义去

# 逆向思考
从前往后--从后往前

自顶向下--自底向上

这个位置可能的值--这个值可能的位置


前面元素对后面元素的贡献--后面元素对前面元素的贡献


# 零碎思考方式

一个起源按照两种方式变出不同的东西，分辨变化后的东西属于哪种变化方式变来的？

对其中一种方式构造不变式子，同时另一种方式始终不满足这种式子

---

枚举其中一个因素，考虑其他因素的影响