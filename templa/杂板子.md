- 火车头
- 对拍
- 快速选择
- IO
- 编程方法
- 位运算
- 随机
- 模拟退火
- 点分治
# 火车头
```cpp
#pragma comment(linker, "/STACK:102400000,102400000")
#pragma GCC optimize("Ofast")
#pragma GCC target("avx,avx2,fma")
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<ctime>
#include<array>
#include<deque>
#include<map>
#include<queue>
#include<set>
#include<stack>
#include<unordered_map>
#include<unordered_set>
#include<vector>
#include<fstream>
#include<iomanip>
#include<iostream>
#include<algorithm>
#include<bitset>
#include<chrono>
#include<random>
#include<string>
#include<utility>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
const int N = 2e5 + 10;
const double pi = acos(-1.0);
const int mod = 1e9 + 7;
const int INF = 0x3f3f3f3f;
const double eps = 1e-6;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    // clock_t starttime,endtime;
    // starttime=clock();
    // endtime=clock();
    // cout << "The run time is: " <<(double)(endtime - starttime) / CLOCKS_PER_SEC << "s" << endl;
    int T;
    cin>>T;
    for(int kase=1;kase<=T;++kase){}
    return 0;
}
```
# 对拍
## 不适用
1. TLE 和 MLE，对拍只能保证正确性
2. 正解就是暴力的题目，你可能暴力写不对
3. corner case，指输入上的边界情况（最大最小数据）和输出上的边界情况（通常出现在构造题，不能套用通解解决，但是确实有可行解）
## 注意事项
所有文件需在同一文件夹的同一层里

编数据时最好不要用原题数据，暴力会卡死，毕竟只是保证正确性，数据小一点就好

修改 cpp 文件后要重新编译，因为调用的是 exe 文件
## 实操
以斐波那契数列为例，这里设递归为暴力，迭代为正解

正解
```cpp
#include<fstream>
#include<iostream>
using namespace std;
void solve(int n)
{
    int res=0;
    for(int i=1;n>=1;--n)
    {
        res=res+i;
        i=res-i;
    }
    return res;
}
int main()
{
    ifstream in;
    in.open("data.in");
    int n;
    in>>n;
    cout<<solve(n);
    return 0;
}
```
暴力
```cpp
#include<fstream>
#include<iostream>
using namespace std;
void solve(int n)
{
    if(n<2)
        return n;
    return solve(n-1)+solve(n-2);
}
int main()
{
    ifstream in;
    in.open("data.in");
    int n;
    in>>n;
    cout<<solve(n);
    return 0;
}
```
数据生成
```cpp
#include<fstream>
#include<chrono>
#include<random>
using namespace std;
int main()
{
    ofstream out;
    cout.open("data.in");
    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
    cout<<rng()%(1e6);
    return 0;
}
```
检查
```cpp
#include<cstdlib>
#include<iostream>
using namespace std;
int main()
{
    for(int kase=1;kase<=10;++kase)
    {
        system("dataGenerator.exe > data.in");
        system("Solution.exe < data.in > 1.out");
        system("bruteForce.exe < data.in > 2.out");
        if(system("fc 1.out 2.out"))
        {
            cout<<"Errors found.";
            return 0;
        }
    }
    cout<<"No errors were found.";
    return 0;
}
```
# 快速选择 $O(n)$ 求第K个最大的元素
```cpp
int findKthLargest(vector<int>& v, int k)
{
    srand(time(NULL));
    return findKthLargest(v,0,v.size()-1,k);
}
int findKthLargest(vector<int>& v,int l,int r,int k)
{
    int index=partition(v,l,r);
    if(index+1==k) return v[index];
    else if(index+1>k) return findKthLargest(v,l,index-1,k);
    else return findKthLargest(v,index+1,r,k);
}
int partition(vector<int>& v,int l,int r)
{
    swap(v[l],v[rand()%(r-l+1)+l]);
    int first=l,last=l+1;
    for(;last<=r;++last)
    {
        if(v[last]>v[l])
            swap(v[++first],v[last]);
    }
    swap(v[first],v[l]);
    return first;
}
```
# IO
```cpp
template <typename T>
inline void read(T &x)
{
    T sum = 0, f = 1;
    char c = getchar();
    while (!isdigit(c))
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (isdigit(c))
    {
        sum = sum * 10 + c - '0';
        c = getchar();
    }
    x = sum * f;
}
inline void read(double &x)
{
    double z = 0, t = 0;
    int s = 0, f = 1;
    char c = getchar();
    while (!isdigit(c))
    {
        if (c == '-')
            f = -1;
        if (c == '.')
            goto readt;
        c = getchar();
    }
    while (isdigit(c) && c != '.')
    {
        z = z * 10 + c - '0';
        c = getchar();
    }
readt:
    while (c == '.')
        c = getchar();
    while (isdigit(c))
    {
        t = t * 10 + c - '0';
        ++s;
        c = getchar();
    }
    x = (z + t / pow(10, s)) * f;
}
inline void read(string &x)
{
    x = "";
    char ch = getchar();
    while (ch == ' ' || ch == '\n' || ch == '\r')
        ch = getchar();
    while (ch != ' ' && ch != '\n' && ch != '\r')
        x += ch, ch = getchar();
}
inline void readline(string &x)
{
    x = "";
    char ch = getchar();
    while (ch == ' ' || ch == '\n' || ch == '\r')
        ch = getchar();
    while (ch != '\n' && ch != '\r')
        x += ch, ch = getchar();
}
template <typename T, typename... Args>
inline void read(T &t, Args &...args)
{
    read(t);
    read(args...);
}
template <typename T>
inline void write(T x)
{
    if (x < 0)
        putchar('-'), x = -x;
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}
inline void write(double x, int k = 6)
{
    ll n = pow(10, k + 1);
    if (x == 0)
    {
        putchar('0'), putchar('.');
        for (int i = 1; i <= k; ++i)
            putchar('0');
        return;
    }
    if (x < 0)
        putchar('-'), x = -x;
    ll y = (ll)(x * n) % n;
    x = (ll)x;
    write((ll)x), putchar('.');
    int bit[20], p = 0, i;
    if (y % 10 >= 5)
        y = y / 10 + 1;
    else
        y = y / 10;
    for (; p < k; y /= 10)
        bit[++p] = y % 10;
    for (i = p; i > 0; i--)
        putchar(bit[i] + 48);
}
inline void write(string x)
{
    for (int i = 0; x[i] != '\0'; i++)
        putchar(x[i]);
}
template <typename T>
inline void write(const char ch, T x)
{
    write(x);
    putchar(ch);
}
template <typename T, typename... Args>
inline void write(const char ch, T x, Args... args)
{
    write(ch, x);
    write(ch, args...);
}
```
# 常见的编程方法
1. 贪心
2. DP
3. 二分
4. 构造
5. 模拟
6. 暴力
7. 搜索，回溯
8. 递推
## 思考方式
5 种手段：普通化、特殊化、类比、分解、重组

考虑辅助问题，比如中学数学中平面几何的辅助线

归谬

双轨迹模型：问题归结成点，把条件分成两半，对每一半，未知点形成轨迹，轨迹交点即为所求

上面这个可以用在观察DP的最优决策点的移动

建立方程

回到定义去
## 逆向思考
从前往后--从后往前

自顶向下--自底向上

这个位置可能的值--这个值可能的位置

前面元素对后面元素的贡献--后面元素对前面元素的贡献

建反向图

计算合法难--计算不合法

拆分--合并

正着推--逆着推

从无解情况推导有解的式子
## 以静制动
枚举其中一个因素，考虑其他因素的影响，（逆序对是最经典的）

---
先考虑不动元素的贡献，再考虑动元素的贡献，最后以不动元素计算动元素和不动元素之间的贡献

---
先考虑无操作的情况，再考虑操作的影响
## 零碎思考方式
一个起源按照两种方式变出不同的东西，分辨变化后的东西属于哪种变化方式变来的？

对其中一种方式构造不变式子，同时另一种方式始终不满足这种式子

---
数据小有可能是DP，将输入数据直接作为状态是典题

---
映射问题转化为图论

---
B在A中出现多次但只计数一次，找最特殊的一个B，比如出现位置组成的字符串字典序最小

计数问题尝试把式子化成二项式定理

---
能暴力别优化，能暴力别分类讨论

---
记忆化搜索DP时，后续状态都搜索过了，但是前继状态不一定，这种情况倒着DP会更好

---
注意函数取值范围

---
预处理会比记忆化搜索更快

---
对于更新A，A不能更新B；更新B，B不能更新A，的情况，需要拿更早的状态更复杂的转移来解决

有些操作可以被另一些操作等效替代，而替代后更好解决

---
有循环节的题目，可能是固定长度，也可能和n有关

不会使答案更劣的选择是对等的，不要先选一个再选一个。有哪个就选哪个

---
DP优化可以考虑调换内外循环顺序

---
区间数颜色最经典的思路就是记录每个位置，相同颜色的k前驱，然后数点

---
把DP的一维放到表示的数值，最后维度和数值做运算求答案

---
拆贡献，比如区间贡献拆为元素贡献

这个思想可以抽象为整体不好想，可以去想局部，比如多个前缀上的操作，但是位置固定，就可以划分为每个段的贡献

---
只计算当前元素对之前元素的贡献，可以避免重复

---
推公式推出精确解，不要想当然

该分类讨论还是分类讨论，暴力不一定对

---
当可以修改区间影响，可以去掉影响再重新赋予，修改影响较难思考

---
当前元素构造方案之前，如果和之前合法方案做交换，可以不使答案更劣，就交换

---
直接计算答案有困难，可以考虑从相邻点的答案转移过去（特别是双指针）

有序可以转化为两个不同的数，最早位置和最晚位置的比较

---
在保证同样效果的前提下，弱化操作可以影响更少信息，可能更好解

---
奇偶性，周期性

---
换枚举东西

---
所有构造的方案里，距离差可以转化为该点选进方案的时间差，时间差只在选进的点和没选进的店之间贡献

设虚点，实点占据虚点的位置来方便修改

每个点有各自需要经过目标点，让所有点先汇聚到一起，再一起行动整个图

每个点有各自需要经过目标点，让所有点先汇聚到一起，再一起行动整个图

适当强化或弱化操作，可以影响更少，或者把多个操作绑定在一起

小区间向大区间转移，左右指针同时向外移动一步，比只移动一侧指针，影响的更少

同时操作x和x+1，影响更小

极长区间的贡献，减去相邻极长区间重叠部分的贡献

关注最终构造结果去贪心

观察选与不选的贡献区别

限跌令使得一段操作是无效操作

先构造一个不一定最优的方案，然后尝试优化它
# 位运算
$a+b=(a\oplus b)+((a\&b)<<1)$

把异或看成不进位的加法，与看成计算进位，左移一下加上去，刚好是和

$a\oplus b=\sum\limits_{i=0}^{30}2^i[a_i\ne b_i]$
## 内建函数
1. int __builtin_ffs(int x) ：返回 x 的二进制末尾最后一个 1 的位置，位置的编号从 1 开始（最低位编号为 1 ）。当 x 为 0 时返回 0 。

2. int __builtin_clz(unsigned int x) ：返回 x 的二进制的前导 0 的个数。当 x 为 0 时，结果未定义。

3. int __builtin_ctz(unsigned int x) ：返回 x 的二进制末尾连续 0 的个数。当 x 为 0 时，结果未定义。

4. int __builtin_clrsb(int x) ：当 x 的符号位为 0 时返回 x 的二进制的前导 0 的个数减一，否则返回 x 的二进制的前导 1 的个数减一。

5. int __builtin_popcount(unsigned int x) ：返回 x 的二进制中 1 的个数。

6. int __builtin_parity(unsigned int x) ：判断 x 的二进制中 1 的个数的奇偶性。

这些函数都可以在函数名末尾添加 ll （如 __builtin_popcountll ）来使参数类型变为 ( unsigned ) long long （返回值仍然是 int 类型）。
## 枚举子集超集
```cpp
for(int i=mask;i;i=(i-1)&mask)
//枚举子集,O(2^{popcount})
//没有考虑0，如果需要则特判
for(int i=0;i<(1<<n);++i)
    for(int j=i;j;j=(j-1)&i)
//枚举每个子集的子集，O(3^n)
for(int i=mask;i<MAX;i=(i+1)|mask)
//枚举超集,O(2^{TotalDigit-popcount})
```
# 随机
## 随机数生成器(random number generator)
这里介绍 mt19937,mt19937_64,uniform_int_distribution,uniform_real_distribution

mt19937、mt19937_64 前者产生32位(unsigned int)随机数，后者产生64位(unsigned long long)随机数。如果用signed存储会有负数。

随机数产生需要种子，当种子固定时产生的随机数固定，所以需要变化的种子，这里介绍 &lt; chrono &gt; 的chrono::steady_clock::now().time_since_epoch().count()
```cpp
#include<chrono>
#include<iostream>
#include<random>
using namespace std;
int main()
{
    mt19937 rng1(chrono::steady_clock::now().time_since_epoch().count());
    auto random_address = [] { char *p = new char; delete p; return uint64_t(p); };
    mt19937_64 rng2(chrono::steady_clock::now().time_since_epoch().count() * (random_address() | 1));
    mt19937 rng3(random_device{}());
    cout<<rng1()<<" "<<rng2()<<" "<<rng3();
}
```
当需要产生区间内随机数，用mt19937取模会导致不均匀，所以使用uniform_int_distribution，特别地，需要两次种子才能使随机数不重复
```cpp
#include<iostream>
#include<random>
#include<chrono>
using namespace std;
int main()
{
    mt19937 seed(chrono::steady_clock::now().time_since_epoch().count());
    uniform_int_distribution<> rng(114,514);
    for(int i=0;i<10;++i)
        cout<<rng(seed)<<"\n";
}
```
## 随机序列
由于random_shuffle使用了rand，所以不可靠，你可以使用 &lt; algorithm &gt; 的shuffle搭配mt19937
```cpp
#include<iostream>
#include<random>
#include<chrono>
#include<algorithm>
using namespace std;
const int N=50;
int main()
{
    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
    vector<int> permutation(N);
    for (int i = 0; i < N; i++)
        permutation[i] = i;
    shuffle(permutation.begin(), permutation.end(), rng);
    for (int i = 0; i < N; i++)
        cout<<permutation[i]<<"\n";
}
```
给定数组a，问是permutation的区间的个数

把1-n都分配一个64位随机数，然后做前缀异或permutationXOR

对原数组，用分配给a[i]的随机数，做前缀异或preXOR

如果区间[l,r]是permutation，那么区间的最大值等于区间长度，且preXOR[r]^preXOR[l-1]=premutationXOR[r-l+1]

因为permutation改变位置不改变异或值，用随机避免了冲突。统计时枚举1开始的位置，先考虑最大值在1右边的，再翻转a，考虑最大值在1左边的。最后加上1的个数
# 模拟退火
当前点附近随机选择一点，如果更高就往那里走，否则有概率走到那里

当随时间流逝，选择的点和当前点之间的距离越来越小

如果一遍模拟退火不能得到正解，可以多跑几遍模拟退火提高正确率

如果求解的函数是个多峰函数，还可以采取分块模拟退火，即把值域分成多段，每段分别模拟退火，最后统一答案

还有一种名为卡时的技巧，也就是在到达时间限制前，一直跑模拟退火下去
```cpp
//T：当前剩余时间，一般取2000-3000
//T_min：日落时分，因为乘法永远无法使得T变为0，所以需要一个极小的数来代替0,比如1e-9
//r：时间流逝速率,一般取0.85-0.997
//H(a)：a处的高度
array<double, 3> SA(double inix, double iniy)
{
    mt19937 mt(time(0));
    uniform_real_distribution<double> rd(-1, 1), rd2(0, 1);
    array<double, 3> ans = {inix, iniy, H(inix, iniy)};
    array<double, 3> now = ans;
    for(double T = 233;T >1e-9;T*=0.95)
    {
        double nxtX = now[0] + rd(mt) * T, nxtY = now[1] + rd(mt) * T;
        array<double, 3> nxt = {nxtX, nxtY, H(nxtX, nxtY)};
        double dE = nxt[2] - now[2];
        if (dE < 0 || exp(-dE / T) > rd2(mt))
            now = nxt;
        if (now[2] < ans[2])
            ans = now;
    }
    return ans;
}
```
# 点分治(重心剖分)
对无根树上所有满足XX限制的链，求一些信息。朴素想法是枚举根作为链的一端，dfs一遍，复杂度 $O(n^2)$

基于分治思想，每次都选择一个点作为根，先计算包含根的路径的贡献

剩下的贡献是不包含根的路径，因此删除该点，对所有子树递归地处理

包含根的路径，等价于两条链拼接起来，两条链满足，公共端点是根，另一个端点来自不同子树

选择树的重心作为根，那么复杂度就可以保证为 $O(n\log n)$
## 实现
```cpp
namespace CentroidDecomposition
{
    int siz[N],del[N];
    int centroid(int u, int fa, int m)
    {
        siz[u] = 1;
        int ctr, mss = 0;
        for (auto &v : e[u])
            if (v != fa && !del[v])
            {
                ctr = centroid(v, u, m);
                if (ctr)
                    return ctr;
                mss = max(mss, siz[v]);
                siz[u] += siz[v];
            }
        mss = max(mss, m - siz[u]);
        if (mss <= m / 2)
        {
            siz[fa] = m - siz[u];
            return u;
        }
        return 0;
    }
    ll cal(int u, int fa, int dep)
    {
        ll ans = 0;
        //计算包含根的链的贡献，根为dec调用时的u
        for (auto &v : e[u])
            if (v != fa && !del[v])
                ans += cal(v, u, dep + 1);
        return ans;
    }
    ll dec(int u)
    {
        ll ans = 0;
        for (auto &v : e[u])
            if (!del[v])
            {
                ans += cal(v, u,1);
                //把v子树的贡献移到u子树的前i棵子树
            }
        //清空u子树的贡献
        del[u] = 1;
        for (auto &v : e[u])
            if (!del[v])
                ans += dec(centroid(v, u, siz[v]));
        return ans;
    }
    ll run(int n)
    {
        memset(del,0,sizeof(int)*(n+1));
        return dec(centroid(1, 0, n));
    }
};
```
