- 概率论
- 组合数学
  - 导读
  - 组合数取模
  - 球盒问题
  - 容斥原理
  - 卡特兰数高精
  - 二项式反演
  - 反演
- 群论
- 线性代数
  - 导读
  - 矩阵快速幂
  - 高斯消元
- 数论
  - 导读
  - Miller-Rabin
  - 逆元
  - 积性函数筛
  - 拓展欧拉定理
  - 卷积&莫反
  - 卷积&莫反例题
  - 杜教筛
  - 原根
  - bsgs&EXbsgs
  - crt&EXcrt
  - EXgcd
  - min25筛
  - pollard-Rho
- 多项式
  - fft
  - ntt
  - 拉格朗日插值
- 高数
- 杂

# 概率论

计算某个事件的概率和期望

当概率论和 DP 复合时，问题转化为图上问题，状态看成点，状态转移看成边

如果该问题无后效性，那么按照拓扑序 DP，否则高斯消元

如果纯概率论题，套公式即可

## 简要概念&公式

### 随机变量

值无法预先确定，仅以一定可能性取值的量

按照值的数量分为

离散型，值数量有限

连续型，值数量无限

> 以下按照这个分类讲述

### 连续型概率

$$\forall a，P(X=a)=0$$
设随机变量 $X$，设密度函数 $f$
$$P(a<X\le b)=\int_{a}^bf(x)dx$$
密度满足
$$\int_{-\infty}^{+\infty}f(x)dx=1$$
分布函数$F(x)$
$$F(x)=P(X\le x)=\int_{-\infty}^xf(x)dx$$
若$F(x)$处处连续可微，则
$$F'(x)=f(x)$$

### 分布函数性质

1. $F(-\infty)=0，F(+\infty)=1$
2. $F(x)$ 单调非递减

### 离散型概率

发生事件 $A$ 的概率，记做 $P(A)$

加法公式
$$P(A\cup B)=P(A)+P(B)-P(A\cap B)$$
$P(A\cup B)$ 表示发生 A 或 B 的概率

$P(A\cap B)$ 表示同时发生 A 和 B 的概率，以下简写为 $P(AB)$

条件概率
$$P(B|A)=\frac{P(AB)}{P(A)}$$
$P(B|A)$ 表示已经发生 $A$，再发生 $B$ 的概率

乘法公式
$$P(AB)=P(A)P(B|A)=P(B)P(A|B)$$

全概率公式
$$P(B)=\sum\limits_{i=1}^nP(A_i)P(B|A_i)$$

贝叶斯公式
$$P(B_i|A)=\frac{P(B_i)P(A|B_i)}{\sum\limits_{j=1}^nP(B_j)P(A|B_j)}$$

### 连续型期望

$$E(X)=\int_{-\infty}^{+\infty}xf(x)dx$$

### 离散型期望

$$E(X)=\sum\limits_{i=1}^nx_iP_i$$

### 期望性质

全期望公式
$$E(Y)=\sum P(X=a)E(Y|X=a)$$
期望的线性性
$$E(aX+b)=aE(x)+b$$
$$E(X+Y)=E(X)+E(Y)$$
若 $X，Y$ 独立，则
$$E(XY)=E(X)E(Y)$$
独立：$P(AB)=P(A)P(B)$

## 概率 DP

根据全概率公式，设点 $v$ 的入边的另一个点 $u$
$$P(v)=\sum P(u)P(v|u)$$

## 期望 DP

### 递推公式

$P(X)，E(X)$ 表示$X$ 到终点的概率，期望

如果有自环，需要移项使得两边没有同样的式子

需要建反图跑 DP

（统计出边）
$$E(Y)=\sum [E(X)+W(Y\rightarrow X)P(Y)]P(X|Y)$$

## 期望和概率的一个联系

全集有 n 种数，手上有 i 种数，全集中随机选数

获得新数的概率是 $\frac {n-i}n$

取得新数要取的次数的期望为 $\frac 1p=\frac n{n-i}$

那么获得全集的次数为 $\sum\limits_{i=0}^{n-1} \frac n{n-i}=\sum\limits_{i=1}^{n-1} \frac ni$

Q:为什么期望是概率分之一

A:如果你平均取 n 个球才会出现 1 个红球，也就是说期望是 n，那又可以说成是平均每 n 个球中出现 1 个红球，所以概率是 $\frac{1}{n}$

也可以用 DP 解释

设 $f_i$ 表示已取到 i 种数，还需要取的次数的期望

可得 $f_{i}=f_{i+1}\times \frac {n-i}n+f_{i}\times \frac {i}n+1$

可得 $f_{i}=f_{i+1}+\frac n{n-i}$

## min-max 容斥计算期望

$$max(S)=\sum\limits_{T\subseteq S}min(T)(-1)^{|T|-1}$$
max 表示满足所有条件的期望，min 表示满足至少一个条件的期望
# 组合数学导读

## 排列数&组合数

### 排列数

$n$ 个数选 $m$ 个排列，情况总数=$A_n^m=\frac{n!}{(n-m)!}$

全排列，指 $n$ 个数选 $n$ 个排列，情况总数=$A_n^n=n!$

### 组合数

$n$ 个数选 $m$ 个组合，情况总数=$C_n^m=\frac{n!}{m!(n-m)!}$

组合数也常用$\displaystyle\binom{n}{m}$表示

组合数也被称为“二项式系数”
## 二项式定理

$$(a+b)^n=\sum\limits_{i=0}^n \displaystyle\binom{n}{i} a^ib^{n-i}$$

## 多重集

### 多重集的排列数

$$\frac{n!}{\prod_{i=1}^k(n_i!)}$$

### 多重集的组合数

$$\binom{r+k-1}{k-1}$$

## 不相邻的排列

$1 \sim n$ 这 $n$ 个自然数中选 $k$ 个，这 $k$ 个数中任何两个数都不相邻的组合有 $\displaystyle \binom {n-k+1}{k}$ 种。

## 圆排列

$n$ 个人全部来围成一圈，所有的排列数记为 $\mathrm Q_n^n$。考虑其中已经排好的一圈，从不同位置断开，又变成不同的队列。
所以有

$$\mathrm Q_n^n \times n = \mathrm A_n^n \Longrightarrow \mathrm Q_n = \frac{\mathrm A_n^n}{n} = (n-1)!$$

由此可知部分圆排列的公式：

$$\mathrm Q_n^r = \frac{\mathrm A_n^r}{r} = \frac{n!}{r \times (n-r)!}$$

## 组合数性质

$$\binom{n}{m}=\binom{n}{n-m}\tag{1}$$

相当于将选出的集合对全集取补集，故数值不变。（对称性）

$$\binom{n}{k} = \frac{n}{k} \binom{n-1}{k-1}\tag{2}$$

由定义导出的递推式。

$$\binom{n}{m}=\binom{n-1}{m}+\binom{n-1}{m-1}\tag{3}$$

组合数的递推式（杨辉三角的公式表达）

$$\binom{n}{0}+\binom{n}{1}+\cdots+\binom{n}{n}=\sum_{i=0}^n\binom{n}{i}=2^n\tag{4}$$

这是二项式定理的特殊情况。取 $a=b=1$ 就得到上式。

$$\sum_{i=0}^m \binom{n}{i}\binom{m}{m-i} = \binom{m+n}{m}\ \ \ (n \geq m)\tag{5}$$

拆组合数的式子，在处理某些数据结构题时会用到。

$$\sum_{i=0}^n\binom{n}{i}^2=\binom{2n}{n}\tag{6}$$

这是 $(5)$ 的特殊情况，取 $n=m$ 即可。

$$\sum_{i=0}^ni\binom{n}{i}=n2^{n-1}\tag{7}$$

带权和的一个式子，通过对 $(3)$ 对应的多项式函数求导可以得证。

$$\sum_{i=0}^ni^2\binom{n}{i}=n(n+1)2^{n-2}\tag{8}$$

与上式类似，可以通过对多项式函数求导证明。

$$\sum_{l=0}^n\binom{l}{k} = \binom{n+1}{k+1}\tag{9}$$

在恒等式证明中较常用。

$$\binom{n}{r}\binom{r}{k} = \binom{n}{k}\binom{n-k}{r-k}\tag{10}$$

通过定义可以证明。

$$\sum_{i=0}^n\binom{n-i}{i}=F_{n+1}\tag{11}$$

其中 $F$ 是斐波那契数列。
## 常见数列

### 错排问题

$f_n=(n-1)(f_{n-1}+f_{n-2})$。

错位排列数列的前几项为 $0,1,2,9$。

### 卡特兰数

#### 经典题：进出栈序列

n 个元素进栈序列为：1，2，3，4，...，n，则有多少种出栈序列

我们将进栈表示为 +1，出栈表示为 -1

出栈序列的所有前缀和必然大于等于 0，并且序列 +1 的数量 等于 -1 的数量

接下来让我们观察一下 n = 3 的一种出栈序列：+1 -1 -1 +1 -1 +1。序列前三项和小于 0，显然这是个非法的序列。

如果将 第一个 前缀和小于 0 的前缀，即前三项元素都进行取反，就会得到：-1 +1 +1 +1 -1 +1。此时有 3 + 1 个 +1 以及 3 - 1 个 -1。

因为这个小于 0 的前缀和必然是 -1，且 -1 比 +1 多一个，取反后，-1 比 +1 少一个，则 +1 变为 n + 1 个，且 -1 变为 n - 1 个。进一步推广，对于 n 元素的每种非法出栈序列，都会对应一个含有 n + 1 个 +1 以及 n - 1 个 -1 的序列。

如何证明这两种序列是一一对应的？

假设非法序列为 A，对应的序列为 B。每个 A 只有一个"第一个前缀和小于 0 的前缀"，所以每个 A 只能产生一个 B。而每个 B 想要还原到 A，就需要找到"第一个前缀和大于 0 的前缀"，显然 B 也只能产生一个 A。

每个 B 都有 n + 1 个 +1 以及 n - 1 个 -1，因此 B 的数量为 $\dbinom {2n}{n+1}$ ，相当于在长度为 2n 的序列中找到 n + 1 个位置存放 +1。相应的，非法序列的数量也就等于 $\dbinom {2n}{n+1}$ 。

出栈序列的总数量共有 $\dbinom {2n}{n}$ ，因此，合法的出栈序列的数量为 $\dbinom {2n}{n}-\dbinom {2n}{n+1}$ 。

此时我们就得到了卡特兰数的通项 $\dbinom {2n}{n}-\dbinom {2n}{n+1}=\dbinom{2n}{n}/(n+1)$

#### 例题

n 对括号，则有多少种 “括号匹配” 的括号序列

左括号+1，有括号-1

n + 1 个叶子节点能够构成多少种形状不同的满二叉树

> 如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。

非叶节点，左子树+1，右子树-1

电影票一张 50 coin，且售票厅没有 coin。m 个人各自持有 50 coin，n 个人各自持有 100 coin。则有多少种排队方式，可以让每个人都买到电影票。

50+1，100-1

公式不同，$\dbinom {n+m}n-\dbinom{n+m}{m+1}$

节点数为 $i$ 时二叉树构造的方案数

> 写题就是寻找满足下列公式的特点

#### 公式

$C_n=\dbinom{2n}{n}/(n+1)$

$C_1=1,C_n=C_{n-1}\times\frac{4n-2}{n+1}$

$C_n=\begin{cases}1&n=0,1\\\sum\limits_{i=1}^n C_{i-1}*C_{n-i}&2\le n\end{cases}$

$C_n=\dbinom {2n}{n}-\dbinom {2n}{n+1}$

# 组合数取模
## 阶乘
```cpp
const int N=1e6+3;
long long fac[N],inv[N];
long long fast_power(long long base, long long exponent)
{
    long long result = 1;
    for (; exponent > 0; exponent >>= 1)
    {
        if (exponent & 1)
            result = result * base % mod;
        base = base * base % mod;
    }
    return result;
}
void getC()
{
    fac[0]=1;
    for(int i=1;i<N;++i)
        fac[i]=fac[i-1]*i%mod;
    inv[N-1]=fast_power(fac[N-1],mod-2);
    for(int i=N-1;i;--i)
        inv[i-1]=inv[i]*i%mod;
}
long long C(int n,int m)
{
    return fac[n]*inv[m]%mod*inv[n-m]%mod;
}
```

## Lucas 定理

### 适用条件

$n,m$ 较大，$p$ 为素数

### 公式

$C(n,m)\%p=C(n/p,m/p)*C(n\%p,m\%p)\%p$

### 时间复杂度

$O(f(x)+g(n)log_p n)$

$f(x)$ 为预处理组合数的复杂度，$g(n)$ 为单次求组合数的复杂度

$p$ 小，逆元打表，$O(n+p+log_p n)$

//$n$ 为处理阶乘，$p$ 为打表，$log_p n$为单次查询

$p$ 大，exgcd 求逆元,$O(n+ln p*log_p n)$

//$n$ 为处理阶乘，$\ln p*log_p n$ 为单次查询

```c++
long long Lucas(long long n, long long m, long long p)
{
    if (m == 0) return 1;
    return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p;
}
```

## exLucas

### 适用条件

$n,m$ 较大，$p$ 不为素数

### 时间复杂度

$O(plog p)$

```c++
ll qpow(ll base,ll exponent,ll mod)
{
    ll result=1;
    for(;exponent;base=base*base%mod,exponent>>=1)
    {
        if(exponent&1)
            result=result*base%mod;
    }
    return result;
}
ll g(ll n,ll p)
{
    if(n<p)
        return 0;
    return g(n/p,p)+n/p;
}
ll calc(ll n,ll p,ll MOD)
{
    if(n==0)
        return 1;
    ll res=1;
    for(ll i=1;i<=MOD;i++)
    {
        if(i%p)
            res=res*i%MOD;
    }
    res=qpow(res,n/MOD,MOD);
    for(ll i=n/MOD*MOD+1;i<=n;i++)
    {
        if(i%p)
            res=res*(i%MOD)%MOD;
    }
    return res*calc(n/p,p,MOD)%MOD;
}
ll exgcd(ll a,ll b,ll &x,ll &y)
{
	if(!b) {x=1,y=0;return a;}
	ll r=exgcd(b,a%b,y,x);
	y-=x*(a/b);
	return r;
}
ll inv(ll a,ll n)
{
    ll x,y;
    if(exgcd(a,n,x,y)==1ll)
        return (x%n+n)%n;
    else
        return -1;
}
ll lucas(ll n,ll m,ll p,ll MOD)
{
    ll pw=qpow(p,g(n,p)-g(m,p)-g(n-m,p),MOD);
    return calc(n,p,MOD)*inv(calc(m,p,MOD),MOD)%MOD*inv(calc(n-m,p,MOD),MOD)%MOD*pw%MOD;
}
ll CRT(const vector<ll> &a,const vector<ll> &m)
{
    int siz=a.size();
    ll mul=1,sum=0;
    for(auto tmp:m)
        mul*=tmp;
    for(int i=0;i<siz;i++)
    {
        ll M=mul/m[i];
        sum=(sum+a[i]*M%mul*inv(M,m[i]))%mul;
    }
    return sum%mul;
}
ll exlucas(ll n,ll m,ll MOD)
{
    vector<ll> a,mod;
    ll tmp=MOD;
    for(int p=2;p<=tmp/p;p++)
    {
        if(tmp%p==0)
        {
            ll mul=1;
            while(tmp%p==0)
                mul*=p,tmp/=p;
            mod.push_back(mul),a.push_back(lucas(n,m,p,mul));
        }
    }
    if(tmp>1) mod.push_back(tmp),a.push_back(lucas(n,m,tmp,tmp));
    return CRT(a,mod);
}
```

# 球盒问题

$n$ 个球，放入 $m$ 个盒中,共 8 种情况

## 球同，盒不同，无空箱

$C(n-1,m-1)$

使用插板法：$n$ 个球中间有 $n-1$ 个间隙，现在要分成 $m$ 个盒子，而且不能有空箱子，所以只要在 $n-1$ 个间隙选出 $m-1$ 个间隙即可

## 球同，盒不同，允许空箱

$C(n+m-1,m-1)$

如果给每个盒子一个球，就可以把问题转化为不能空的情况了,就相当于 $n+m$ 个小球放入 $m$ 个盒子且不能空

## 球不同，盒相同，无空箱

第二类斯特林数 $dp[n][m]$

$dp[n][m]=\begin{cases}m\times dp[n-1][m]+dp[n-1][m-1]&1\le m<n\\1&m=n\\
0&1\le n&m=0\\
0&m>n \end{cases}$

$dp[n][m]$表示 $n$ 个球放在 $m$ 个箱子，每个箱子都有球

对于第 $n$ 个球，如果前面的 $n-1$ 个球已经放在了 $m$ 个箱子里，那么现在第 $n$ 个球放在哪个箱子都是可以的，所以 $m*dp[n-1][m]$

如果前 $n-1$ 个球已经放在了 $m-1$ 个箱子里，那么现在第 $n$ 个球必须要新开一个箱子来存放，（第 $m$ 个箱子现在没有球）所以 $dp[n-1][m-1]$

```c++
ll f(ll n, ll m)
{
    if (m == 0 || n < m)
        return 0;
    if (n == m)
        return 1;
    return f(n-1, m-1) + f(n-1, m) * m;
}
```

## 球不同，盒相同，允许空箱

$\sum\limits_{i=1}^m dp[n][i]$

$dp[n][m]$ 为第二类斯特林数,枚举使用的箱子的个数

## 球不同，盒不同，无空箱

$dp[n][m]*fac[m]$

$dp[n][m]$ 为第二类斯特林数,$fac[m]$ 为 $m$ 的阶乘

因为球是不同的，所以 $dp[n][m]$ 得到的盒子相同的情况，只要再给盒子定义顺序，就等于现在的答案了

## 球不同，盒不同，允许空箱

$m^n$

每个球都有 $m$ 种选择

## 球同，盒同，允许空箱

$dp[n][m]=\begin{cases} 1&n=0,1\\1&m=1\\dp[n][m-1]+dp[n-m][m]&m\le n\\
dp[n][m-1]&n<m\end{cases}$

可以选择在所有箱子里面都放上 $1$ 个球，也可以不选择这个操作。

如果选择了这个操作，那么就从 $dp[n-m][m]$ 转移过来

如果没有选择这个操作，那么就从 $dp[n][m-1]$ 转移过来

```c++
ll f(ll n,ll m)
{
    if(n==1 || m==1 || n==0)
        return 1;
    if(n<m)
        return f(n,n);
    return f(n,m-1)+f(n-m,m);
}
```

## 球同，盒同，无空箱

$dp[n-m][m],m\le n$ ，dp 同第 7 种情况

因为要求无空箱，我们先在每个箱子里面放 $1$ 个球，然后还剩下 $n-m$ 个球了，再根据情况 7 答案就出来了

# 容斥原理
## min-max 容斥

通过集合最小值计算集合最大值，或者反过来
$$max(S)=\sum\limits_{T\subseteq S}min(T)(-1)^{|T|-1}$$
$|T|$ 表示 $T$ 的元素个数
$$min(S)=\sum\limits_{T\subseteq S}max(T)(-1)^{|T|-1}$$
如果只是计算集合最大最小值，$O(n)$ 即可完成，但是这个结论可以放到期望上

即，max 表示满足所有条件的期望，min 表示满足至少一个条件的期望

## Kthmin-max 容斥

$$Kthmax(S)=\sum\limits_{T\subseteq S}min(T)\dbinom{|T|-1}{k-1}(-1)^{|T|-k}$$

## gcd-lcm 容斥

$$lcm(S)=\sum\limits_{T\subseteq S}gcd(T)(-1)^{|T|-1}$$

# 卡特兰数高精

$C_n=\dbinom{2n}{n}/(n+1)$

将乘除部分按照质因数存储，乘法即答案的相应质因数 +1 ，除法则 −1 ，可以优化掉高精除低精这个过程。

同时，应用高精度压位技巧，即数组中的每一位存储多个数字

```c++
typedef long long ll;
int exponential[1010];
struct big
{
    int len;
    ll x[1000];
    int bit=1e9;
    ll& operator [](int a)
    {return x[a];}
    friend void operator *=(big &a,int b)
    {
        int len=a.len,bit=a.bit;
        for(int i=1;i<=len;i++)a[i]*=b;
        int now=1;
        while(now<=len)
        {
            if(a[now]>=bit)a[now+1]+=a[now]/bit,a[now]%=bit;
            if(now==len&&a[len+1])len++;
            now++;
        }
        a.len=len;
    }
    void print()
    {
        cout<<x[len];
        for(int i=len-1;i>=1;i--)
            cout<<setw(9)<<setfill('0')<<x[i];
    }
}catalennumber;
void add(int x,int v)
{
    for(int i=2;i*i<=x;++i)
    {
        while(x%i==0)
        {
            x/=i;
            exponential[i]+=v;
        }
    }
    if(x!=1)
        exponential[x]+=v;
}
void catalan(int n)
{
    int t=n<<1;
    for(int i=n+2;i<=t;++i)
        add(i,1);
    for(int i=1;i<=n;++i)
        add(i,-1);
    catalennumber[1]=catalennumber.len=1;
    for(int i=1;i<=t;++i)
    {
        while(exponential[i])
        {
            catalennumber*=i;
            --exponential[i];
        }
    }
    catalennumber.print();
}
```
# 二项式反演
## 形式1
$f(k)=\sum\limits_{i=k}^n \dbinom ik g(i)$

$g(k)=\sum\limits_{i=k}^n (-1)^{i-k}\dbinom ikf(i)$
## 形式2
$f(k)=\sum\limits_{i=m}^{k} \dbinom ki g(i)$

$g(k)=\sum\limits_{i=m}^k (-1)^{k-i}\dbinom kif(i)$
# 反演
$f_x=\sum\limits_{y=1}^nA_{x,y}g_y$

$g_x=\sum\limits_{y=1}^nB_{x,y}f_y$

把 $A,B$ 看成矩阵

满足上面式子的 $A,B$ 满足 $A*B=I$

所以已知 $f,A$ 可以求出 $A$ 的逆矩阵 $B$ 来求出 $g$
# 群论

## 群

设 $G$ 是一个集合

$*$ 是 $G$ 上的二元运算，如果 $(G,*)$ 满足下面 4 个条件,则称 $(G,*)$ 为一个群。

1. 封闭性：$\forall a,b∈G$ ,有 $a*b∈G$;

2. 结合律：$\forall a,b,c∈G$，有 $(a*b)*c=a*(b*c)$;

3. 单位元：存在 $e∈G$ ,使得 $\forall a∈G$,都有$a*e=e*a=a$;

4. 逆元：$\forall a∈G,\exists x∈G$,使得 $a*x=x*a=e$,这个时候记 $x$ 为 $a^{-1}$，称为 $a$ 的逆元

群元素的个数有限，称为有限群，且其中元素的个数称为阶，记为 $|G|$

---

## 置换

设 $X$ 为一个有限集，对集合的元素进行任意的排序，那么称排序后的结果 $π$ 是 $X$ 上的一个置换。

//有限集是元素个数有限的集合

设 $X=\{1,2,3,4....n\}$

设 $π$ 是 $X$ 的一个置换
其中 $a_1,a_2,...,a_n$ 是 $X$ 的一个排列

可将 $π$ 记为 $\begin{matrix}1&2&......&n\\a_1&a_2&......&   a_n\end{matrix}$

同一置换用这样的表示法有 $n!$ 种，但其对应的关系不变。

设置换 $π$ 的部分元素的对应关系如下

$π$：$\begin{matrix}a_1&a_2&...&a_k\\a_2&a_3&...&a_1\end{matrix}$

称为 $k$ 阶循环，$k$ 为循环长度。

//不一定连续，不一定从 1 开始

每个置换都可以写成若干个互不相交的循环节的乘积，且表示是唯一的.

> 对着例子理解这句话，一定要理解

### 例子

$π$：$\begin{matrix}1&2&3&4&5&6\\2&4&5&1&3&6\end{matrix}$

可以表示为$(124)(35)(6)$,置换的循环节数是 3,记为 C(π)

# Polya 定理

设 $G=\{π_1,π_2,π_3,...,π_k\}$是 $X=\{a_1,a_2,a_3,...,a_n\}$ 上一个置换群，

//置换的集合即为置换群

用 $m$ 种颜色对 $X$ 中的元素进行涂色，那么不同的涂色方案数为：

$\frac{1}{|G|} * \sum\limits_{i=1}^{k} m^{C(π_i)}$

---

## 例题

黑白两种颜色对下面的 2\*2 方格进行染色,

如果允许方格可以绕中心点旋转, 问有多少种不同的着色方案数?

$\begin{matrix}1&2\\3&4\end{matrix}$

---

方格可以旋转 $0°,90°,180°,270°$.

所以群 $G = \{0°,90°,180°,270°\}$ ,$|G| = 4$

$G$ 中 所有的置换是

$π_1 = (1)(2)(3)(4)$

$π_2 = (1234)$

$π_3 = (14)(23)$

$π_4 = (1432)$

$c(π_1) = 4 , c(π_2) = 1  , c(π_3) = 2 , c(π_4) = 1$

带入 Polya 定理

$ans = \frac{1}{4}*(2^4+2^1+2^2+2^1) = 6$

---

## 原理

当只有旋转的时候(顺时针或逆时针)，

对于一个有 $n$ 个元素的环，可顺时针或逆时针旋转几个位置，

由于至少有 $n$ 个置换，

但是假设我顺时针旋转 $k$ 个位置，他就等同于逆时针转动 $n-k$ 个位置，

假设一个置换为:

$G=\{π_0,π_1,π_2,...,π_{n-1}\}$

这个时候可以证明

逆时针旋转 $k$ 个位置时

$π_k$ 的循环节数为 $gcd(n,k)$

且每个循环的长度为 $L=n/gcd(n,k)$

---

上面那个例题只考虑了旋转的情况

## 翻转

- 当 $n$ 为奇数的时候，只有一种形式，

以顶点 $i$ 与中心的连线为轴的翻转

$π_i=\begin{matrix}...&i-1&i&i+1&...\\...&i+1&i&i-1&...\end{matrix}$

有 $n$ 个循环节数为 $(n+1)/2$ 的置换

- 当 n 为偶数时，有两种形式：

1. 以顶点 $i$ 与中心的连线为轴的翻转

$π_i=\begin{matrix}...&i-1&i&i+1&...\\...&i+1&i&i-1&...\end{matrix}$

有 $n/2$ 个循环节数为 $n/2+1$ 的置换

2. 以顶点 $i$ 和 $i+1$ 的中点与中心的连线为轴翻转

$π_i=\begin{matrix}...&i-1&i&i+1&...\\...&i+2&i+1&i&...\end{matrix}$

有 $n/2$ 个循环节数为 $n/2$ 的置换

> 要特别注意 $0$ 的情况，输出 $0$ 即可。

由于旋转有 $n$ 种置换，翻转也有 $n$ 种置换，所以 $|G|=2n$

```c++
typedef long long ll;
ll fast_power(ll base,ll exponent)
{
    ll result=1;
    while(exponent>0)
    {
        if(exponent&1)
            result=result*base;
        base=base*base;
        exponent>>=1;
    }
    return result;
}
ll polya(ll n,ll m)
{
    if(!n)
        return 0;
    ll sum=0;
    for(ll i=0;i<n;++i)
        sum+=fast_power(m,__gcd(n,i));
    if(n&1)
        sum+=n*fast_power(m,(n+1)/2);
    else
        sum+=n/2*(1ll+m)*fast_power(m,n/2);
    sum/=(2*n);
    return sum;
}
```

# 矩阵快速幂

给出底矩阵和指数，快速求出幂矩阵

也就是把对整数的操作移植到矩阵上来

一般会复合一些 dp

## 时间复杂度

$O(t^3*log n)$,$t$ 是矩阵边长，$t^3$ 表示矩阵乘法

## 常见多项式抽象

1. $f(n) = a * f(n-1) + b * f(n-2) +c$

$\begin{pmatrix}a&b&1\\1&0&0\\0&0&1\end{pmatrix}*
\begin{pmatrix}f(n-1)\\f(n-2)\\c\end{pmatrix}=
\begin{pmatrix}f(n)\\f(n-1)\\c\end{pmatrix}$

2. $f(n) = f(n-1) + c^n$

$\begin{pmatrix}1&c\\0&c\end{pmatrix}*
\begin{pmatrix}f(n-1)\\c^{n-1}\end{pmatrix}=
\begin{pmatrix}f(n)\\c^{n}\end{pmatrix}$

3. $f(n)= f(n-1) + n^3$

因为

$n^3$

$= (n - 1 + 1)^3$

$= C(0,3)*(n-1)^3 + C(1,3)*(n-1)^2 + C(2,3)*(n-1)^1 + C(3,3)*(n-1)^0$

所以

$\begin{pmatrix}1&C(0,3)&C(1,3)&C(2,3)&C(3,3)\\
0&C(0,3)&C(1,3)&C(2,3)&C(3,3)\\
0&0&C(0,2)&C(1,2)&C(2,2)\\
0&0&0&C(0,1)&C(1,1)\\
0&0&0&0&C(0,0)\end{pmatrix}*
\begin{pmatrix}f(n-1)\\(n-1)^3\\(n-1)^2\\(n-1)^1\\(n-1)^0\end{pmatrix}=
\begin{pmatrix}f(n)\\n^3\\n^2\\n^1\\n^0\end{pmatrix}$

# 高斯消元

求解线性方程组和异或方程组，求矩阵的逆

用的是高斯约旦消元法，比普通高斯消元法精度更高，代码更简洁

## 时间复杂度

$O(n^3)$

稀疏矩阵可以观察稀疏的地方并优化

## 线性方程组

形式如下
$$\begin{cases}a_{11}x_1+a_{12}x_2+...+a_{1n}x_n=b_1\\ a_{21}x_1+a_{22}x_2+...+a_{2n}x_n=b_2\\...\\a_{n1}x_1+a_{n2}x_2+...+a_{nn}x_n=b_n\end{cases}$$
写成矩阵形式，AX=B
$$A=\begin{vmatrix}a_{11}&a_{12}&...&a_{1n}\\a_{21}&a_{22}&...&a_{2n}\\...\\a_{n1}&a_{n2}&...&a_{nn}\end{vmatrix},X=\begin{vmatrix}x_1\\x_2\\...\\x_n\end{vmatrix},B=\begin{vmatrix}b_1\\b_2\\...\\b_n\end{vmatrix}$$

程序求解就是增广矩阵行初等行变换为行最简形：
$$\begin{vmatrix}a_{11}&a_{12}&...&a_{1n}&b_1\\a_{21}&a_{22}&...&a_{2n}&b_2\\...\\a_{n1}&a_{n2}&...&a_{nn}&b_n\end{vmatrix}\rightarrow\begin{vmatrix}1&0&...&0&c_1\\0&1&...&0&c_2\\...\\0&0&...&1&c_n\end{vmatrix}$$
这样 $X$ 就等于
$$\begin{vmatrix}c_1\\c_2\\...\\c_n\end{vmatrix}$$

## 矩阵求逆

对 $n$ 阶矩阵 $A$，构造 $n\times 2n$ 的矩阵 $(A,I_n)$

高斯消元化成 $(I_n,A^{-1})$

如果左半部分不能化成单位矩阵，则矩阵 $A$ 不可逆

## 异或方程组

异或运算满足交换律和结合律，所以可以使用类似高斯消元的方法解决方程组

形式如下,且所有系数（即 a 和 b）均为 0 或 1
$$\begin{cases}a_{11}x_1\oplus a_{12}x_2\oplus ...\oplus a_{1n}x_n=b_1\\ a_{21}x_1\oplus a_{22}x_2\oplus ...\oplus a_{2n}x_n=b_2\\...\\a_{n1}x_1\oplus a_{n2}x_2\oplus ...\oplus a_{nn}x_n=b_n\end{cases}$$
应使用“异或消元”而非“加减消元”，且不需要进行乘除改变系数（因为系数均为 0 和 1）。

注意到异或方程组的增广矩阵是 01 矩阵，可以用 bitset 优化

# 行列式

矩阵应用高斯消元，得到一个对角线矩阵，此矩阵的行列式由对角线元素之积所决定。其符号可由交换行的数量来确定（如果为奇数，则行列式的符号应颠倒）

# 矩阵快速幂

注意稠密矩阵和稀疏矩阵的乘法处理要不一样

```c++
const int N = 4;
struct matrix
{
    ll m[N][N];
    void init()//单位矩阵
    {
        memset(m,0,sizeof(m));
        for(int i=0;i<N;++i)
            m[i][i]=1;
    }
    matrix operator*(matrix y)
    {
        matrix c;
        memset(c.m,0,sizeof(c.m));
        //稠密矩阵
        for(int i=0;i<N;++i)
        {
            for(int j=0;j<N;++j)
            {
                for(int k=0;k<N;++k)
                    c.m[i][j] = (c.m[i][j] + m[i][k] * y.m[k][j] % mod) % mod;
            }
        }
        //稀疏矩阵(指矩阵中很多数为0)
        for(int i=0;i<N;++i)
        {
            for(int j=0;j<N;++j)
            {
                if(!m[i][j])
                    continue;
                for(int k=0;k<N;++k)
                    c.m[i][k] = (c.m[i][k] + m[i][j] * y.m[j][k] % mod) % mod;
            }
        }
        return c;
    }
    matrix operator^(ll exponent)
    {
        matrix result;
        result.init();
        for(;exponent;exponent>>=1)
        {
            if(exponent&1)
                result = result*(*this);
            (*this) = (*this)*(*this);
        }
        return result;
    }
};
matrix base{1,1,1,2,
            0,1,1,2,
            0,1,0,0,
            0,1,0,1};
base=base^(n-2);
ll ans=(((base.m[0][0]*2%mod+base.m[0][1])%mod+base.m[0][2])%mod+base.m[0][3])%mod;
```

# 高斯消元

注意处理无解，无穷解情况

-1 无解，0 无穷解，1 唯一解

# 线性方程组

```c++
const int N=1e2+1;
const double eps=1e-6;
double a[N][N],ans[N];
int GaussianElimination(int n)
{
    int i,maxx,j,k,cnt=0;
    double temp;
    for(i=0;i<n;++i)
    {
        maxx=cnt;
        for(j=cnt+1;j<n;++j)
        {
            if(fabs(a[j][i])>fabs(a[maxx][i]))
                maxx=j;
        }
        if(fabs(a[maxx][i])<eps)
            continue;
        if(maxx!=cnt)
            swap(a[maxx],a[cnt]);
        for(j=0;j<n;++j)
        {
            if(j==cnt)
                continue;
            temp=a[j][i]/a[cnt][i];
            for(k=i+1;k<=n;++k)
                a[j][k]-=a[cnt][k]*temp;
        }
        ++cnt;
    }
    if(cnt<n)
    {
        for(;cnt<n;++cnt)
        {
            if(fabs(a[cnt][n])>eps)
                return -1;
        }
        return 0;
    }
    for(i=0;i<n;++i)
        ans[i]=a[i][n]/a[i][i];
    return 1;
}
```

# 异或方程组

```c++
const int N=1e2+3;
bitset<N> a[N];
bitset<N> ans;
int GaussElimination(int n, int m)
{
    int i,j,cnt=0;
    for(i=0;i<n;++i)
    {
        for(j=cnt;j<m && !a[j][i];++j){}
        if(j==m)
            continue;
        if(j != cnt)
            swap(a[j], a[cnt]);
        for(j=0;j<m;j++)
        {
            if(cnt==j)
                continue;
            if(a[j][i])
                a[j]^=a[cnt];
        }
        ++cnt;
    }
    if(cnt<n)
    {
        for(;cnt<n;++cnt)
        {
            if(a[cnt][n])
                return -1;
        }
        return 0;
    }
    for (i = 0; i < n; i++)
        ans[i] = a[i][n];
    return 1;
}
```

# 行列式

```c++
const int N=1e2+1;
const double eps=1e-6;
double a[N][N];
double GaussianElimination(int n)
{
    int i,maxx,j,k;
    double temp,res=1;
    for(i=0;i<n;++i)
    {
        maxx=i;
        for(j=i+1;j<n;++j)
        {
            if(fabs(a[j][i])>fabs(a[maxx][i]))
                maxx=j;
        }
        if(fabs(a[maxx][i])<eps)
            return 0.0;
        if(maxx!=i)
        {
            swap(a[maxx],a[i]);
            res=-res;
        }
        res*=a[i][i];
        for(j=0;j<n;++j)
        {
            if(j==i)
                continue;
            temp=a[j][i]/a[i][i];
            if(fabs(temp)<eps)
                continue;
            for(k=i;k<=n;++k)
                a[j][k]-=a[i][k]*temp;
        }
    }
    return res;
}
```

# 数论导读

## 因子个数

$\prod\limits_{i=1}^s (1+k_i)$

## 因子和

$\prod\limits_{i=1}^s \frac{p_i^{k_i+1}-1}{p_i-1}
$

## $gcd$性质

$gcd(a,b)=gcd(a-b,b)$

$gcd(a,b)=gcd(a,a-b)$

$gcd(a,b)=gcd(b,a\%b)$

## 欧拉函数

$\sum\limits_{i=1}^{n} i*(gcd(i,n)==1)=n*φ(n)/2$

特例：$n=1,result=1$

> 一个常识：$d\mid i,d\mid j⇔d\mid gcd(i,j)$

# 米勒-拉宾素性检验
$2^{32}$ 以内，$2,7,61$

$2^{64}$ 以内，$2,325,9375,28178,450775,9780504,1795265022$

$2^{78}$ 以内，$2,3,5,7,11,13,17,19,23,29,31,37$
## 时间复杂度
$O(7log n)$
```c++
typedef unsigned long long ll;
ll fastPower(ll a, ll n, ll p)
{
    ll ans = 1;
    for(;n;n>>=1)
    {
        if (n & 1)
            ans = (__int128)ans * a % p; // 注意！中间结果可能溢出，需要使用__int128过渡
        a = (__int128)a * a % p;
    }
    return ans;
}
bool Miller_Rabin(ll x)
{
    if (x < 3)
        return x == 2;
    if ((x&1) == 0)
        return false;
    ll v,r=__builtin_ctz(x-1),d=x>>r;
    for (ll a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022})
    {
        v = fastPower(a, d, x);
        if (v <= 1 || v == x - 1)
            continue;
        for (int i = 0; i < r; ++i)
        {
            v = (__int128)v * v % x; // 同样使用__int128过渡
            if (v == x - 1 && i != r - 1)
            {
                v = 1;
                break;
            }
            if (v == 1)
                return false;
        }
        if (v != 1)
            return false;
    }
    return true;
}
```

# 逆元
```c++
long long exgcd(long long a,long long b,long long &x,long long &y)
{
	if(!b)
	{
		x=1;
		y=0;
		return a;
	}
	long long r=exgcd(b,a%b,y,x);
	y-=x*(a/b);
	return r;
}
long long inv(long long a,long long n)
{
    long long x,y;
    if(exgcd(a,n,x,y)==1ll)
        return (x%n+n)%n;
    else
        return -1;
}
```
```c++
const int N = 1e6 + 5;
long long inv[N];
void getinv()
{
    inv[1] = 1;
    for(ll i=2; i<N; ++i)
        inv[i] =  (mod - mod / i) * inv[mod%i] % mod;
}
```
```cpp
//a下标从1开始
const int N=1e5+3;
long long preprod[N],inv[N];
long long exgcd(long long a,long long b,long long &x,long long &y)
{
	if(!b)
	{
		x=1;
		y=0;
		return a;
	}
	long long r=exgcd(b,a%b,y,x);
	y-=x*(a/b);
	return r;
}
long long getinv(long long a,long long n)
{
    long long x,y;
    if(exgcd(a,n,x,y)==1ll)
        return (x%n+n)%n;
    else
        return -1;
}
void getINV(int n)
{
    preprod[0]=1;
    for(int i=1;i<=n;++i)
        preprod[i]=preprod[i-1]*a[i]%mod;
    long long sis=getinv(preprod[n],mod);
    for(int i=n;i>=1;--i)
    {
        inv[i]=sis*preprod[i-1]%mod;
        sis=sis*a[i]%mod;
    }
}
```
# 线性筛

## 欧拉函数 φ

```c++
const int N=1e7+3;
bitset<N> v;
int p[N>>2],phi[N];
void seive()
{
	int cnt=0;
    phi[1]=1;
    for(int i=2;i<N;++i)
    {
        if(!v[i])
        {
            p[cnt++]=i;
            phi[i]=i-1;
        }
        for(int j=0;j < cnt && p[j]*i < N;++j)
        {
            v[i*p[j]]=1;
            if(i%p[j]==0)
            {
                phi[i*p[j]]=phi[i]*p[j];
                break;
            }
			phi[i*p[j]]=phi[i]*(p[j]-1);
        }
    }
}
```

## 莫比乌斯函数 μ

```c++
const int N=1e7+3;
bitset<N> v;
int p[N>>2],mu[N];
void seive()
{
	int cnt=0;
	mu[1]=1;
	for(int i=2;i<N;++i)
	{
		if(!v[i])
		{
			p[cnt++]=i;
			mu[i]=-1;
		}
		for(int j=0;j < cnt && i*p[j] < N;++j)
		{
			v[i*p[j]]=1;
			if(!(i%p[j]))
				break;
			mu[i*p[j]]=-mu[i];
		}
	}
}
```

## 约数个数

```c++
//dn约数个数
const int N=1e7+3;
bitset<N> v;
int p[N>>2],dn[N],mpdn[N];
void seive()
{
	int cnt=0;
	for(int i=2;i<N;++i)
    {
        if(!v[i])
		{
			p[cnt++]=i;
			dn[i]=2;
			mpdn[i]=1;
		}
        for(int j=0;j < cnt && i*p[j] < N;++j)
        {
            v[i*p[j]]=1;
            if(i%p[j]==0)
            {
				mpdn[i*p[j]] = mpdn[i]+1;
                dn[i*p[j]]=dn[i]/(mpdn[i]+1)*(mpdn[i]+2);
                break;
            }
			dn[i*p[j]]=dn[i]*dn[p[j]];
			mpdn[i*p[j]]=1;
        }
    }
}
```

## 约数和

```c++
//sd约数和
const int N=1e7+3;
bitset<N> v;
int p[N>>2],sd[N],smpd[N];
void seive()
{
	int cnt=0;
    sd[1]=1;
    for(int i=2;i<N;++i)
    {
        if(!v[i])
		{
			p[cnt++]=i;
			sd[i]=i+1;
			smpd[i]=i+1;
		}
        for(int j=0;j<cnt && i*p[j]<N;++j)
        {
            v[i*p[j]]=1;
            if(i%p[j]==0)
            {
				smpd[i*p[j]]=smpd[i]*p[j]+1;
                sd[i*p[j]]=sd[i]/smpd[i]*smpd[i*p[j]];
                break;
            }
			sd[i*p[j]]=sd[i]*sd[p[j]];
			smpd[i*p[j]]=p[j]+1;
        }
    }
}
```

# 拓展欧拉定理

如果$gcd(a,n)\ne1$，且$b>φ(n)$时  
$a ^ b ≡ a ^ {b \% φ(n) + φ(n) } \pmod n$

# 狄利克雷卷积

## 常用数论函数

单位函数 $ε(n)=\begin{cases}1&n=1\\0&otherwise\end{cases}$

---

幂函数 $Id_k(n)=n^k$.  
k=1 时为恒等函数 $Id(n)$  
k=0 时为常数函数 $1(n)$

---

除数函数 $σ_k(n)=\sum\limits_{d\mid n} d^k$  
k=1 时为因数和函数 $σ(n)$  
k=0 时为因数个数函数 $σ_0(n)$  
$σ_0(n)$ 的一个性质：
$$σ_0(ij)=\sum_{x|i} \sum_{y|j} ε(gcd(x,y))$$
$$=\sum\limits_{d\mid \gcd(i,j)}μ(d)σ_0(i/d)σ_0(j/d)$$

---

欧拉函数 $φ(n)$

---

这些函数都是积性函数，前二者还是完全积性函数

## 常用数论函数联系

除数函数与幂函数  
 $Id_k*1=σ_k$  
欧拉函数与恒等函数  
 $φ*1=Id$  
注意：$1$此时是常数函数

## 狄利克雷卷积性质

1. 函数间交换律，即 $f*g=g*f$
2. 函数间结合律，即 $(f*g)*h=f*(g*h)$
3. 函数间卷积分配律，即  
   $(f*(g+h))(n)=(f*g)(n)+(f*h)(n)$
4. 若$f$,$g$是积性函数，则$f*g$也是积性函数
5. 函数常数间结合律，即 $(xf)*g=x(f*g)$
6. 单位元是单位函数$ε$
7. 狄利克雷逆存在必要条件是$f(1)\ne 0$，，没有在网上找到充分条件
8. 积性函数必然存在狄利克雷逆，且狄利克雷逆仍是积性函数。

## 狄利克雷逆求法

因为 $f*g=ε$，所以

$g(n)=\frac 1{f(1)}(ε(n)-\sum\limits_{i\mid n,i\ne 1} f(i)g(\frac ni))$

# 莫比乌斯反演

## 莫比乌斯函数

常数函数 $1$ 的狄利克雷逆，称之为莫比乌斯函数 $μ$

## 莫比乌斯反演公式

因数形式：  
$g(n)=\sum\limits_{d\mid n} f(d) ⇔ f(n)=\sum\limits_{d\mid n} μ(d)\times g(n/d)$  
狄利克雷卷积形式：  
$g=f*1 ⇔ f=g*u$  
倍数形式：  
$g(n)=\sum\limits_{n\mid N} f(N) ⇔ f(n)=\sum\limits_{n\mid N} g(N)\times μ(N/n)$

# 重要结论

给定一个函数 $f$，$g$ 满足 $f=1*g$

$\sum\limits_{i=1}^n\sum\limits_{j=1}^m f(gcd(i,j))=\sum\limits_{d=1}^{min(n,m)} g(d)\lfloor\frac nd\rfloor\lfloor\frac md\rfloor$

## 解题步骤

1. 将 $f$ 替换成题目所给具体函数
2. 预处理 $g$，$g=\mu*f$
3. 数论分块计算

## 卷积证明

枚举 gcd

$\sum\limits_{d=1}^{min(n,m)} f(d) \sum\limits_{i=1}^n\sum\limits_{j=1}^m [gcd(i,j)=d]$

枚举 d 的倍数

$\sum\limits_{d=1}^{min(n,m)} f(d) \sum\limits_{i=1}^{\lfloor\frac nd\rfloor}\sum\limits_{j=1}^{\lfloor\frac md\rfloor} [gcd(i,j)=1]$

$\mu * 1=\epsilon$

$\sum\limits_{d=1}^{min(n,m)} f(d) \sum\limits_{i=1}^{\lfloor\frac nd\rfloor}\sum\limits_{j=1}^{\lfloor\frac md\rfloor} \sum\limits_{t\mid gcd(i,j)}\mu(t)$

枚举 t

$\sum\limits_{d=1}^{min(n,m)} f(d) \sum\limits_{t=1}^{min(\lfloor\frac nd\rfloor,\lfloor\frac md\rfloor)} \mu(t)\sum\limits_{i=1}^{\lfloor\frac nd\rfloor}\sum\limits_{j=1}^{\lfloor\frac md\rfloor} [t\mid gcd(i,j)]$

枚举 t 的倍数

$\sum\limits_{d=1}^{min(n,m)} f(d) \sum\limits_{t=1}^{min(\lfloor\frac nd\rfloor,\lfloor\frac md\rfloor)} \mu(t)\sum\limits_{i=1}^{\lfloor\frac n{dt}\rfloor}\sum\limits_{j=1}^{\lfloor\frac m{dt}\rfloor} 1$

$\sum\limits_{d=1}^{min(n,m)} f(d) \sum\limits_{t=1}^{min(\lfloor\frac nd\rfloor,\lfloor\frac md\rfloor)} \mu(t)\lfloor\frac n{dt}\rfloor\lfloor\frac m{dt}\rfloor$

设 $T=dt$

$\sum\limits_{T=1}^{min(n,m)} \lfloor\frac nT\rfloor\lfloor\frac mT\rfloor \sum\limits_{d\mid T} f(d)\mu(T/d)$

发现 $\sum\limits_{d\mid T} f(d)\mu(T/d)$ 可以表示为 $g(T)=f*\mu$

$\sum\limits_{T=1}^{min(n,m)} g(T)\lfloor\frac nT\rfloor\lfloor\frac mT\rfloor$

## 莫反证明

$f=1*g$

$\sum\limits_{i=1}^n\sum\limits_{j=1}^m \sum\limits_{d\mid gcd(i,j)} g(d)$

枚举 $d$

$\sum\limits_{d=1}^{\min(n,m)} g(d) \sum\limits_{i=1}^n\sum\limits_{j=1}^m [d\mid gcd(i,j)]$

枚举 $d$ 的倍数

$\sum\limits_{d=1}^{min(n,m)} g(d)\lfloor\frac nd\rfloor\lfloor\frac md\rfloor$

## 预处理

若 $f$ 是积性函数，则可以线性筛预处理(卷积性质 4)，否则至少 $O(n\log\log n)$

```c++
void get_g_1(int N, const int *f, int *g)
{
    for (int i = 1; i <= N; i++)
        g[i] = 0;
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; i * j <= N; j++)
            g[i * j] = (g[i * j] + mu[i] * f[j]) % mod;
    }
} // 依照卷积定义，O(nlogn)

void get_g_2(int N, const int *f, int *g)
{
    for (int i = 1; i <= N; i++)
        g[i] = f[i];
    for (int i = 1; i <= N; i++)
    {
        for (int j = 2; i * j <= N; j++)
            g[i * j] = (g[i * j] - g[i]) % mod;
    }
} // 类似求狄利克雷卷积逆的方式，不需要线性筛 mu ，O(nlogn)

void get_g_3(int N, const int *f, int *g)
{
    for (int i = 1; i <= N; i++)
        g[i] = f[i];
    for (int i = 0; i < prime_count; i++)
    {
        for (int j = N / prime[i]; j >= 1; j--)
            g[j * prime[i]] = (g[j * prime[i]] - g[j]) % mod;
    }
} // Magic! O(nloglogn)
```

最后一种可以理解成 DP:
$$g_{i,n}=\sum\limits_{d\mid n,d只含前i种质因子} \mu(d)f(n/d)$$
具体转移就是
$$g_{i,n}=\begin{cases}g_{i-1,n}&p_i\nmid n\\ g_{i-1,n}-g_{i-1,n/p_i}&p_i\mid n\end{cases}$$

大部分题目第二种就够用，不排除 currywoe 没遇到毒瘤题（bushi

## 例题

$\sum\limits_{i=1}^n \sum\limits_{j=1}^m [gcd(i,j)=1]$

显然 $f=ε$，那么 $g=\mu$

---

$\sum\limits_{i=1}^n \sum\limits_{j=1}^m [gcd(i,j)=k]$

显然 $f(x)=[x=k]$，稍微推一下式子，则 $g=\mu$

---

稍难：求 $\sum\limits_{p∈prime}\sum\limits_{i=1}^n \sum\limits_{j=1}^m [gcd(i,j)=p]$

显然 $f(x)=[x∈prime]$,那么 $g=\sum\limits_{d\mid x} \mu(x/d)[d∈prime]$

换种写法就是 $g(x)=\sum\limits_{p∈prime,p\mid x} μ(x/p)$

此题特殊之处，可以线性筛处理出 $g$

$g(x=i*p)=\begin{cases}1&i=1\\μ(i)&i\mod p=0\\μ(i)-g(i)&i\mod p\neq 0\end{cases}$

---

$\sum\limits_{i=1}^n \sum\limits_{j=1}^m gcd(i,j)$

显然 $f=id$，则 $g=φ$

---

变形：求 $\sum\limits_{i=1}^n \sum\limits_{j=1}^m ij\times gcd(i,j)$

卷积处理，留作思考

参考答案 $=\sum\limits_{d=1}^{\min(n,m)} φ(d)*d^2*g(\lfloor\frac nd\rfloor)*g(\lfloor\frac md\rfloor)$

$g(x)=(1+x)*x/2$

---

变形：$\sum\limits_{i=1}^n \sum\limits_{j=1}^m lcm(i,j)$

卷积处理，留作思考，很好的练习题

参考答案 $=\sum\limits_{d=1}^{min(n,m)} d*sum(\lfloor\frac nd\rfloor,\lfloor\frac md\rfloor)$

$sum(n,m)=\sum\limits_{d=1}^{min(n,m)} μ(d)*d^2*g(\lfloor\frac nd\rfloor,\lfloor\frac md\rfloor)$

$g(n,m)=[(n+1)n/2]*[(m+1)*m/2]$

---

求 $\sum\limits_{i=1}^n \sum\limits_{j=1}^m σ_0(ij)$

先自行尝试把常用数论函数里给出的性质化成下面那个式子

再带回本题

原式 $=\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{p \mid \gcd(i,j)}\mu(p)σ_0\left(\frac{i}{p}\right)σ_0\left(\frac{j}{p}\right)$

枚举 $p$

$=\sum\limits_{p=1}^{min(n,m)} \sum\limits_{i=1}^n\sum\limits_{j=1}^m [p \mid \gcd(i,j)]\cdot\mu(p)σ_0\left(\frac{i}{p}\right)σ_0\left(\frac{j}{p}\right)$

$i,j$ 枚举 $p$ 的倍数

$=\sum\limits_{p=1}^{min(n,m)} \sum\limits_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac{m}{p}\right\rfloor} \mu(p)σ_0(i)σ_0(j)$

$μ(p)$ 和 $i,j$ 无关，提到前面去，$σ_0(i)$ 同理

$=\sum\limits_{p=1}^{min(n,m)}\mu(p) \sum\limits_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}σ_0(i) \sum\limits_{j=1}^{\left\lfloor\frac{m}{p}\right\rfloor}σ_0(j)$

简化形式

$=\sum\limits_{p=1}^{min(n,m)}\mu(p)*S\left(\left\lfloor\frac{n}{p}\right\rfloor\right)*S\left(\left\lfloor\frac{m}{p}\right\rfloor\right)$

$S(n)=\sum\limits_{i=1}^{n} σ_0(i)$
## trick
$\sum\limits_{i=1}^n\sum\limits_{j=1}^n[gcd(i,j)=1]$

上面这个式子除了往莫比乌斯函数化，还可以化成

$-1+2\sum\limits_{i=1}^n\phi(i)$

# 杜教筛
求数论函数前缀和
## 复杂度
$O(n^{\frac 23})$
## 原理
设数论函数 $f$，其前缀和 $S(n)=\sum\limits_{i=1}^n f(i)$，另一数论函数 $g$

$\sum\limits_{i=1}^nf*g(i)=\sum\limits_{i=1}^n\sum\limits_{d|i}f(i)g(\frac id)$

$=\sum\limits_{i=1}^n\sum\limits_{j=1}^{\lfloor\frac ni\rfloor}f(j)g(i)$

$=\sum\limits_{i=1}^ng(i)\sum\limits_{j=1}^{\lfloor\frac ni\rfloor}f(j)$

$=\sum\limits_{i=1}^ng(i)S(\lfloor\frac ni\rfloor)$

$g(1)S(n)=\sum\limits_{i=1}^nf*g(i)-\sum\limits_{i=2}^ng(i)S(\lfloor\frac ni\rfloor)$

假如可以快速求 $\sum\limits_{i=1}^nf*g(i)$，数论分块求 $\sum\limits_{i=2}^ng(i)S(\lfloor\frac ni\rfloor)$，则 $S(n)$ 可求

线性筛预处理前 $n^{\frac 23}$，记忆化中间结果(map和um，洛谷数据测试二者差别不大)
## 莫比乌斯函数前缀和
$f=\mu$，$g=1$，$f*g=\epsilon$

$S(n)=1-\sum\limits_{i=2}^nS(\lfloor\frac ni\rfloor)$
```cpp
const int N=1e8+3;
const int M=6e6;
bitset<N> v;
int p[M];
int mu[N];
void seive()
{
	int cnt=0;
	mu[1]=1;
	for(int i=2;i<N;++i)
	{
		if(!v[i])
		{
			p[cnt++]=i;
			mu[i]=-1;
		}
		for(int j=0;j < cnt && i*p[j] < N;++j)
		{
			v[i*p[j]]=1;
			if(!(i%p[j]))
				break;
			mu[i*p[j]]=-mu[i];
		}
	}
    for(int i=1;i<N;++i)
        summu[i]=summu[i-1]+mu[i];
}
struct Du
{
    map<ll,ll> mpmu;
    long long Smu(long long x)
    {
        if (x < N)
            return summu[x];
        if (mpmu.count(x))
            return mpmu[x];
        long long res = 1;
        for (long long l = 2, r; l <= x; l = r + 1)
        {
            r = x / (x / l);
            res -= Smu(x / l) * (r - l + 1);
        }
        return (mpmu[x] = res);
    }
}du;
```
## 欧拉函数前缀和
>如果同时求欧拉函数前缀和，莫比乌斯函数前缀和用这个，如果单独求欧拉函数前缀和用下面那个

莫反求：

$\sum\limits_{i=1}^n\phi(i)=\sum\limits_{i=1}^n\mu(i)\lfloor\frac nd\rfloor^2$
```cpp
long long Sphi(long long x)
{
    long long z,y=0,res =1;
    for (long long l = 1,r; l <= x; l = r + 1)
    {
        r = x / (x / l);
        z=Smu(r);
        res += (z - y) * (x / l) * (x / l);
        y=z;
    }
    return res / 2;
}
```
杜教筛求：

$f=\phi$，$g=1$，$f*g=ID$

$S(n)=\frac{n(n+1)}2-\sum\limits_{i=2}^nS(\lfloor\frac ni\rfloor)$
```cpp
struct Du
{
    map<ll,ll> mpphi;
    ll Sphi(int x)
    {
        if (x <N)
            return sumphi[x];
        if (mpphi.count(x))
            return mp[x];
        ll res = (x&1)?(x+1)/2*x:x/2*(x+1);//如果可能溢出用int128
        for (ll l = 2, r; l <= x; l = r + 1)
        {
            r = x / (x / l);
            res -= Sphi(x / l) * (r - l + 1);
        }
        return (mp[x] = res);
    }
}du;
```

# 原根

## 阶

### 定义

若 $p>1$，$gcd(a,p)=1$，则必有一个 $x$ 满足

$a^x\equiv 1 \pmod p$,

且 $x$ 为最小正整数解,

则 $x$ 为 $a$ 模 $p$ 的阶,记作 $\delta_p(a)$

### 性质

1. $a,a^2,...,a^{\delta_p(a)}$ 模 $p$ 两两不同余

2. 若 $a^n\equiv 1 \pmod p$，则$\delta_p(a) \mid n$

3. 若 $a^r \equiv a^t \pmod p$，则 $r\equiv t \pmod {\delta_p(a)}$

4. 若 $\gcd(a,p)=\gcd(b,p)=1$，则 $\delta_p(ab)=\delta_p(a)\delta_p(b)$

的充分必要条件是 $\gcd\big(\delta_p(a),\delta_p(b)\big)=1$

5. 若 $\gcd(a,p)=1$，则$\delta_p(a^k)=\dfrac{\delta_p(a)}{\gcd\big(\delta_p(a),k\big)}$

## 原根

### 定义

$\delta_p(a)=φ(p)$

则 $a$ 为模 $p$ 的原根(Primitive Root)

### 原根存在定理

$p$ 能表示为下列形式之一：

$2,4,k^n,2*k^n$，其中 $k$ 为奇素数。

### 原根判定定理

若 $p>2$，$gcd(a,p)=1$或者$a^{φ(p)}\equiv 1 \pmod p$

前者用\_\_gcd 判断，后者用取模快速幂判断，根据 luogu p6091，二者效率差别不大

则 $a$ 是模 $p$ 的原根的充要条件是，对于 $φ(p)$ 的每个素因数 $j$，都有 $a^{\frac{φ(p)}{j}}\not\equiv 1\pmod p$。

### 数量

$φ(φ(p))$

最多是 $p/2$

### 常见数的最小原根

2——1,4——3,998244353——3,1e9+7——5

### 求 p 的所有原根的步骤

1. 线性筛处理

不大于 $p$ 的素数，不大于 $p$ 的正整数的欧拉函数值，不大于 $p$ 的有原根的模数

1. 判断 $p$ 是否有原根

2. 求最小原根

用已经筛出的素数求 $φ(p)$ 的质因数,并顺便标记和 $φ(p)$ 互素的数

枚举 $i$ （从 1 开始）,满足 $gcd(i,n)=1$,

对于 $φ(p)$ 的每个质因数 $j$

如果 $i^{φ(p)/j}\equiv 1 \pmod p$

说明 $i$ 不是原根

继续循环，直到找到合适的 $i$ 为止

有人证明过，最多 $n^{1/4}$ 次就能找到最小原根

4. 求所有原根

枚举 $φ(p)$ 以内的正整数 $s$

如果 $s$ 与 $φ(p)$ 互质，则 $a^s$ 是一个原根

#### 时间复杂度

$O(nlogloglogn)$

#### 优化

如果要求顺序输出原根，基数排序比快速排序更快

```c++
typedef long long ll;
const int N=1e6+7;
int p[N],phi[N],factor[15];
bool v[N],pr[N],coprime[N],proot[N];
void init(int n)//筛素数，欧拉函数，有原根的数
{
	pr[2]=pr[4]=phi[1]=1;
	int cnt=0;
	for(int i=2;i<=n;++i)
    {
		if(!v[i])
        {
            p[cnt++]=i;
            phi[i]=i-1;
        }
		for(int j=0;j<cnt && p[j]*i<=n;++j)
        {
			v[p[j]*i]=1;
			if(!(i%p[j]))
            {
				phi[i*p[j]]=phi[i]*p[j];
				break;
			}
			phi[i*p[j]]=phi[i]*phi[p[j]];
		}
	}
	for(int i=1;i<cnt;++i)
    {
        for(ll j=p[i];j<=n;j*=p[i])
            pr[j]=1;
        for(ll j=2*p[i];j<=n;j*=p[i])
            pr[j]=1;
	}
}
long long fast_power(long long base,long long exponent,ll mod)
{
    long long result=1;
    for(;exponent>0;exponent>>=1)
    {
        if(exponent&1)
            result=result*base%mod;
        base=base*base%mod;
    }
    return result;
}
vector<int> PrimitiveRoot(int n)
{
    vector<int> vec;
    if(!pr[n])//模数n没有原根
        return vec;
    if(n==2 || n==4)
    {
        vec.push_back(n-1);
        return vec;
    }
    int temp=phi[n];
    int cnt=0;
    for(int i=0;p[i]*p[i]<=temp;++i)//求φ(n)的质因子，用埃氏筛的思想筛出与φ(n)互质的数(即coprime[i]=0)
    {
        if(!(temp%p[i]))
        {
            factor[cnt++]=p[i];
            while(!(temp%p[i]))
                temp/=p[i];
            for(int j=p[i];j<phi[n];j+=p[i])
                coprime[j]=1;
        }
    }
    if(temp>1)//处理大于根号φ(n)的质因子
    {
        factor[cnt++]=temp;
        for(int i=temp;i<phi[n];i+=temp)
            coprime[i]=1;
    }
    int minPr=1;
    for(;;++minPr)//求最小原根
    {
        for(;__gcd(minPr,n)!=1;++minPr);
        int j=0;
        for(;j<cnt && fast_power(minPr,phi[n]/factor[j],n)!=1;++j);
        if(j>=cnt)
            break;
    }
    temp=minPr;
    for(int i=1;i<phi[n];++i,temp=temp*minPr%n)//求所有原根
    {
        if(!coprime[i])
            proot[temp]=1;
        else
            coprime[i]=0;//清零
    }
    for(int i=1;i<n;++i)//排序原根
    {
        if(proot[i])
        {
            proot[i]=0;//清零
            vec.push_back(i);
        }
    }
    return vec;
}
```

### 原根应用

1. 乘法转化为加法

若 $p$ 有原根，

根据阶的性质 1 和原根的定义，

若 $g$ 是 $p$ 的原根，$1 \le k \le φ(p)$

$g^k \pmod p$ 能生成$[1, p-1]$ 中 $φ(p)$ 个数

换句话说就是

$g^1,g^2...g^{φ(p)} \pmod p$与 $[1,p-1]$ 中的数形成了单射

当 $p$ 是素数时，就形成了双射

> 把 x 比作萝卜，y 比作坑：  
> 单射就是一个萝卜一个坑，有的坑有可能没萝卜；  
> 满射就是所有坑都有萝卜，有的坑可能有不止一个萝卜；  
> 双射就是严格的一个萝卜一个坑，一个坑一个萝卜，所有萝卜都有坑，所有坑都有萝卜。

若 $p$ 是素数，$1 \le a,b$

则 $a*b=g^{Ind_ga+Ind_gb} \pmod p$

Ind 是离散对数，在 bsgs&exbsgs 里会介绍

因此求出 $p$ 的原根 $g$，然后我们就可以把原序列 $a[i]$ 变成 $g^{b[i]}$ ，从而我们就把乘法变成了加法，即

$a[i]*a[j]=a[k] \pmod p$ 变成

$b[i]+b[j]=b[k] \pmod {p-1}$

要特判 0,因为原根不会生成 0

# 离散对数

### 定义

当模 $m$ 有原根时，设 $l$ 为模 $m$ 的一个原根，则当 $x\equiv l^k \pmod m$ 时，$Ind_lx\equiv k \pmod {φ(m)}$

这里的 $Ind_lx$ 为 $x$ 以 $l$ 为底，模 $φ(m)$ 时的离散对数值

$1 \le k \le φ(m)$

### 性质

离散对数和普通对数有类似的性质

$Ind_lxy\equiv Ind_lx+Ind_ly \pmod {φ(m)}$

$Ind_lx^y\equiv yInd_lx \pmod {φ(m)}$

通过这些性质，可以将乘法操作变成加法操作，来简化或者解决一些运算问题.

## BSGS

求离散对数

### 前提条件

$gcd(base,mod)=1$

### 原理

由欧拉定理推论

$a^b=a^{b\%φ(n)} \pmod n$

得知 $a^b$ 在模 $n$ 下有长度为 $φ(n)$ 的循环节

所以最多枚举 $φ(n)$ 次 $a^b$ 就可以求出离散对数

但是如果 $n$ 是质数，那暴力枚举时间复杂度就是 $O(n)$

bsgs 时间复杂度更优

$y^x \equiv z \pmod p$

给定 $y$ , $z$ , $p$ , 求 $x$ 最小正整数解

设$x=am-b$，$m=\left\lceil \sqrt p\right\rceil$，$a\in[1,m],b\in[1,m]$

> $\left\lceil x\right\rceil$是向上取整

$a$,$b$的值域保证$x$取遍$[0,p]$

原式变为

$y^{am} ≡ z*y^b  \pmod p$

如果发现这个式子成立，说明有解

### 时间复杂度

$O(\sqrt {mod})$

### 算法流程

右边的$b$枚举$[1,m]$，算出$z∗y^b \pmod p$，哈希存起来

PS：map 也可以过一些题，但是如果卡常就不行，所以最好用哈希表

左边$a$枚举$[1,m]$，算出$(y^m)^a \pmod p$查表就行了

如果$p\mid base^m$，那么 remain 只能是 0，否则无解

### 代码

```c++
long long bsgs(long long base,long long remain,long long p)
{
	base%=p;
	remain%=p;
	ll t=ceil(sqrt(1.0*p));
	for(ll i=1;i<=t;++i)
    {
        remain=remain*base%p;
        insert(i,remain);
    }
	base=fast_power(base,t,p);
	if(!base)
        return !remain ? 1 : -1;
    remain=1;
    int flag;
	for(ll i=1;i<=t;++i)
    {
		remain=remain*base%p;
        flag=find(remain);
        if(flag!=-1)
            return i*t-flag;
	}
	return -1;
}
```

## exbsgs

解决$gcd(base,modulus)\ne 1$的情况

### 原理

$y^x \equiv z \pmod p$

设$g=gcd(y,p)$

发现此时的$z$必须要是$g$的倍数，否则无解。

因此，除掉 g

<font size=4>$\frac{y}{g} * y^{x-1} \equiv \frac{z}{g} \pmod {\frac{p}{g}}$</font>

不断检查$gcd(p,y)$，一直除到互质为止

此时的形式就变成了

<font size=6>$\frac{y^k}{\prod\limits_{i=1}^k g_i} *y^{x-k} = \frac{z}{\prod\limits_{i=1}^k g_i} \pmod {\frac{p}{\prod\limits_{i=1}^k g_i}}$</font>

互质之后就可以套用 bsgs 了

```c++
ll EXbsgs(ll base,ll remain,ll mod)
{
    base%=mod;
    remain%=mod;
	if(remain==1)
        return 0;
	ll k=0,a=1;
	for(ll g=__gcd(base,mod);g>1;g=__gcd(base,mod))
	{
		if(remain%g)
            return -1;
		remain/=g;
        mod/=g;
        ++k;
        a=a*(base/g)%mod;
		if(remain==a)
            return k;
	}
    clear();
	ll m=ceil(sqrt(1.0*mod));
	for(int i=1;i<=m;++i)
    {
        remain=remain*base%mod;
        insert(i,remain);
    }
    base=fast_power(base,m,mod);
    remain=a;
    ll flag;
	for(ll i=1;i<=m;++i)
	{
        remain=remain*base%mod;
        flag=find(remain);
        if(flag!=-1)
            return (i*m-flag+k);
	}
	return -1;
}
//返回值要求余mod,但不能在子函数里，因为mod变了
```

## 哈希表

链地址法解决冲突

```c++
typedef long long ll;
const int MAXN=1e7+1;
struct hash
{
    ll id,value;
    int next;
}e[MAXN];
int head[MAXN];
int tot;
inline ll hashfunc(ll x)
{
    return x%MAXN;
}
void insert(ll id,ll x)
{
    e[++tot]={id,x,head[hashfunc(x)]};
    head[hashfunc(x)]=tot;
}
ll find(ll x)
{
    for(int i=head[hashfunc(x)];i;i=e[i].next)
    {
        if(e[i].value==x)
            return e[i].id;
    }
    return -1;
}
void clear()
{
    for(;tot;--tot)
        head[hashfunc(e[tot].value)]=0;
}
```

# CRT

## 时间复杂度

$O(nlog n)$

求解如下形式的一元线性同余方程组

$x\equiv a_1 \pmod {n_1}$

$x\equiv a_2 \pmod {n_2}$

.

.

.

$x\equiv a_k \pmod {n_k}$

## 限制条件

$n_i$两两互质

## 算法流程

1. 计算所有模数的积 $n=\prod\limits_{i=1}^k n_i$
2. 对于第 $i$ 个方程：

   a. 计算 $m_i=n/n_i$ ;

   b. 计算 $m_i$ 在模 $n_i$ 意义下的逆元 $m_i^{-1}$;

   c. 计算 $c_i=m_i*m_i^{-1}$ (不要对 $n_i$ 取模)

3. 方程组的唯一解为 $x=\sum\limits_{i=1}^k a_i*c_i \pmod n$

```c++
long long CRT(int number,long long* remainder,long long* modulus)
{
    long long m,x,y,product = 1, ans = 0;
    for (int i = 1; i <= number; i++)
        product = product * modulus[i];
    for (int i = 1; i <= number; i++)
    {
        m = product / modulus[i];
        exgcd(m, modulus[i], x, y);
        ans = (ans + remainder[i] * m * x % product) % product;
    }
    return (ans % product + product) % product;
}
```

# excrt

解决模数不互质的情况

设两个方程分别是

$x=a_1 \pmod {n_1}$

$x=a_2 \pmod {n_2}$

将它们转化为不定方程：

$x=n_1*p+a_1=n_2*q+a_2$

其中 $p$ , $q$ 是整数,则有 $n_1*p-n_2*q=a_2-a_1$

由裴蜀定理，当 $a_2-a_1$ 不能被 $gcd(n1,n2)$ 整除时，无解

> 裴蜀定理：设 $a,b$ 是不全为零的整数，则存在整数 $x,y$, 使得 $ax+by=gcd(a,b)$.

其他情况下，可以通过扩展欧几里得算法解出来一组可行解$(p,q)$

则原来的两方程组成的模方程组的解为

$x=n_1*p+a_1 \pmod {lcm(m1,m2)}$

多个方程,用上面的方法两两合并即可

```c++
long long CRT(int number,long long* remainder,long long* modulus)
{
    long long lcm = modulus[1],sum = remainder[1],x,y,gcd;
    int fail = 0;
    for(int i = 2;i <= number;++i)
    {
        remainder[i] = ((remainder[i] - sum) % modulus[i] + modulus[i]) % modulus[i];
        gcd = exgcd(lcm,modulus[i],x,y);
        if(remainder[i] % gcd == 0)
            x = x * (remainder[i] / gcd) % modulus[i];
        else
        {
            fail = 1;
            break;
        }
        sum += x * lcm;
        lcm = lcm / gcd * modulus[i];
        sum = (sum % lcm + lcm) % lcm;
    }
    return fail ? -1 : sum;
}
```

# exgcd

$Ax\equiv C \pmod B$
，其中$A$、$B$、$C$都为常量，$x$是未知数

exgcd 解出特解$x_0,y_0$

通解：

$x=C/d*x_0+B/d*k$，$y=C/d*y_0-A/d*k$。

exgcd 函数返回值是最大公约数

## 代码

```c++
int exgcd(int a,int b,int &x,int &y)
{
	if(!b)
	{
		x=1;
		y=0;
		return a;
	}
	int r=exgcd(b,a%b,y,x);
	y-=x*(a/b);
	return r;
}
```
# min_25筛
>此篇为 $O(\frac {n^{\frac 34}}{\log n})$ 的版本，$O(n^{\frac 23})$ 的见[这里](https://zhuanlan.zhihu.com/p/60378354)

求积性函数 $f(n)$ 前缀和 $\sum\limits_{i=1}^nf(i)$

>以下p表示质数
## 限制
$f(p)$ 是一个最高次数低，关于 $p$ 的多项式，即 $f(p)=\sum\limits_{j=0}^{\infty}coe_jp^j$

$f(p^k)$ 可以快速计算
## 第1部分
自己设一个完全积性函数 $f'$，要求 $f'(p)=f(p)$

>以下$p_j$表示第 $j$ 个质数，$p_1=2$，特别地，$p_0=1$  
>以下 $minp(i)$ 表示 $i$ 的最小质因子，特别地，$minp(1)=0$

min25想了一个关于 $f'$ 的函数 $g(n,j)=\sum\limits_{i=1}^n[i\in prime 或者 p_j<minp(i)]f'(i)$

考虑DP求解这个函数，从 $g(n,j-1)\rightarrow g(n,j)$ 的转移过程中，少了 $p_j=minp(i)$ 的合数的贡献，即

$\sum\limits_{i=p_j^2}^n[p_j=minp(i)]f'(i)$

当 $p_j^2>n$ 上式为0，即 $g(n,j)=g(n,j-1)$

考虑 $p_j\le\lfloor\sqrt n\rfloor$ 的情况

$i$ 分解成 $p_j$ 和另一个数的乘积，上式变成

$\sum\limits_{k=p_j}^{\lfloor\frac n{p_j}\rfloor}[p_j\le minp(k)]f'(p_jk)$

由于 $f'$ 是完全积性函数，所以把 $f'(p_jk)$ 拆开，即

$f'(p_j)\sum\limits_{k=p_j}^{\lfloor\frac n{p_j}\rfloor}[p_j\le minp(k)]f'(k)$

上式的后半部分和 $g(\frac n{p_j},j-1)$ 相比，产生贡献的合数一样，质数计算了大于等于 $p_j$ 的，即，少了 $\sum\limits_{i=1}^{j-1}f'(p_i)$

所以上式改写成

$f'(p_j)(g(\frac n{p_j},j-1)-\sum\limits_{i=1}^{j-1}f'(p_i))$

整理一下

$g(n,j)=\begin{cases}g(n,j-1)&p_j^2>n\\g(n,j-1)-f'(p_j)(g(\frac n{p_j},j-1)-\sum\limits_{i=1}^{j-1}f'(p_i))&otherwise\end{cases}$

由上式知，需要所有的 $g(\frac n{p_j},j-1)$，而且还需要递归处理子问题

但是有一个重要结论 $\lfloor\frac{\lfloor\frac na\rfloor}{b}\rfloor=\lfloor\frac n{ab}\rfloor$，所以子问题个数是 $O(\sqrt n)$的
### 证明
$\lfloor\frac nx\rfloor$最多 $2\sqrt n$个

当 $x\le \sqrt n$ ，因为 $x$ 最多 $\sqrt n$ 个，所以$\lfloor\frac nx\rfloor$最多 $\sqrt n$个

当 $x> \sqrt n$ ，因为 $\lfloor\frac nx\rfloor\le\sqrt n$，所以$\lfloor\frac nx\rfloor$最多 $\sqrt n$个

## 第2部分
min25又想了一个关于 $f$ 的函数 $S(n,j)=\sum\limits_{i=1}^n[p_j<minp(i)]f(i)$

把 $i$ 分成质数和合数讨论（1的贡献最后加上）

质数的贡献：

$\sum\limits_{p}^nf(p)-\sum\limits_{i=1}^jf(p_i)$

由于 $f(p)=f'(p)$，所以上式等于

$g(n,+\infty)-\sum\limits_{i=1}^jf(p_i)$

合数的贡献：

合数 $x$ 可以唯一表示为 $minp(x)^k\times i$

要求 $minp(i)>p$

如果 $minp(i)<p$，$p$ 就不是 $x$ 的最小质因子

如果 $minp(i)=p$，$x$ 就不能唯一表示

$\sum\limits_{p}^{\lfloor\sqrt n\rfloor}\sum\limits_{k=1}^{\lfloor log_pn\rfloor}\left([k>1]f(p^k)+\sum\limits_{i=p+1}^{\lfloor\frac{n}{p^k}\rfloor}[minp(i)>p]f(p^k\times i)\right)$

因为 $f$ 是积性函数，所以把 $p^k*i$ 拆开来

$\sum\limits_{p}^{\lfloor\sqrt n\rfloor}\sum\limits_{k=1}^{\lfloor log_pn\rfloor}\left([k>1]f(p^k)+f(p^k)\sum\limits_{i=p+1}^{\lfloor\frac{n}{p^k}\rfloor}[minp(i)>p]f(i)\right)$

$\sum\limits_{j=1}^{+\infty}\sum\limits_{k=1}^{\lfloor log_{p_j}n\rfloor}f(p_j^k)\left([k>1]+\sum\limits_{i=p_j+1}^{\lfloor\frac{n}{p_j^k}\rfloor}[minp(i)>p_j]f(i)\right)$

$\sum\limits_{j=1}^{+\infty}\sum\limits_{k=1}^{\lfloor log_{p_j}n\rfloor}f(p_j^k)(S(\frac n{p_j^k},j)+[k>1])$

整理一下

$S(n,j)=g(n,+\infty)-\sum\limits_{i=1}^jf(p_i)+\sum\limits_{k>j}^{+\infty}\sum\limits_{i=1}^{\lfloor log_{p_k}n\rfloor}f(p_k^i)(S(\frac n{p_k^i},k)+[i>1])$

$k>j$ 是因为 $minp(x)>p_j$

---
$\sum\limits_{i=1}^nf(i)=S(n,0)+1$
## 实现
把 $f(p)$ 的多项式拆成单项式 $f_1(p),f_2(p),...$，有几个单项式就有几个要预处理的数组

线性筛预处理 $\lfloor\sqrt n\rfloor$ 内的质数，预处理 $sum_j=\sum\limits_{i=1}^{p_i\le\lfloor\sqrt n\rfloor}f_j(p_i)$

预处理 $g_j(m,0)=\sum\limits_{i=2}^mf_j'(i)$，整除分块来顺序求出所有的 $m$

根据对 $g_j(m,0)$ 的个数的证明，开两个数组分别记录 $m>\sqrt n$，和 $m\le\sqrt n$ 的 $g_j(m,0)$

需要 $g(m,+\infty)$,知道 $g(m,0)$，按照第1部分去转移,此时计算了各个 $\frac nx$ 内质数的贡献

计算和数的贡献，按照第2部分去转移

如果1有贡献，记得加上

使用时修改带注释的函数，f1(x),f2(x)只在x是质数时调用
```cpp
const int N=1e5+3;//根号n
const int M=1e4;//根号n以内质数个数
const ll mod=1e9+7;
const ll inv2=500000004;
const ll inv6=166666668;
bitset<N> v;
int cnt;
ll p[M];
void seive()
{
	cnt=0;
	for(int i=2;i<N;++i)
	{
		if(!v[i])
			p[++cnt]=i;
		for(int j=1;j<=cnt && i*p[j]<N;++j)
		{
			v[i*p[j]]=true;
			if(i%p[j]==0)
				break;
		}
	}
}
struct min25
{
    ll n,sum1[M],sum2[M];
    ll w[N<<1],g1[N<<1],g2[N<<1];
    int id1[N],id2[N],tot,sq;
    int getid(ll x)
    {
        if(x<=sq)
            return id1[x];
        return id2[n/x];
    }
    ll f1(ll x)//f_1'(p)
    {
        return x;
    }
    ll f2(ll x)//f_2'(p)
    {
        return x*x%mod;
    }
    ll presumff1(ll x)//\sum\limits_{i=2}^xf_1'(i)
    {
        x%=mod;
        return x*(x+1)%mod*inv2%mod-1;
    }
    ll presumff2(ll x)//\sum\limits_{i=2}^xf_2'(i)
    {
        x%=mod;
        return x*(x+1)%mod*(2ll*x%mod+1)%mod*inv6%mod-1;
    }
    ll pk(ll x)//f(p^k)
    {
        x%=mod;
        return x*(x-1)%mod;
    }
    ll func(ll x1,ll x2)//单项式组合成多项式
    {
        return (x2-x1)%mod;
    }
    ll S(ll x,int j)
    {
        if(p[j]>x)
            return 0;
        ll sp,ans=(func(g1[getid(x)],g2[getid(x)])-func(sum1[j],sum2[j]))%mod;
        for(int i=j+1;i<=cnt && p[i]*p[i]<=x;++i)
        {
            sp=p[i];
            for(int e=1;sp<=x;sp*=p[i],++e)
                ans=(ans+pk(sp)*(S(x/sp,i)+(e>1))%mod)%mod;
        }
        return (ans+mod)%mod;
    }
    void init()
    {
        for(int i=1;i<=cnt;++i)
        {
            sum1[i]=(sum1[i-1]+f1(p[i]))%mod;
            sum2[i]=(sum2[i-1]+f2(p[i]))%mod;
        }
    }
    ll cal(ll nn)
    {
        tot=0;
        n=nn;
        sq=sqrt(n);
        for(ll r,m,l=1;l<=n;l=r+1)
        {
            r=n/(n/l);
            w[tot]=m=n/l;
            g1[tot]=presumff1(m);
            g2[tot]=presumff2(m);
            if(m<=sq)
                id1[m]=tot;
            else
                id2[n/m]=tot;
            ++tot;
        }
        for(int i=1;i<=cnt;++i)
        {
            for(int j=0;j<tot && p[i]*p[i]<=w[j];++j)
            {
                g1[j]=(g1[j]-f1(p[i])*(g1[getid(w[j]/p[i])]-sum1[i-1])%mod)%mod;
                g2[j]=(g2[j]-f2(p[i])*(g2[getid(w[j]/p[i])]-sum2[i-1])%mod)%mod;
            }
        }
        return (S(n,0)+1)%mod;
    }
}m2;
seive();
m2.init();
m2.cal();
```
## 拆常数
对于 $f(p)$ 的单项式去掉常数是完全积性函数，可以取去掉常数的单项式作为 $f'(p)$，计算完 $g(n,+\infty)$ 和 $sum$ 之后，给这两个再乘上常数（因为只计算质数的贡献），例如 $f(p)=3$，取 $f'(p)=1$，这样就凑出完全积性函数常数函数了

>一定要记得两个乘回去

## 拆条件
对于 $f(x)=[条件]F(x)$，$F(x)$ 是积性函数的，可以取去掉条件的单项式作为 $f'(p)$，在计算第2部分的时候，对于质数的贡献，质数幂的贡献乘上条件，即

$S(n,j)=[条件]\left(g(n,+\infty)-\sum\limits_{i=1}^jf(p_i)\right)+\sum\limits_{k>j}^{+\infty}\sum\limits_{i=1}^{\lfloor log_{p_k}n\rfloor}f(p_k^i)(S(\frac n{p_k^i},k)+[条件][i>1])$

## 例题选讲
[n以内素数个数](https://vjudge.net/problem/LibreOJ-6235)

[洛谷的同一题目](https://www.luogu.com.cn/problem/P1835)

因为 $f(p)=1$ ，所以 $f'(i)=1$，$\sum\limits_{i=2}^n f'(i)=n-1$

代码部分：

f1(x)=1，presumff1(x)=x-1

因为只有一个单项式，所以f2(x)和presumff2(x)和func(x1,x2)不需要

因为只计算质数的贡献，所以S(n,j)和pk(x)不需要

---
[n以内素数和](https://vjudge.net/problem/LibreOJ-6202)

因为 $f(p)=p$，所以 $f'(i)=i$，$\sum\limits_{i=2}^n f'(i)=(1+n)*n/2-1$

代码部分：

f1(x)=x，presumff1(x)=x*(x+1)/2-1

因为只有一个单项式，所以f2(x)和presumff2(x)和func(x1,x2)不需要

因为只计算质数的贡献，所以S(n,j)和pk(x)不需要

---
[质数前缀统计](https://www.luogu.com.cn/problem/P5493)

>此题需要求自然数幂和，可以拿[这里](https://zhuanlan.zhihu.com/p/563147047)的板子

因为 $f(p)=p^k$，所以 $f'(i)=i^k$，$\sum\limits_{i=2}^n f'(i)$用板子求

代码部分：

$f1(x)=x^k$，presumff1(x)用板子求

因为只有一个单项式，所以f2(x)和presumff2(x)和func(x1,x2)不需要

因为只计算质数的贡献，所以S(n,j)和pk(x)不需要

---
[洛谷模板题](https://www.luogu.com.cn/problem/P5325)

$f_1(p)=p$，$f_2(p)=p^2$，所以 $f_1'(i)=i$，$f_2'(i)=i^2$，$\sum\limits_{i=2}^n f_1'(i)=n(n+1)/2-1$，$\sum\limits_{i=2}^n f_2'(i)=n(n+1)(2n+1)/6-1$

$f(p^k)=p^k(p^k-1)=p^{2k}-p^k$

代码部分：

$f1(x)=x$，$f2(x)=x^2$，$presumff1(x)=x(x+1)/2-1$，$presumff2(x)=x(x+1)(2x+1)/6-1$，$pk(x)=x(x-1)$，$func(x1,x2)=x2-x1$

---
[Counting Divisors (square) ](https://vjudge.net/problem/SPOJ-DIVCNT2)

$f(p)=3$，根据拆常数技巧，$f'(i)=1$，$\sum\limits_{i=2}^n f_1'(i)=n-1$

$f(p^k)=2k+1$

代码部分：

$f1(x)=1$，$presumff1(x)=x-1$

因为只有一个单项式，所以f2(x)和presumff2(x)和func(x1,x2)不需要

记得给 g1,sum1 乘3

$pk(p^k)=2k+1$

---
[Counting Divisors (cube)](https://vjudge.net/problem/SPOJ-DIVCNT3)

和上题类似

$f(p)=4$，$f(p^k)=3k+1$

---
[Counting Divisors (general)](https://vjudge.net/problem/SPOJ-DIVCNTK)

和上题类似

$f(p)=k$，$f(p^e)=ke+1$

---
[奇怪的数学题](https://vjudge.net/problem/51Nod-1847)

>略难，考察对第1部分的理解

根据直觉，$sgcd(i,j)=\frac{gcd(i,j)}{minp(gcd(i,j))}$

设 $f(x)=\begin{cases}0&x=1\\\frac x{minp(x)}&otherwise\end{cases}$

$\sum\limits_{i=1}^n\sum\limits_{j=1}^nf(gcd(i,j))^k$

接下来按照[套路](https://zhuanlan.zhihu.com/p/557832253)推式子，这里就跳过一部分

$\sum\limits_{d=2}^nf(d)^k\sum\limits_{i=1}^{\frac nd}\sum\limits_{j=1}^{\frac nd}[gcd(i,j)=1]$

$\sum\limits_{d=2}^nf(d)^k(-1+2\sum\limits_{i=1}^{\frac nd}\phi(i))$

$\sum\limits_{i=1}^{m}\phi(i)$ 可以杜教筛求，[板子](https://zhuanlan.zhihu.com/p/576131237)

形如 $\sum\limits_{i=1}^nf(i)g(\left\lfloor\dfrac ni\right\rfloor)$ 可以[数论分块](https://zhuanlan.zhihu.com/p/557857835)

剩下需要求 $S(m)=\sum\limits_{i=1}^mf(i)^k$

分成质数，合数分别考虑

$f(p)^k=1$，因此质数的贡献等于m以内的质数个数

>从这里开始考察对第1部分的理解

从 $g(n,j-1)\rightarrow g(n,j)$ 的转移过程中，少了 $p_j=minp(i)$ 的合数的贡献，即

$\sum\limits_{i=p_j^2}^n[p_j=minp(i)]f'(i)$

发现这里有需要的 $minp(i)$，拆一下

$\sum\limits_{i=p_j^2}^n[p_j=minp(i)](\frac i{p_j})^k$

$\frac 1{p_j}^k\sum\limits_{i=p_j^2}^n[p_j=minp(i)]i^k$

$i$ 分解成 $p_j$ 和另一个数的乘积，上式变成

$\frac 1{p_j}^k\sum\limits_{d=p_j}^{\lfloor\frac n{p_j}\rfloor}[p_j\le minp(d)](p_jd)^k$

$\sum\limits_{d=p_j}^{\lfloor\frac n{p_j}\rfloor}[p_j\le minp(d)]d^k$

此时 $d^k$ 是完全积性函数幂函数

取 $f'(i)=i^k$，按照第一部分去维护这个 $f'(i)$ 的 $g$

转移的式子是 $g(n,j)=\begin{cases}g(n,j-1)&p_j^2>n\\g(n,j-1)-f'(p_j)(g(\frac n{p_j},j-1)-\sum\limits_{i=1}^{j-1}f'(p_i))&otherwise\end{cases}$

求 $g(n,0)$ 需要自然数幂和，还是抄[板子](https://zhuanlan.zhihu.com/p/563147047)

而需要的合数的贡献是$\sum\limits_{d=p_j}^{\lfloor\frac n{p_j}\rfloor}[p_j\le minp(d)]d^k$，即 $g(\frac n{p_j},j-1)-\sum\limits_{i=1}^{j-1}f'(p_i)$ 这一部分

---
[2022四川省赛E](https://ac.nowcoder.com/acm/contest/42105/E)

$\sum\limits_{p_1p_2p_3\le n，p_1<p_2<p_3}(p_1+p_2+p_3)^3$

对求和号下面的条件转化为更具体的

$\sum\limits_{p_1}^{\lfloor\sqrt[3] n\rfloor}\sum\limits_{p_2>p_1}^{\lfloor\sqrt\frac n{p_1}\rfloor}\sum\limits_{p_3>p_2}^{\lfloor\frac n{p_1p_2}\rfloor}(p_1+p_2+p_3)^3$

发现前两个求和号的上限之积不大，估算一下就是2.2e3*1e5=2.2e8

而题目给了8s，所以考虑枚举 $p_1,p_2$，求满足条件的 $p_3$ 的贡献

拆一下贡献的式子

$(p_1+p_2+p_3)^3$

$=p_1^3+p_2^3+p_3^3+3p_1p_2^2+3p_1p_3^2+3p_1^2p_2+3p_1^2p_3+3p_2p_3^2+3p_2^2p_3+6p_1p_2p_3$

$=(p_1^3+p_2^3+3p_1p_2^2+3p_1^2p_2)+3(2p_1p_2+p_1^2+p_2^2)p_3+3(p_1+p_2)p_3^2+p_3^3$

$=(p_1+p_2)^3p_3^0+3(p_1+p_2)^2p_3+3(p_1+p_2)p_3^2+p_3^3$

产生贡献的 $p_3$ 范围是 $(p_2,\frac n{p_1p_2}]$

所以需要筛 $p_3^0,p_3,p_3^2,p_3^3$ 的前缀和，而这个事min25筛可以做到

---
[2022ICPC网络赛1F](https://pintia.cn/market/item/1571156622976593920)

设 $f(x)$ 为 $a_k=x$ 的方案数

手算小数据会发现 $f(p)=k$ ，$f(p^2)=k(k+1)/2$

然后发现这是同球不同盒有空箱的[球盒问题](https://zhuanlan.zhihu.com/p/557873619)

推出 $f(p^e)=\dbinom{e+k-1}{e}$

另外发现不同质因子相互不干扰，所以 $f(x)$ 是积性函数

用min25筛求其前缀和，$f_1'(x)=1，presumff1(x)=x-1$

---
[2022牛客多校6D](https://ac.nowcoder.com/acm/contest/33191/D)

$ans=\sum\limits_{i=1}^nf(i)$

对于 $f(i)$，可以先想想如何暴力判断，质因数分解，然后每次取两个相异的，指数最高的，质因子，如果能取光，那 $f(i)=1$，否则 $f(i)=0$

因为每次取两个，所以总指数和是偶数

有一个经典结论，一堆元素分成多组，每次从不同的两组各拿一个，那么能拿完的条件是，元素个数最多的一组，的元素个数，小于等于全部元素数/2

因此，$x=\prod\limits_{i=1}^kp_i^{e_i}$

$f(x)=[\left(\sum\limits_{i=1}^k e_i\right)\%2=0][2\max e_i\le \sum\limits_{i=1}^ke_i]$

根据拆条件技巧，$f'(x)=1$，也就是第一部分处理质数个数，然后第二部分多传两个参数，表示指数和，最大指数

然后递归子问题时，指数和，和当前枚举指数，取和；最大指数，和当前枚举指数，取max

---
[2022杭电多校7I](http://acm.hdu.edu.cn/showproblem.php?pid=7217)

数组 $a$ 长度 $n(n\le N)$，$a_n\le M$，$f(n,m)$ 为数组长度为 $n$，$a_n=m$ 的方案数

考虑暴力求解 $f(n,m)$，$m=\prod\limits_{i=1}^kp_i^{e_i}$，每种质因数可以放在 $n$ 个位置，转化为同球不同盒有空箱的[球盒问题](https://zhuanlan.zhihu.com/p/557873619)

$f(n,m)=\prod\limits_{i=1}^k\dbinom{e_i+n-1}{e_i}$

$ans=\sum\limits_{i=1}^N\sum\limits_{j=1}^Mf(i,j)$

当 $n$ 固定，$f(n,m)$ 是积性函数，$\sum\limits_{i=1}^mf(n,i)$ 是积性函数前缀和，可以用 min25求

当 $m$ 固定，$\dbinom{e_i+n-1}{e_i}$ 是关于 $n$ 的 $e_i$ 次多项式

设 $E=\sum\limits_{i=1}^ke_i$，$f(n,m)$ 是关于 $n$ 的 $E$ 次多项式，$E\le min(n-1,log_2m)$

$\sum\limits_{j=1}^Mf(n,j)$，也是关于 $n$ 的 $E$ 次多项式

所以可以min25求 $g(i)=\sum\limits_{j=1}^Mf(i,j)$，然后对 $g(i)$ 的前缀和，插值求出 $ans$

min25 求 $g(i)=\sum\limits_{j=1}^Mf(i,j)$，和2022ICPC网络赛1F是一模一样的

# pollard-rho
$O(n^{\frac 14})$ 得找到 $x$ 的一个非1非本身的因子
```cpp
ll fastPower(ll x, ll n, ll p)
{
    ll s = 1;
    for (; n; n >>= 1)
    {
        if (n & 1)
            s = (__int128)s*x%p;
        x=(__in128)x*x%p;
    }
    return s;
}
ll pollardRho(ll n)
{
    auto f = [&](ll x) { return (__int128)x*x%n + 1; };
    ll p = 2, q;
    for (ll i = 1, x = 0, y = 0, t = 0; t++ % 255 || __gcd(p, n) == 1; x = f(x), y = f(f(y)))
    {
        if (x == y)
        {
            x = i++;
            y = f(x);
        }
        q = (__int128)p*abs(x - y)%n;
        if (q)
            p = q;
    }
    return __gcd(p, n);
}
bool millerRabin(ll x)
{
    if (x < 3)
        return x == 2;
    if ((x&1) == 0)
        return false;
    ll v,r=__builtin_ctz(x-1),d=x>>r;
    for (ll a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022})
    {
        v = fastPower(a, d, x);
        if (v <= 1 || v == x - 1)
            continue;
        for (int i = 0; i < r; ++i)
        {
            v = (__int128)v * v % x; // 同样使用__int128过渡
            if (v == x - 1 && i != r - 1)
            {
                v = 1;
                break;
            }
            if (v == 1)
                return false;
        }
        if (v != 1)
            return false;
    }
    return true;
}
ll ans=2;
void maxfactor(ll n)
{
    if (n<ans)
        return;
    if (millerRabin(n))
    {
        ans=n;
        return;
    }
    ll t = pollardRho(n);
    maxfactor(t);
    maxfactor(n / t);
}
ll ans=INF;
void minfactor(ll n)
{
    if (millerRabin(n))
    {
        ans=min(ans,n);
        return;
    }
    ll t = pollardRho(n);
    maxfactor(t);
    maxfactor(n / t);
}
vector<ll> factor;
void allfactor(ll n)
{
    if (millerRabin(n))
    {
        factor.push_back(n);
        return;
    }
    ll t = pollardRho(n);
    maxfactor(t);
    maxfactor(n / t);
}
```

# 多项式

## fft
```cpp
const int MAXN = 1e7 + 10;
const double Pi = acos(-1.0);
struct comp//c++complex头文件的complex类运行速度很慢，所以自己定义复数结构体
{
    double x, y;
    comp (double xx = 0, double yy = 0) {x = xx, y = yy;}
    comp operator + (const comp b) const {return comp(x + b.x,y + b.y);}
    comp operator - (const comp b) const {return comp(x - b.x,y - b.y);}
    comp operator * (const comp b) const {return comp(x * b.x - y * b.y,x * b.y + y * b.x);}
} a[MAXN], b[MAXN];
int l, limit, r[MAXN];
int N,M;
void fft(comp *A, int type)
{
    for (int i = 0; i < limit; i++)//求出要迭代的序列
    {
        if (i < r[i])
            swap(A[i], A[r[i]]);
    }
    for (int mid = 1; mid < limit; mid <<= 1)//待合并区间的中点
    {
        comp Wn( cos(Pi / mid) , type * sin(Pi / mid) );//单位根
        for (int R = mid << 1, j = 0; j < limit; j += R)//R是区间的右端点，j表示前已经到哪个位置了
        {
            comp w(1, 0);//幂
            for (int k = 0; k < mid; k++, w = w * Wn)//枚举左半部分
            {
                comp x = A[j + k], y = w * A[j + mid + k];//蝴蝶效应
                A[j + k] = x + y;
                A[j + mid + k] = x - y;
            }
        }
    }
    if(type==-1)
    {
        for (int i = 0; i <= N + M; i++)
            a[i].x=(double)((int)(a[i].x / limit + 0.5));//四舍五入取整
    }
}
void init(int x)//x表示2个多项式相乘最多有几个单项式
{
    limit=1;
    l=-1;
    while (limit < x)
        limit <<= 1, l++;
    for (int i = 0; i < limit; i++)
        r[i] = ( r[i >> 1] >> 1 ) | ( (i & 1) << l );
}
init(N+M+1);
fft(a, 1);
fft(b, 1);
for (int i = 0; i < limit; i++)
    a[i] = a[i] * b[i];
fft(a, -1);
```
### 三次变两次优化
(a+bi)^2=a^2-b^2+2abi
所以把b放在虚部，答案是虚部/2，注意把fft除limit改成虚部

## 分治fft
```cpp
void solve(int l,int r,int logn)
{
    if(logn<=0) return;
    if(l>=n) return;
    int mid=(l+r)>>1,i;
    ll t=inv(r-l);
    solve(l,mid,logn-1); // 计算左区间
    calcrev(logn);
    memset(a+(r-l)/2,0,sizeof(ll)*(r-l)/2); // 拷贝左区间
    memcpy(a,f+l,sizeof(ll)*(r-l)/2); // 填充0
    memcpy(b,g,sizeof(ll)*(r-l)); // 拷贝g
    FFT(a,logn,0),FFT(b,logn,0); // 卷积
    for(i=0;i<r-l;i++) a[i]=a[i]*b[i]%kcz;
    FFT(a,logn,1);
    for(i=0;i<r-l;i++) a[i]=a[i]*t%kcz;
    for(i=(r-l)/2;i<r-l;i++)
        f[l+i]=(f[l+i]+a[i])%kcz; // 把卷积后的右半段的数加到f数组后半段
    solve(mid,r,logn-1); // 计算右区间
}
```

## ntt

```cpp
typedef long long ll;
const int MAXN = 3e6 + 10;
const int P = 998244353;
const int G = 3;
const int Gi = 332748118;//G在模P的逆元
int N, M, limit, l, r[MAXN];
ll a[MAXN], b[MAXN];
ll fastpow(ll a, ll k)
{
	ll base = 1;
	for(;k;k>>=1)
    {
		if(k & 1)
            base = (base * a ) % P;
		a = (a * a) % P;
	}
	return base % P;
}
void NTT(ll *A, int type)
{
	for(int i = 0; i < limit; i++)
    {
		if(i < r[i])
            swap(A[i], A[r[i]]);
    }
	for(int mid = 1; mid < limit; mid <<= 1)
    {
		ll Wn = fastpow( type == 1 ? G : Gi , (P - 1) / (mid << 1));
		for(int j = 0,R=mid<<1; j < limit; j +=R)
        {
			ll w = 1;
			for(int k = 0; k < mid; k++, w = (w * Wn) % P)
            {
				 int x = A[j + k], y = w * A[j + k + mid] % P;
				 A[j + k] = (x + y) % P,
				 A[j + k + mid] = (x - y + P) % P;
			}
		}
	}
    if(type==-1)
    {
        ll inv = fastpow(limit, P - 2);
        for(int i=N+M;i>=0;--i)
            A[i]=A[i]*inv%P;
    }
}
void init(int x)
{
    limit=1;
    l=-1;
    while(limit<x)
        limit<<=1,++l;
    for(int i=0;i<limit;++i)
        r[i]=(r[i>>1]>>1)|((i&1)<<l);
}
init(N+M+1);
NTT(a, 1);
NTT(b, 1);
for(int i = 0; i < limit; i++)
    a[i] = (a[i] * b[i]) % P;
NTT(a, -1);
```
## 拉格朗日插值
### 原版
$n$ 个不同点 $(x_i,y_i)$ 确定唯一 $n-1$ 次多项式 $g$

已知 $n$ 个点值，可以 $O(n^2)$ 预处理，$O(nlog(mod))$ 求出 $g(k)$

```cpp
const int N=2e3+3;
const ll mod=998244353;
struct lagrange
{
    int n;
    ll x[N],y[N],w[N];
    long long inv(long long base)
    {
        long long result=1,exponent=mod-2;
        for(;exponent>0;exponent>>=1)
        {
            if(exponent&1)
                result=result*base%mod;
            base=base*base%mod;
        }
        return result;
    }
    void init()
    {
        n=0;
    }
    void insert(ll xx,ll yy)
    {
        x[++n]=xx;
        y[n]=yy;
        ll s=1;
        for(int i=1;i<n;++i)
        {
            w[i]=w[i]*(x[i]-xx)%mod;
            s=s*(xx-x[i])%mod;
        }
        w[n]=s;
    }
    void init2()
    {
        for(int i=1;i<=n;++i)
            w[i]=y[i]*inv(w[i])%mod;
    }
    ll lag(ll k)
    {
        ll s=1;
        for(int i=1;i<=n;++i)
        {
            if(k==x[i])
                return y[i];
            s=s*(k-x[i])%mod;
        }
        ll ans=0;
        for(int i=1;i<=n;++i)
            ans=(ans+s*inv(k-x[i])%mod*w[i]%mod)%mod;
        return (ans+mod)%mod;
    }
}la;
la.init();
la.insert(x,y);
la.init2();
la.lag(k);
```
### 特化版
当给定点值 $x_i$ 连续，可以 $O(n)$ 预处理，$O(n)$ 求 $g(k)$

$g(n)=\sum\limits_{i=1}^{k}y_i\prod\limits_{j=1,j\ne i}^{k}\frac{n-j}{i-j}$

$g(n)=\sum\limits_{i=1}^{k}y_i\left(\prod\limits_{j=1,j\ne i}^{k}(i-j)\right)^{-1}\prod\limits_{j=1,j\ne i}^{k}(n-j)$

$g(n)=\sum\limits_{i=1}^{k}y_i\left(\prod\limits_{j=1}^{i-1}(i-j)\prod\limits_{j=i+1}^{k}(i-j)\right)^{-1}\prod\limits_{j=1}^{i-1}(n-j)\prod\limits_{j=i+1}^{k}(n-j)$

$g(n)=\sum\limits_{i=1}^{k}y_i\left(\prod\limits_{j=1}^{i-1}j\prod\limits_{j=i-k}^{-1}j\right)^{-1}\prod\limits_{j=1}^{i-1}(n-j)\prod\limits_{j=i+1}^{k}(n-j)$

$pre_i=\prod\limits_{j=1}^i(n-j)，suf_i=\prod\limits_{j=i}^k(n-j)$

$g(n)=\sum\limits_{i=1}^{k}y_i(-1)^{k-i}\left((i-1)!(k-i)!\right)^{-1}pre_{i-1}suf_{i+1}$
```cpp
const int N=1e6+3;
const ll mod=1e9+7;
long long fac[N],inv[N];
long long fast_power(long long base, long long exponent)
{
    long long result = 1;
    for (; exponent > 0; exponent >>= 1)
    {
        if (exponent & 1)
            result = result * base % mod;
        base = base * base % mod;
    }
    return result;
}
void getC()
{
    fac[0]=1;
    for(int i=1;i<N;++i)
        fac[i]=fac[i-1]*i%mod;
    inv[N-1]=fast_power(fac[N-1],mod-2);
    for(int i=N-1;i;--i)
        inv[i-1]=inv[i]*i%mod;
}
struct lagrange
{
    ll y[N],pre[N],suf[N];
    ll lag(ll m,int k)//g(m)，k个点
    {
        if(m<=k)
            return y[m];
        pre[0]=suf[k+1]=1;
        for(int i=1;i<k;++i)
            pre[i]=pre[i-1]*(m-i)%mod;
        for(int i=k;i>1;--i)
            suf[i]=suf[i+1]*(m-i)%mod;
        ll ans=0;
        for(int i=1;i<=k;++i)
            ans=(ans+y[i]*inv[i-1]%mod*inv[k-i]%mod*pre[i-1]%mod*suf[i+1]%mod*((k-i)&1?-1:1))%mod;
        return (ans+mod)%mod;
    }
}la;
la.y[i]=y;
la.lag(m,k);
```
# 高等数学
# 函数
## 有界性
$\forall x,f(x)\le MAX$，$MAX$ 称为上界

$\forall x,f(x)\ge MIN$，$MIN$ 称为下界

$\forall x,|f(x)|<=M$，$M$ 称为界
## 初等函数
1. 幂函数：$y=x^k$
2. 指数函数：$y=a^x$
3. 对数函数：$y=\log_a x$
4. 三角函数：$y=\sin x,\cos x,\tan x=\frac{\sin x}{\cos x},\cot x=\frac 1{\tan x},\sec x=\frac 1{\cos x},\csc x=\frac 1{\sin x}$
5. 反三角函数：$y=\arcsin x$ 等

由以上5种，基本初等函数，经过有限次的四则运算和有限次的函数复合，的函数为初等函数
# 函数的极限存在的充分必要条件
$x$ 从左侧趋于 $x_0$ 记作 $x\rightarrow x_0^-$，$x$ 从右侧趋于 $x_0$ 记作 $x\rightarrow x_0^+$

$\lim\limits_{x\rightarrow x_0^-}f(x)=A=\lim\limits_{x\rightarrow x_0^+}f(x)$
# 无穷小与无穷大
## 无穷小定义
如果函数 $\lim\limits_{x\rightarrow x_0或x\rightarrow \infty}f(x)=0$，那么称函数 $f(x)$ 为当 $x\rightarrow x_0或x\rightarrow \infty$ 时的无穷小
## 无穷大定义
如果函数 $\lim\limits_{x\rightarrow x_0或x\rightarrow \infty}f(x)=\infty$，那么称函数 $f(x)$ 为当 $x\rightarrow x_0或x\rightarrow \infty$ 时的无穷大
## 无穷大和无穷小的联系
在自变量的同一变化过程中，如果 $f(x)$ 为无穷大，那么 $\frac 1{f(x)}$ 为无穷小；

反之，如果 $f(x)$ 为无穷小，且 $f(x)\ne 0$，那么 $\frac 1{f(x)}$ 为无穷大；
# 极限运算法则
1. 有限个无穷小之和是无穷小
2. 有界函数与无穷小的乘积是无穷小
3. 有限个无穷小之积是无穷小
4. 四则运算，即 $\lim f(x)=A,\lim g(x)=B$  
$\lim[f(x)+g(x)]=\lim f(x)+\lim g(x)=A+B$  
$\lim[f(x)-g(x)]=\lim f(x)-\lim g(x)=A-B$  
$\lim[f(x)g(x)]=\lim f(x)\lim g(x)=AB$  
$\lim[\frac{f(x)}{g(x)}]=\frac {\lim f(x)}{\lim g(x)}=\frac AB$，且 $B\ne 0$
5. 4的推论，$c$ 为常数，$\lim[cf(x)]=c\lim f(x)$
6. 4的推论，$n$ 为正整数，$\lim[f(x)]^n=[\lim f(x)]^n$
7. 复合函数的极限运算法则，先求内层函数的极限，再把这个极限代回去求外层函数的极限
# 几个重要极限
1. $\lim\limits_{x\rightarrow 0}\frac {\sin x}{x}=1$
2. $\lim\limits_{x\rightarrow 0}\cos x=1$
3. $\lim\limits_{x\rightarrow\infty}\left(1+\frac 1x \right)^x=e$
# 无穷小的比较
## 常见等价无穷小
1. $\sin x\sim x$
2. $\tan x\sim x$
3. $1-\cos x\sim \frac 12 x^2$
4. $e^x-1\sim x$
5. $\ln(1+x)\sim x$
6. $\sqrt[n]{1+x}-1\sim\frac xn$
## 等价无穷小运算法则
设 $\alpha\sim\tilde\alpha,\beta\sim\tilde\beta$，且 $\lim\frac{\tilde\beta}{\tilde\alpha}$ 存在，则 $\lim\frac{\beta}{\alpha}=\lim\frac{\tilde\beta}{\tilde\alpha}$
# 函数的求导法则
1. 设 $u=u(x),v=v(x)$  
$[u+v]'=u'+v'$  
$[u-v]'=u'-v'$  
$[uv]'=u'v+uv'$  
$[\frac uv]'=\frac{u'v+uv'}{v^2}$，且 $v\ne 0$
2. 反函数的求导法则，即函数 $x=f(y)$，反函数 $y=f^{-1}(x)$  
$[f^{-1}(x)]'=\frac 1{f'(y)}$
3. 复合函数的求导法则，即 $y=f(u),u=g(x)$  
$[f(g(x))]'=f'(u)g'(x)$
# 基本初等函数的导数公式
1. $(x^k)'=kx^{k-1}$
2. $(a^x)'=a^x\ln a$
3. $(\log_a x)'=\frac 1{xln a}$
4. $(\sin x)'=\cos x$
5. $(\cos x)'=-\sin x$
6. $(\tan x)'=\sec^2 x$
7. $(\cot x)'=-\csc^2 x$
8. $(\sec x)'=\sec x\tan x$
9. $(\csc x)'=-\csc x\cot x$
10. $(\arcsin x)'=\frac 1{\sqrt{1-x^2}}$
11. $(\arccos x)'=-\frac 1{\sqrt{1-x^2}}$
12. $(\arctan x)'=\frac 1{1+x^2}$
13. $(arccot~x)'=-\frac 1{1+x^2}$
# 高阶导数
对导数再次求导，即可得更高阶导数
# 洛必达法则
对于 $\frac 00,\frac{\infty}{\infty}$ 型的极限的商，不能用“商的极限等于极限的商”这一法则，因此用洛必达法则，即

$\lim\frac{f(x)}{F(x)}=\lim\frac{f'(x)}{F'(x)}$
# 泰勒公式
用多项式近似表达函数，即

$f(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)$
# 题目

# [2021ICPC网络赛2G](https://pintia.cn/market/item/1442013218528759808)
Given $2n$ integers, $a_1,a_2,…,a_n,b_1,b_2,…,b_n,$ and an integer $t$. You need to calculate:

$\lim\limits_{x→0}\frac{\sum\limits_{i=1}^na_i\times ln(1+b_i\times x)}{x^t}$.
## Input
The first line consists of two integers $n,t$.

In the following $n$ lines, the $i$-th line consists of two integers $a_i,b_i$.

$1≤n≤100000,−100≤a_i,b_i≤100,0≤t≤5$.
## Output
Please output the result of this limit.

If the result is $\infty$, please output "infinity" (without quotes). And if the result is an integer, please output this integer directly. Otherwise, the answer must be $\frac ab$, such that $a$ and $b$ are coprime and $b≥2$, please output "$a/b$".
## Sample Input 1
```
2 2
1 1
1 -1
```
## Sample Output 1
```
-1
```
## Sample Input 2
```
2 1
1 1
1 -1
```
## Sample Output 2
```
0
```
## Sample Input 3
```
2 3
1 1
1 -1
```
## Sample Output 3
```
infinity
```
## Solution
$\lim\limits_{x→0}\frac{\sum\limits_{i=1}^na_i\times ln(1+b_i\times x)}{x^t}$

$\sum\limits_{i=1}^na_i\lim\limits_{x→0}\frac{ln(1+b_i\times x)}{x^t}$

直接对后半部分洛必达会发现洛1次之后就不是 $\frac 00$ 的形式，因此泰勒公式来近似后半部分

$f(x)=ln(1+b_i\times x)$

$f'(x)=\frac{b_i}{1+b_ix}$

$f''(x)=\frac{-b_i^2}{1+2b_ix+b_i^2x^2}$

$f'''(x)=\frac{2b_i^3+2b_i^4x}{1+4b_ix+6b_i^2x^2+4b_i^3x^3+b_i^4x^4}$

$f''''(x)=\frac{-6b_i^4-24b_i^5x-36b_i^6x^2-24b_i^7x^3-6b_i^8x^4}{(1+4b_ix+6b_i^2x^2+4b_i^3x^3+b_i^4x^4)^2}$

$f'''''(x)=...$

$x_0=0$

$f(x)=b_ix-\frac 12b_i^2x^2+\frac{1}{3}b_i^3x^3-\frac 1{4}b_i^4x^4+\frac 15b_i^5x^5+...$

$ans=\sum\limits_{i=1}^na_i\lim\limits_{x\to 0}\frac {f(x)}{x^t}$

$t=0,ans=0$

$t=1,ans=\sum\limits_{i=1}^na_ib_i$

$t=2,ans=\sum\limits_{i=1}^na_i\frac{-b_i^2}{2}$

$t=3,ans=\sum\limits_{i=1}^na_i\frac{b_i^3}{3}$

$t=4,ans=\sum\limits_{i=1}^na_i\frac{-b_i^4}{4}$

$...$

由于只有 $\frac 00$ 形式能一直洛，所以中间结果如果不是 $\frac 00$，那答案为 $\infty$
```cpp
ll g[7];
string solve(int n,int t)
{
    if(t==0)
        return "0";
    ll a,b;
    for(int i=0;i<n;++i)
    {
        cin>>a>>b;
        for(int j=1;j<=t;++j)
        {
            a*=b;
            if(j&1)
                g[j]+=a;
            else
                g[j]-=a;
        }
    }
    for(int i=1;i<t;++i)
    {
        if(g[i])
            return "infinity";
    }
    ll gc=__gcd(g[t],(ll)t);
    string ans=to_string(g[t]/gc);
    if(t!=gc)
        ans+=" "+to_string(t/gc);
    return ans;
}
```
# [2021ICPC昆明C](https://ac.nowcoder.com/acm/contest/32708/C)
There is an empty cup, and a dumb robot is going to fill it with $1$ liter of water.

For every turn, the robot will randomly select a real number $t$ between $0$ and $x$ ($x$ is a given number) and then fill the cup with $t$ liter of water. The robot will repeat it until the cup is full (at least $1$ liter of water has been filled).

You need to answer the expected number of turns the robot should fill.
## Input
The first line contains an integer $T(T\leq 10000)$, denoting the number of test cases.

In the following $T$ lines, each line contains a real number $x(0.05\leq x\leq 10^9)$, describing a test case.

It is guaranteed that $x$ contains no more than $3$ decimal places.
## Output
For each test case, output one line with a real number, denoting the expected number of turns.

Any answer with a relative or absolute error less than $10^{-4}$ will be accepted.
## Sample Input 1
```
2
0.3
1.5
```
## Sample Output 1
```
7.3332227396
1.9477340411
```
## Solution
设 $f(x)$ 为每次均匀随机走 $[0,a]$，达到大于等于 $x$ 的期望次数，由全期望公式

$$f(x)=1+\int_{max(0,x-a)}^x\frac{f(t)}adt$$

对两边求导

$$af'(x)=f(x)-f(x-a)$$

### 定义近似计算
$$a\frac{f(x+\Delta x)-f(x)}{\Delta x}=f(x)-f(x-a)$$

$$f(x+\Delta x)=f(x)+\frac{\Delta x}a(f(x)-f(x-a))$$

$f(0)=1$ 表示无穷小期望为1，那么 $ans=f(1)$

由于是多组数据，原问题步长 $[0,a]$，大于等于1的期望步数，等价于，步长 $[0,1]$，大于等于 $\frac 1a$ 的期望步数，故上式改为

$$f(x+\Delta x)=f(x)+\Delta x(f(x)-f(x-1))$$

$ans=f(\frac 1a)$
```cpp
const int maxn = 1e5;
const double dx = 1.0 / maxn;
double f[maxn * 20 + 100];
void init()
{
    f[0] = 1;
    for(int i=0;i<maxn;++i)
        f[i + 1] = (dx+1) * f[i];
    for (int i = maxn; i < 20 * maxn + 99; i++)
        f[i + 1] = f[i] + dx * (f[i] - f[i - maxn]);
}
double solve(double x)
{
    return f[(int)(maxn / x)];
}
```
### 推精准式子
转化为步长为 $[0,1]$ 的问题

$$f'(x)=f(x)-f(x-1)$$

对 $x$ 范围分类讨论

---
当 $x\in(0,1],f(x-1)=0$

$f'(x)=f(x)$，满足这个式子，已知的有 $e^x$

所以，$f(x)=Ce^x$

当 $x\to 0^+$,$f(x)\to 1$，所以 $f(x)=e^x$

---
当 $x\in(1,2],f(x-1)=e^{x-1}$

$f'(x)=f(x)-e^{x-1}$，满足这个式子，嗯凑凑出 $-xe^{x-1}$

所以，$f(x)=-xe^{x-1}$

当 $x\to 1^-$,$f(x)\to e$，

由于连续性，$x\to 1^+$,$f(x)\to e$，

和 $f(1^+)=-1e^{1-1}$ 差了 $1+e$

因此补上一些东西使式子成立，而 $Ce^x$ 不影响式子成立

所以，$f(x)=Ce^x-xe^{x-1}=(1+\frac 1e)e^x-xe^{x-1}=e^x-(x-1)e^{x-1}$

---
当 $x\in(2,3],f(x-1)=e^{x-1}-(x-2)e^{x-2}$

$f'(x)=f(x)-(e^{x-1}-(x-2)e^{x-2})$，满足这个式子，嗯凑凑出 $-xe^{x-1}+\frac 12(x-2)^2e^{x-2}$

所以，$f(x)=-xe^{x-1}+\frac 12(x-2)^2e^{x-2}$

当 $x\to 2^-$,$f(x)\to e$，

由于连续性，$x\to 1^+$,$f(x)\to e^2-e$，

和 $f(2^+)=-2e^{2-1}$ 差了 $e^2+e$

因此补上一些东西使式子成立，而 $Ce^x$ 不影响式子成立

所以，$f(x)=Ce^x-xe^{x-1}+\frac 12(x-2)^2e^{x-2}=(1+\frac 1e)e^x-xe^{x-1}+\frac 12(x-2)^2e^{x-2}=e^x-(x-1)e^{x-1}+\frac 12(x-2)^2e^{x-2}$

---
仿照以上方法，发现规律，$x\in(k,k+1]$

$$f(x)=\sum\limits_{i=0}^k\frac{(-1)^i}{i!}(x-i)^ie^{x-i}$$

$ans=f(\frac 1a)$
```cpp
double solve(double x)
{
    x = 1 / x;
    double ans = 0, fac = 1;
    for (int i = 0; i < x; i++)
    {
        if (i & 1)
            ans -= fac * pow(x - i, i) * exp(x - i);
        else
            ans += fac * pow(x - i, i) * exp(x - i);
        fac /= (i + 1);
    }
    return ans;
}
```
# 数学杂

# 线性回归

一堆点 $(x_i,y_i)$ ，求一条直线 $F(x):y=Ax+B$ ，使得 $\sum\limits_{i=1}^n (y_i-F(x_i))^2$ 最小

设 $\overline{x}=\frac{\sum\limits_{i=1}^n x_i}n$ ， $\overline{y}=\frac{\sum\limits_{i=1}^n y_i}n$

$A=\frac{\sum\limits_{i=1}^n x_iy_i-n\overline{x} \overline{y}}{\sum\limits_{i=1}^n x_i^2-n\overline{x}^2}$

$B=\overline{y}-A\overline{x}$

# 自然数幂和
$\sum\limits_{i=1}^n i=n(n+1)/2$

$\sum\limits_{i=1}^n i^2=n(n+1)(2n+1)/6$

$\sum\limits_{i=1}^n i^3=n^2(n+1)^2/4$

$\sum\limits_{i=1}^n i^4=n(n+1)(6n^3+9n^2+n-1)/30$

$\sum\limits_{i=1}^n i^5=n^2(n+1)(2n^3+4n^2+n-1)/12$

## 递推式推导

设 $f_n^p=\sum\limits_{i=1}^n i^{p}$

$(n+1)^p-n^p=C_p^1n^{p-1}+C_p^2n^{p-2}+...+1$

$\sum\limits_{n=1}^m(n+1)^p-n^p=\sum\limits_{n=1}^mC_p^1n^{p-1}+C_p^2n^{p-2}+...+1$

$(m+1)^p-1=C_p^1f_m^{p-1}+C_p^2f_m^{p-2}+...+m$

$f_m^{p-1}=((m+1)^p-1-(C_p^2f_m^{p-2}+...+m))/C_p^1$

$f_m^{p}=((m+1)^{p+1}-1-(C_{p+1}^2f_m^{p-1}+...+m))/(p+1)$
## 求法
### 拉格朗日插值
如果有取模，那么模数必须质数

自然数k次幂和是k+1次函数，求前k+2个点的点值，插就完了
```cpp
const int N=1e6+3;
const ll mod=1e9+7;
long long fac[N],inv[N];
long long fast_power(long long base, long long exponent)
{
    long long result = 1;
    for (; exponent > 0; exponent >>= 1)
    {
        if (exponent & 1)
            result = result * base % mod;
        base = base * base % mod;
    }
    return result;
}
void getC()
{
    fac[0]=1;
    for(int i=1;i<N;++i)
        fac[i]=fac[i-1]*i%mod;
    inv[N-1]=fast_power(fac[N-1],mod-2);
    for(int i=N-1;i;--i)
        inv[i-1]=inv[i]*i%mod;
}
struct lagrange
{
    ll y[N],pre[N],suf[N];
    ll lag(ll m,int k)//g(m)，k个点
    {
        if(m<=k)
            return y[m];
        pre[0]=suf[k+1]=1;
        for(int i=1;i<k;++i)
            pre[i]=pre[i-1]*(m-i)%mod;
        for(int i=k;i>1;--i)
            suf[i]=suf[i+1]*(m-i)%mod;
        ll ans=0;
        for(int i=1;i<=k;++i)
            ans=(ans+y[i]*inv[i-1]%mod*inv[k-i]%mod*pre[i-1]%mod*suf[i+1]%mod*((k-i)&1?-1:1))%mod;
        return (ans+mod)%mod;
    }
}la;
getC();
for(int i=1;i<=k+2;++i)
    la.y[i]=(la.y[i-1]+fast_power(i,k))%mod;
cout<<la.lag(n,k+2);
```
### 第2类斯特林数
不需要逆元

$\sum\limits_{i=1}^ni^k=\sum\limits_{j=0}^{k}S_2(k,j)\frac{(n+1)^{\underline{j+1}}}{j+1}$
```cpp
struct powersum
{
    int k;
    ll s[K][K];
    void init(int kk)
    {
        k=kk;
	    s[0][0]=1;
	    for(int i=1;i<=k;++i)
		    for(ll j=1;j<=i;++j)
			    s[i][j]=s[i-1][j-1]+j*s[i-1][j];
    }
    ll cal(ll n)
    {
        ll res,ans=0;
        for(ll i=0;i<=k;++i)
        {
            res=s[k][i];
            for(ll j=0;j<=i;++j)
            {
                if((n+1-j)%(i+1))
                    res=res*(n+1-j);
                else
                    res=res*((n+1-j)/(i+1));
            }
            ans=ans+res;
        }
        return ans;
    }
};
```
# 调和级数近似公式

n 很大时

$f_n\approx \ln n+0.5772156649+\frac 1{2n}$

```cpp
log(n)+0.5772156649+1.0/(2*n)
```
# 狄利克雷前后缀
$O(n\log\log n)$

原缀已知 $a$，求 $b$

逆缀已知 $b$，求 $a$

答案保存在原数组上
## 狄利克雷前缀
$b_n=\sum\limits_{d|n}a_d$
```cpp
for(int i=1;i<=cnt && primes[i]<=n;++i)
{
    for(int j=1;j*primes[i]<=n;++j)
        a[j*primes[i]]+=a[j];
}
```
## 狄利克雷后缀
$b_d=\sum\limits_{d|n}a_n$
```cpp
for(int i=1;i<=cnt && primes[i]<=n;++i)
{
    for(int j=n/primes[i];j;--j)
        a[j]+=a[j*primes[i]];
}
```
## 逆狄利克雷前缀
$b_n=\sum\limits_{d|n}a_d$
```cpp
for(int i=cnt;i;--i)
{
    for(int j=n/primes[i];j;--j)
        a[j*primes[i]]-=a[j];
}
```
## 逆狄利克雷后缀
$b_d=\sum\limits_{d|n}a_n$
```cpp
for(int i=cnt;i;--i)
{
    for(int j=1;j*primes[i]<=n;++j)
        a[j]-=a[j*primes[i]];
}
```
# 广义斐波那契数列求循环节

$f_n=af_{n-1}+bf_{n-2}$

## $f_n\pmod p$的最小循环节长度

1. 分解$p$为素因子幂的形式，即$p=\prod p_i^{a_i}$
2. 计算数列模$p_i^{a_i}$的循环节长度，设长度为$x_i$

$x_i=G(p_i)*p^{a_i-1}$

$G(p)$ 表示模$p$的最小循环节长度

求$G(p)$,设$c=a^2+4b$

$p=2$要特判（具体怎么判待研究）

## 欧拉准则

若 p 是奇质数且$p\nmid d$，

d 是模 p 的二次剩余当且仅当：

$d^{(p-1)/2}=1 \pmod p$

否则，d 是模 p 的二次非剩余

---

若$c$是$p$的二次剩余,枚举$p-1$的因子

若$c$是$p$的二次非剩余,枚举$(p-1)(p+1)$的因子

找到$G(p)$满足

$\begin{bmatrix}a&b\\1&0\end{bmatrix}^{G(p)} =\begin{bmatrix}1&0\\0&1\end{bmatrix} \pmod {p}$

3. 循环节长度$L=lcm(x_i)$

## 求较小循环节

注意到 $G(p)$一定是$(p-1)(p+1)$的因子

所以$x_i$一定是$(p_i-1)(p_i+1)*p_i^{a_i-1}$的因子

循环节长度$L=\prod (p_i-1)(p_i+1)*p_i^{a_i-1} \pmod p$