- 概率论
- 组合数学
  - 导读
  - 组合数取模
  - 球盒问题
  - 卡特兰数高精
- 群论
- 线性代数
  - 导读
  - 矩阵快速幂
  - 高斯消元
- 数论
  - 导读
  - Miller-Rabin
  - 逆元
  - 积性函数筛
  - 拓展欧拉定理
  - 卷积&莫反
  - 卷积&莫反例题
  - 杜教筛
  - 原根
  - bsgs&EXbsgs
  - crt&EXcrt
  - EXgcd
- 多项式
  - fft
  - ntt
- 杂

# 概率论

计算某个事件的概率和期望

当概率论和 DP 复合时，问题转化为图上问题，状态看成点，状态转移看成边

如果该问题无后效性，那么按照拓扑序 DP，否则高斯消元

如果纯概率论题，套公式即可

# 简要概念&公式

## 随机变量

值无法预先确定，仅以一定可能性取值的量

按照值的数量分为

离散型，值数量有限

连续型，值数量无限

> 以下按照这个分类讲述

## 连续型概率

$$\forall a，P(X=a)=0$$
设随机变量 $X$，设密度函数 $f$
$$P(a<X\le b)=\int_{a}^bf(x)dx$$
密度满足
$$\int_{-\infty}^{+\infty}f(x)dx=1$$
分布函数$F(x)$
$$F(x)=P(X\le x)=\int_{-\infty}^xf(x)dx$$
若$F(x)$处处连续可微，则
$$F'(x)=f(x)$$

### 分布函数性质

1. $F(-\infty)=0，F(+\infty)=1$
2. $F(x)$ 单调非递减

## 离散型概率

发生事件 $A$ 的概率，记做 $P(A)$

加法公式
$$P(A\cup B)=P(A)+P(B)-P(A\cap B)$$
$P(A\cup B)$ 表示发生 A 或 B 的概率

$P(A\cap B)$ 表示同时发生 A 和 B 的概率，以下简写为 $P(AB)$

条件概率
$$P(B|A)=\frac{P(AB)}{P(A)}$$
$P(B|A)$ 表示已经发生 $A$，再发生 $B$ 的概率

乘法公式
$$P(AB)=P(A)P(B|A)=P(B)P(A|B)$$

全概率公式
$$P(B)=\sum\limits_{i=1}^nP(A_i)P(B|A_i)$$

贝叶斯公式
$$P(B_i|A)=\frac{P(B_i)P(A|B_i)}{\sum\limits_{j=1}^nP(B_j)P(A|B_j)}$$

## 连续型期望

$$E(X)=\int_{-\infty}^{+\infty}xf(x)dx$$

## 离散型期望

$$E(X)=\sum\limits_{i=1}^nx_iP_i$$

## 期望性质

全期望公式
$$E(Y)=\sum P(X=a)E(Y|X=a)$$
期望的线性性
$$E(aX+b)=aE(x)+b$$
$$E(X+Y)=E(X)+E(Y)$$
若 $X，Y$ 独立，则
$$E(XY)=E(X)E(Y)$$
独立：$P(AB)=P(A)P(B)$

# 概率 DP

根据全概率公式，设点 $v$ 的入边的另一个点 $u$
$$P(v)=\sum P(u)P(v|u)$$

# 期望 DP

## 递推公式

$P(X)，E(X)$ 表示$X$ 到终点的概率，期望

如果有自环，需要移项使得两边没有同样的式子

需要建反图跑 DP

（统计出边）
$$E(Y)=\sum [E(X)+W(Y\rightarrow X)P(Y)]P(X|Y)$$

## 期望和概率的一个联系

全集有 n 种数，手上有 i 种数，全集中随机选数

获得新数的概率是 $\frac {n-i}n$

取得新数要取的次数的期望为 $\frac 1p=\frac n{n-i}$

那么获得全集的次数为 $\sum\limits_{i=0}^{n-1} \frac n{n-i}=\sum\limits_{i=1}^{n-1} \frac ni$

Q:为什么期望是概率分之一

A:如果你平均取 n 个球才会出现 1 个红球，也就是说期望是 n，那又可以说成是平均每 n 个球中出现 1 个红球，所以概率是 $\frac{1}{n}$

也可以用 DP 解释

设 $f_i$ 表示已取到 i 种数，还需要取的次数的期望

可得 $f_{i}=f_{i+1}\times \frac {n-i}n+f_{i}\times \frac {i}n+1$

可得 $f_{i}=f_{i+1}+\frac n{n-i}$

# min-max 容斥计算期望

$$max(S)=\sum\limits_{T\subseteq S}min(T)(-1)^{|T|-1}$$
max 表示满足所有条件的期望，min 表示满足至少一个条件的期望

# 组合数学导读

# 排列数&组合数

## 排列数

$n$ 个数选 $m$ 个排列，情况总数=$A_n^m=\frac{n!}{(n-m)!}$

全排列，指 $n$ 个数选 $n$ 个排列，情况总数=$A_n^n=n!$

## 组合数

$n$ 个数选 $m$ 个组合，情况总数=$C_n^m=\frac{n!}{m!(n-m)!}$

组合数也常用$\displaystyle\binom{n}{m}$表示

组合数也被称为“二项式系数”

# 二项式定理

$$(a+b)^n=\sum\limits_{i=0}^n \displaystyle\binom{n}{i} a^ib^{n-i}$$

# 多重集

## 多重集的排列数

$$\frac{n!}{\prod_{i=1}^k(n_i!)}$$

## 多重集的组合数

$$\binom{r+k-1}{k-1}$$

# 不相邻的排列

$1 \sim n$ 这 $n$ 个自然数中选 $k$ 个，这 $k$ 个数中任何两个数都不相邻的组合有 $\displaystyle \binom {n-k+1}{k}$ 种。

# 圆排列

$n$ 个人全部来围成一圈，所有的排列数记为 $\mathrm Q_n^n$。考虑其中已经排好的一圈，从不同位置断开，又变成不同的队列。
所以有

$$\mathrm Q_n^n \times n = \mathrm A_n^n \Longrightarrow \mathrm Q_n = \frac{\mathrm A_n^n}{n} = (n-1)!$$

由此可知部分圆排列的公式：

$$\mathrm Q_n^r = \frac{\mathrm A_n^r}{r} = \frac{n!}{r \times (n-r)!}$$

# 组合数性质

$$\binom{n}{m}=\binom{n}{n-m}\tag{1}$$

相当于将选出的集合对全集取补集，故数值不变。（对称性）

$$\binom{n}{k} = \frac{n}{k} \binom{n-1}{k-1}\tag{2}$$

由定义导出的递推式。

$$\binom{n}{m}=\binom{n-1}{m}+\binom{n-1}{m-1}\tag{3}$$

组合数的递推式（杨辉三角的公式表达）

$$\binom{n}{0}+\binom{n}{1}+\cdots+\binom{n}{n}=\sum_{i=0}^n\binom{n}{i}=2^n\tag{4}$$

这是二项式定理的特殊情况。取 $a=b=1$ 就得到上式。

$$\sum_{i=0}^m \binom{n}{i}\binom{m}{m-i} = \binom{m+n}{m}\ \ \ (n \geq m)\tag{5}$$

拆组合数的式子，在处理某些数据结构题时会用到。

$$\sum_{i=0}^n\binom{n}{i}^2=\binom{2n}{n}\tag{6}$$

这是 $(5)$ 的特殊情况，取 $n=m$ 即可。

$$\sum_{i=0}^ni\binom{n}{i}=n2^{n-1}\tag{7}$$

带权和的一个式子，通过对 $(3)$ 对应的多项式函数求导可以得证。

$$\sum_{i=0}^ni^2\binom{n}{i}=n(n+1)2^{n-2}\tag{8}$$

与上式类似，可以通过对多项式函数求导证明。

$$\sum_{l=0}^n\binom{l}{k} = \binom{n+1}{k+1}\tag{9}$$

在恒等式证明中较常用。

$$\binom{n}{r}\binom{r}{k} = \binom{n}{k}\binom{n-k}{r-k}\tag{10}$$

通过定义可以证明。

$$\sum_{i=0}^n\binom{n-i}{i}=F_{n+1}\tag{11}$$

其中 $F$ 是斐波那契数列。

## 二项式反演

$f(n)=\sum\limits_{k=0}^n \dbinom nk g(k)$

$g(n)=\sum\limits_{k=0}^n (-1)^{n-k}\dbinom nkf(k)$

# 常见数列

## 错排问题

$f_n=(n-1)(f_{n-1}+f_{n-2})$。

错位排列数列的前几项为 $0,1,2,9$。

## 卡特兰数

### 经典题：进出栈序列

n 个元素进栈序列为：1，2，3，4，...，n，则有多少种出栈序列

我们将进栈表示为 +1，出栈表示为 -1

出栈序列的所有前缀和必然大于等于 0，并且序列 +1 的数量 等于 -1 的数量

接下来让我们观察一下 n = 3 的一种出栈序列：+1 -1 -1 +1 -1 +1。序列前三项和小于 0，显然这是个非法的序列。

如果将 第一个 前缀和小于 0 的前缀，即前三项元素都进行取反，就会得到：-1 +1 +1 +1 -1 +1。此时有 3 + 1 个 +1 以及 3 - 1 个 -1。

因为这个小于 0 的前缀和必然是 -1，且 -1 比 +1 多一个，取反后，-1 比 +1 少一个，则 +1 变为 n + 1 个，且 -1 变为 n - 1 个。进一步推广，对于 n 元素的每种非法出栈序列，都会对应一个含有 n + 1 个 +1 以及 n - 1 个 -1 的序列。

如何证明这两种序列是一一对应的？

假设非法序列为 A，对应的序列为 B。每个 A 只有一个"第一个前缀和小于 0 的前缀"，所以每个 A 只能产生一个 B。而每个 B 想要还原到 A，就需要找到"第一个前缀和大于 0 的前缀"，显然 B 也只能产生一个 A。

每个 B 都有 n + 1 个 +1 以及 n - 1 个 -1，因此 B 的数量为 $\dbinom {2n}{n+1}$ ，相当于在长度为 2n 的序列中找到 n + 1 个位置存放 +1。相应的，非法序列的数量也就等于 $\dbinom {2n}{n+1}$ 。

出栈序列的总数量共有 $\dbinom {2n}{n}$ ，因此，合法的出栈序列的数量为 $\dbinom {2n}{n}-\dbinom {2n}{n+1}$ 。

此时我们就得到了卡特兰数的通项 $\dbinom {2n}{n}-\dbinom {2n}{n+1}=\dbinom{2n}{n}/(n+1)$

### 例题

n 对括号，则有多少种 “括号匹配” 的括号序列

左括号+1，有括号-1

n + 1 个叶子节点能够构成多少种形状不同的满二叉树

> 如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。

非叶节点，左子树+1，右子树-1

电影票一张 50 coin，且售票厅没有 coin。m 个人各自持有 50 coin，n 个人各自持有 100 coin。则有多少种排队方式，可以让每个人都买到电影票。

50+1，100-1

公式不同，$\dbinom {n+m}n-\dbinom{n+m}{m+1}$

节点数为 $i$ 时二叉树构造的方案数

> 写题就是寻找满足下列公式的特点

### 公式

$C_n=\dbinom{2n}{n}/(n+1)$

$C_1=1,C_n=C_{n-1}\times\frac{4n-2}{n+1}$

$C_n=\begin{cases}1&n=0,1\\\sum\limits_{i=1}^n C_{i-1}*C_{n-i}&2\le n\end{cases}$

$C_n=\dbinom {2n}{n}-\dbinom {2n}{n+1}$

# 线性求逆元

## 时间复杂度

$O(n)$

```cpp
const int N=1e6+3;
long long fac[N],inv[N];
long long fast_power(long long base, long long exponent)
{
    long long result = 1;
    for (; exponent > 0; exponent >>= 1)
    {
        if (exponent & 1)
            result = result * base % mod;
        base = base * base % mod;
    }
    return result;
}
void getC()
{
    fac[0]=1;
    for(int i=1;i<N;++i)
        fac[i]=fac[i-1]*i%mod;
    inv[N-1]=fast_power(fac[N-1],mod-2);
    for(int i=N-1;i;--i)
        inv[i-1]=inv[i]*i%mod;
}
long long C(int n,int m)
{
    return fac[n]*inv[m]%mod*inv[n-m]%mod;
}
```

# Lucas 定理

## 适用条件

$n,m$ 较大，$p$ 为素数

## 公式

$C(n,m)\%p=C(n/p,m/p)*C(n\%p,m\%p)\%p$

## 时间复杂度

$O(f(x)+g(n)log_p n)$

$f(x)$ 为预处理组合数的复杂度，$g(n)$ 为单次求组合数的复杂度

$p$ 小，逆元打表，$O(n+p+log_p n)$

//$n$ 为处理阶乘，$p$ 为打表，$log_p n$为单次查询

$p$ 大，exgcd 求逆元,$O(n+ln p*log_p n)$

//$n$ 为处理阶乘，$\ln p*log_p n$ 为单次查询

```c++
long long Lucas(long long n, long long m, long long p)
{
    if (m == 0) return 1;
    return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p;
}
```

# exLucas

## 适用条件

$n,m$ 较大，$p$ 不为素数

## 时间复杂度

$O(plog p)$

```c++
ll qpow(ll base,ll exponent,ll mod)
{
    ll result=1;
    for(;exponent;base=base*base%mod,exponent>>=1)
    {
        if(exponent&1)
            result=result*base%mod;
    }
    return result;
}
ll g(ll n,ll p)
{
    if(n<p)
        return 0;
    return g(n/p,p)+n/p;
}
ll calc(ll n,ll p,ll MOD)
{
    if(n==0)
        return 1;
    ll res=1;
    for(ll i=1;i<=MOD;i++)
    {
        if(i%p)
            res=res*i%MOD;
    }
    res=qpow(res,n/MOD,MOD);
    for(ll i=n/MOD*MOD+1;i<=n;i++)
    {
        if(i%p)
            res=res*(i%MOD)%MOD;
    }
    return res*calc(n/p,p,MOD)%MOD;
}
ll exgcd(ll a,ll b,ll &x,ll &y)
{
	if(!b) {x=1,y=0;return a;}
	ll r=exgcd(b,a%b,y,x);
	y-=x*(a/b);
	return r;
}
ll inv(ll a,ll n)
{
    ll x,y;
    if(exgcd(a,n,x,y)==1ll)
        return (x%n+n)%n;
    else
        return -1;
}
ll lucas(ll n,ll m,ll p,ll MOD)
{
    ll pw=qpow(p,g(n,p)-g(m,p)-g(n-m,p),MOD);
    return calc(n,p,MOD)*inv(calc(m,p,MOD),MOD)%MOD*inv(calc(n-m,p,MOD),MOD)%MOD*pw%MOD;
}
ll CRT(const vector<ll> &a,const vector<ll> &m)
{
    int siz=a.size();
    ll mul=1,sum=0;
    for(auto tmp:m)
        mul*=tmp;
    for(int i=0;i<siz;i++)
    {
        ll M=mul/m[i];
        sum=(sum+a[i]*M%mul*inv(M,m[i]))%mul;
    }
    return sum%mul;
}
ll exlucas(ll n,ll m,ll MOD)
{
    vector<ll> a,mod;
    ll tmp=MOD;
    for(int p=2;p<=tmp/p;p++)
    {
        if(tmp%p==0)
        {
            ll mul=1;
            while(tmp%p==0)
                mul*=p,tmp/=p;
            mod.push_back(mul),a.push_back(lucas(n,m,p,mul));
        }
    }
    if(tmp>1) mod.push_back(tmp),a.push_back(lucas(n,m,tmp,tmp));
    return CRT(a,mod);
}
```

# 球盒问题

$n$ 个球，放入 $m$ 个盒中,共 8 种情况

## 球同，盒不同，无空箱

$C(n-1,m-1)$

使用插板法：$n$ 个球中间有 $n-1$ 个间隙，现在要分成 $m$ 个盒子，而且不能有空箱子，所以只要在 $n-1$ 个间隙选出 $m-1$ 个间隙即可

## 球同，盒不同，允许空箱

$C(n+m-1,m-1)$

如果给每个盒子一个球，就可以把问题转化为不能空的情况了,就相当于 $n+m$ 个小球放入 $m$ 个盒子且不能空

## 球不同，盒相同，无空箱

第二类斯特林数 $dp[n][m]$

$dp[n][m]=\begin{cases}m\times dp[n-1][m]+dp[n-1][m-1]&1\le m<n\\1&m=n\\
0&1\le n&m=0\\
0&m>n \end{cases}$

$dp[n][m]$表示 $n$ 个球放在 $m$ 个箱子，每个箱子都有球

对于第 $n$ 个球，如果前面的 $n-1$ 个球已经放在了 $m$ 个箱子里，那么现在第 $n$ 个球放在哪个箱子都是可以的，所以 $m*dp[n-1][m]$

如果前 $n-1$ 个球已经放在了 $m-1$ 个箱子里，那么现在第 $n$ 个球必须要新开一个箱子来存放，（第 $m$ 个箱子现在没有球）所以 $dp[n-1][m-1]$

```c++
ll f(ll n, ll m)
{
    if (m == 0 || n < m)
        return 0;
    if (n == m)
        return 1;
    return f(n-1, m-1) + f(n-1, m) * m;
}
```

## 球不同，盒相同，允许空箱

$\sum\limits_{i=1}^m dp[n][i]$

$dp[n][m]$ 为第二类斯特林数,枚举使用的箱子的个数

## 球不同，盒不同，无空箱

$dp[n][m]*fac[m]$

$dp[n][m]$ 为第二类斯特林数,$fac[m]$ 为 $m$ 的阶乘

因为球是不同的，所以 $dp[n][m]$ 得到的盒子相同的情况，只要再给盒子定义顺序，就等于现在的答案了

## 球不同，盒不同，允许空箱

$m^n$

每个球都有 $m$ 种选择

## 球同，盒同，允许空箱

$dp[n][m]=\begin{cases} 1&n=0,1\\1&m=1\\dp[n][m-1]+dp[n-m][m]&m\le n\\
dp[n][m-1]&n<m\end{cases}$

可以选择在所有箱子里面都放上 $1$ 个球，也可以不选择这个操作。

如果选择了这个操作，那么就从 $dp[n-m][m]$ 转移过来

如果没有选择这个操作，那么就从 $dp[n][m-1]$ 转移过来

```c++
ll f(ll n,ll m)
{
    if(n==1 || m==1 || n==0)
        return 1;
    if(n<m)
        return f(n,n);
    return f(n,m-1)+f(n-m,m);
}
```

## 球同，盒同，无空箱

$dp[n-m][m],m\le n$ ，dp 同第 7 种情况

因为要求无空箱，我们先在每个箱子里面放 $1$ 个球，然后还剩下 $n-m$ 个球了，再根据情况 7 答案就出来了

# min-max 容斥

通过集合最小值计算集合最大值，或者反过来
$$max(S)=\sum\limits_{T\subseteq S}min(T)(-1)^{|T|-1}$$
$|T|$ 表示 $T$ 的元素个数
$$min(S)=\sum\limits_{T\subseteq S}max(T)(-1)^{|T|-1}$$
如果只是计算集合最大最小值，$O(n)$ 即可完成，但是这个结论可以放到期望上

即，max 表示满足所有条件的期望，min 表示满足至少一个条件的期望

# Kthmin-max 容斥

$$Kthmax(S)=\sum\limits_{T\subseteq S}min(T)\dbinom{|T|-1}{k-1}(-1)^{|T|-k}$$

# gcd-lcm 容斥

$$lcm(S)=\sum\limits_{T\subseteq S}gcd(T)(-1)^{|T|-1}$$

# 卡特兰数高精

$C_n=\dbinom{2n}{n}/(n+1)$

将乘除部分按照质因数存储，乘法即答案的相应质因数 +1 ，除法则 −1 ，可以优化掉高精除低精这个过程。

同时，应用高精度压位技巧，即数组中的每一位存储多个数字

```c++
typedef long long ll;
int exponential[1010];
struct big
{
    int len;
    ll x[1000];
    int bit=1e9;
    ll& operator [](int a)
    {return x[a];}
    friend void operator *=(big &a,int b)
    {
        int len=a.len,bit=a.bit;
        for(int i=1;i<=len;i++)a[i]*=b;
        int now=1;
        while(now<=len)
        {
            if(a[now]>=bit)a[now+1]+=a[now]/bit,a[now]%=bit;
            if(now==len&&a[len+1])len++;
            now++;
        }
        a.len=len;
    }
    void print()
    {
        cout<<x[len];
        for(int i=len-1;i>=1;i--)
            cout<<setw(9)<<setfill('0')<<x[i];
    }
}catalennumber;
void add(int x,int v)
{
    for(int i=2;i*i<=x;++i)
    {
        while(x%i==0)
        {
            x/=i;
            exponential[i]+=v;
        }
    }
    if(x!=1)
        exponential[x]+=v;
}
void catalan(int n)
{
    int t=n<<1;
    for(int i=n+2;i<=t;++i)
        add(i,1);
    for(int i=1;i<=n;++i)
        add(i,-1);
    catalennumber[1]=catalennumber.len=1;
    for(int i=1;i<=t;++i)
    {
        while(exponential[i])
        {
            catalennumber*=i;
            --exponential[i];
        }
    }
    catalennumber.print();
}
```

# 群论

## 群

设 $G$ 是一个集合

$*$ 是 $G$ 上的二元运算，如果 $(G,*)$ 满足下面 4 个条件,则称 $(G,*)$ 为一个群。

1. 封闭性：$\forall a,b∈G$ ,有 $a*b∈G$;

2. 结合律：$\forall a,b,c∈G$，有 $(a*b)*c=a*(b*c)$;

3. 单位元：存在 $e∈G$ ,使得 $\forall a∈G$,都有$a*e=e*a=a$;

4. 逆元：$\forall a∈G,\exists x∈G$,使得 $a*x=x*a=e$,这个时候记 $x$ 为 $a^{-1}$，称为 $a$ 的逆元

群元素的个数有限，称为有限群，且其中元素的个数称为阶，记为 $|G|$

---

## 置换

设 $X$ 为一个有限集，对集合的元素进行任意的排序，那么称排序后的结果 $π$ 是 $X$ 上的一个置换。

//有限集是元素个数有限的集合

设 $X=\{1,2,3,4....n\}$

设 $π$ 是 $X$ 的一个置换
其中 $a_1,a_2,...,a_n$ 是 $X$ 的一个排列

可将 $π$ 记为 $\begin{matrix}1&2&......&n\\a_1&a_2&......&   a_n\end{matrix}$

同一置换用这样的表示法有 $n!$ 种，但其对应的关系不变。

设置换 $π$ 的部分元素的对应关系如下

$π$：$\begin{matrix}a_1&a_2&...&a_k\\a_2&a_3&...&a_1\end{matrix}$

称为 $k$ 阶循环，$k$ 为循环长度。

//不一定连续，不一定从 1 开始

每个置换都可以写成若干个互不相交的循环节的乘积，且表示是唯一的.

> 对着例子理解这句话，一定要理解

### 例子

$π$：$\begin{matrix}1&2&3&4&5&6\\2&4&5&1&3&6\end{matrix}$

可以表示为$(124)(35)(6)$,置换的循环节数是 3,记为 C(π)

# Polya 定理

设 $G=\{π_1,π_2,π_3,...,π_k\}$是 $X=\{a_1,a_2,a_3,...,a_n\}$ 上一个置换群，

//置换的集合即为置换群

用 $m$ 种颜色对 $X$ 中的元素进行涂色，那么不同的涂色方案数为：

$\frac{1}{|G|} * \sum\limits_{i=1}^{k} m^{C(π_i)}$

---

## 例题

黑白两种颜色对下面的 2\*2 方格进行染色,

如果允许方格可以绕中心点旋转, 问有多少种不同的着色方案数?

$\begin{matrix}1&2\\3&4\end{matrix}$

---

方格可以旋转 $0°,90°,180°,270°$.

所以群 $G = \{0°,90°,180°,270°\}$ ,$|G| = 4$

$G$ 中 所有的置换是

$π_1 = (1)(2)(3)(4)$

$π_2 = (1234)$

$π_3 = (14)(23)$

$π_4 = (1432)$

$c(π_1) = 4 , c(π_2) = 1  , c(π_3) = 2 , c(π_4) = 1$

带入 Polya 定理

$ans = \frac{1}{4}*(2^4+2^1+2^2+2^1) = 6$

---

## 原理

当只有旋转的时候(顺时针或逆时针)，

对于一个有 $n$ 个元素的环，可顺时针或逆时针旋转几个位置，

由于至少有 $n$ 个置换，

但是假设我顺时针旋转 $k$ 个位置，他就等同于逆时针转动 $n-k$ 个位置，

假设一个置换为:

$G=\{π_0,π_1,π_2,...,π_{n-1}\}$

这个时候可以证明

逆时针旋转 $k$ 个位置时

$π_k$ 的循环节数为 $gcd(n,k)$

且每个循环的长度为 $L=n/gcd(n,k)$

---

上面那个例题只考虑了旋转的情况

## 翻转

- 当 $n$ 为奇数的时候，只有一种形式，

以顶点 $i$ 与中心的连线为轴的翻转

$π_i=\begin{matrix}...&i-1&i&i+1&...\\...&i+1&i&i-1&...\end{matrix}$

有 $n$ 个循环节数为 $(n+1)/2$ 的置换

- 当 n 为偶数时，有两种形式：

1. 以顶点 $i$ 与中心的连线为轴的翻转

$π_i=\begin{matrix}...&i-1&i&i+1&...\\...&i+1&i&i-1&...\end{matrix}$

有 $n/2$ 个循环节数为 $n/2+1$ 的置换

2. 以顶点 $i$ 和 $i+1$ 的中点与中心的连线为轴翻转

$π_i=\begin{matrix}...&i-1&i&i+1&...\\...&i+2&i+1&i&...\end{matrix}$

有 $n/2$ 个循环节数为 $n/2$ 的置换

> 要特别注意 $0$ 的情况，输出 $0$ 即可。

由于旋转有 $n$ 种置换，翻转也有 $n$ 种置换，所以 $|G|=2n$

```c++
typedef long long ll;
ll fast_power(ll base,ll exponent)
{
    ll result=1;
    while(exponent>0)
    {
        if(exponent&1)
            result=result*base;
        base=base*base;
        exponent>>=1;
    }
    return result;
}
ll polya(ll n,ll m)
{
    if(!n)
        return 0;
    ll sum=0;
    for(ll i=0;i<n;++i)
        sum+=fast_power(m,__gcd(n,i));
    if(n&1)
        sum+=n*fast_power(m,(n+1)/2);
    else
        sum+=n/2*(1ll+m)*fast_power(m,n/2);
    sum/=(2*n);
    return sum;
}
```

# 矩阵快速幂

给出底矩阵和指数，快速求出幂矩阵

也就是把对整数的操作移植到矩阵上来

一般会复合一些 dp

## 时间复杂度

$O(t^3*log n)$,$t$ 是矩阵边长，$t^3$ 表示矩阵乘法

## 常见多项式抽象

1. $f(n) = a * f(n-1) + b * f(n-2) +c$

$\begin{pmatrix}a&b&1\\1&0&0\\0&0&1\end{pmatrix}*
\begin{pmatrix}f(n-1)\\f(n-2)\\c\end{pmatrix}=
\begin{pmatrix}f(n)\\f(n-1)\\c\end{pmatrix}$

2. $f(n) = f(n-1) + c^n$

$\begin{pmatrix}1&c\\0&c\end{pmatrix}*
\begin{pmatrix}f(n-1)\\c^{n-1}\end{pmatrix}=
\begin{pmatrix}f(n)\\c^{n}\end{pmatrix}$

3. $f(n)= f(n-1) + n^3$

因为

$n^3$

$= (n - 1 + 1)^3$

$= C(0,3)*(n-1)^3 + C(1,3)*(n-1)^2 + C(2,3)*(n-1)^1 + C(3,3)*(n-1)^0$

所以

$\begin{pmatrix}1&C(0,3)&C(1,3)&C(2,3)&C(3,3)\\
0&C(0,3)&C(1,3)&C(2,3)&C(3,3)\\
0&0&C(0,2)&C(1,2)&C(2,2)\\
0&0&0&C(0,1)&C(1,1)\\
0&0&0&0&C(0,0)\end{pmatrix}*
\begin{pmatrix}f(n-1)\\(n-1)^3\\(n-1)^2\\(n-1)^1\\(n-1)^0\end{pmatrix}=
\begin{pmatrix}f(n)\\n^3\\n^2\\n^1\\n^0\end{pmatrix}$

# 高斯消元

求解线性方程组和异或方程组，求矩阵的逆

用的是高斯约旦消元法，比普通高斯消元法精度更高，代码更简洁

## 时间复杂度

$O(n^3)$

稀疏矩阵可以观察稀疏的地方并优化

## 线性方程组

形式如下
$$\begin{cases}a_{11}x_1+a_{12}x_2+...+a_{1n}x_n=b_1\\ a_{21}x_1+a_{22}x_2+...+a_{2n}x_n=b_2\\...\\a_{n1}x_1+a_{n2}x_2+...+a_{nn}x_n=b_n\end{cases}$$
写成矩阵形式，AX=B
$$A=\begin{vmatrix}a_{11}&a_{12}&...&a_{1n}\\a_{21}&a_{22}&...&a_{2n}\\...\\a_{n1}&a_{n2}&...&a_{nn}\end{vmatrix},X=\begin{vmatrix}x_1\\x_2\\...\\x_n\end{vmatrix},B=\begin{vmatrix}b_1\\b_2\\...\\b_n\end{vmatrix}$$

程序求解就是增广矩阵行初等行变换为行最简形：
$$\begin{vmatrix}a_{11}&a_{12}&...&a_{1n}&b_1\\a_{21}&a_{22}&...&a_{2n}&b_2\\...\\a_{n1}&a_{n2}&...&a_{nn}&b_n\end{vmatrix}\rightarrow\begin{vmatrix}1&0&...&0&c_1\\0&1&...&0&c_2\\...\\0&0&...&1&c_n\end{vmatrix}$$
这样 $X$ 就等于
$$\begin{vmatrix}c_1\\c_2\\...\\c_n\end{vmatrix}$$

## 矩阵求逆

对 $n$ 阶矩阵 $A$，构造 $n\times 2n$ 的矩阵 $(A,I_n)$

高斯消元化成 $(I_n,A^{-1})$

如果左半部分不能化成单位矩阵，则矩阵 $A$ 不可逆

## 异或方程组

异或运算满足交换律和结合律，所以可以使用类似高斯消元的方法解决方程组

形式如下,且所有系数（即 a 和 b）均为 0 或 1
$$\begin{cases}a_{11}x_1\oplus a_{12}x_2\oplus ...\oplus a_{1n}x_n=b_1\\ a_{21}x_1\oplus a_{22}x_2\oplus ...\oplus a_{2n}x_n=b_2\\...\\a_{n1}x_1\oplus a_{n2}x_2\oplus ...\oplus a_{nn}x_n=b_n\end{cases}$$
应使用“异或消元”而非“加减消元”，且不需要进行乘除改变系数（因为系数均为 0 和 1）。

注意到异或方程组的增广矩阵是 01 矩阵，可以用 bitset 优化

# 行列式

矩阵应用高斯消元，得到一个对角线矩阵，此矩阵的行列式由对角线元素之积所决定。其符号可由交换行的数量来确定（如果为奇数，则行列式的符号应颠倒）

# 矩阵快速幂

注意稠密矩阵和稀疏矩阵的乘法处理要不一样

```c++
const int N = 4;
struct matrix
{
    ll m[N][N];
    void init()//单位矩阵
    {
        memset(m,0,sizeof(m));
        for(int i=0;i<N;++i)
            m[i][i]=1;
    }
    matrix operator*(matrix y)
    {
        matrix c;
        memset(c.m,0,sizeof(c.m));
        //稠密矩阵
        for(int i=0;i<N;++i)
        {
            for(int j=0;j<N;++j)
            {
                for(int k=0;k<N;++k)
                    c.m[i][j] = (c.m[i][j] + m[i][k] * y.m[k][j] % mod) % mod;
            }
        }
        //稀疏矩阵(指矩阵中很多数为0)
        for(int i=0;i<N;++i)
        {
            for(int j=0;j<N;++j)
            {
                if(!m[i][j])
                    continue;
                for(int k=0;k<N;++k)
                    c.m[i][k] = (c.m[i][k] + m[i][j] * y.m[j][k] % mod) % mod;
            }
        }
        return c;
    }
    matrix operator^(ll exponent)
    {
        matrix result;
        result.init();
        for(;exponent;exponent>>=1)
        {
            if(exponent&1)
                result = result*(*this);
            (*this) = (*this)*(*this);
        }
        return result;
    }
};
matrix base{1,1,1,2,
            0,1,1,2,
            0,1,0,0,
            0,1,0,1};
base=base^(n-2);
ll ans=(((base.m[0][0]*2%mod+base.m[0][1])%mod+base.m[0][2])%mod+base.m[0][3])%mod;
```

# 高斯消元

注意处理无解，无穷解情况

-1 无解，0 无穷解，1 唯一解

# 线性方程组

```c++
const int N=1e2+1;
const double eps=1e-6;
double a[N][N],ans[N];
int GaussianElimination(int n)
{
    int i,maxx,j,k,cnt=0;
    double temp;
    for(i=0;i<n;++i)
    {
        maxx=cnt;
        for(j=cnt+1;j<n;++j)
        {
            if(fabs(a[j][i])>fabs(a[maxx][i]))
                maxx=j;
        }
        if(fabs(a[maxx][i])<eps)
            continue;
        if(maxx!=cnt)
            swap(a[maxx],a[cnt]);
        for(j=0;j<n;++j)
        {
            if(j==cnt)
                continue;
            temp=a[j][i]/a[cnt][i];
            for(k=i+1;k<=n;++k)
                a[j][k]-=a[cnt][k]*temp;
        }
        ++cnt;
    }
    if(cnt<n)
    {
        for(;cnt<n;++cnt)
        {
            if(fabs(a[cnt][n])>eps)
                return -1;
        }
        return 0;
    }
    for(i=0;i<n;++i)
        ans[i]=a[i][n]/a[i][i];
    return 1;
}
```

# 异或方程组

```c++
const int N=1e2+3;
bitset<N> a[N];
bitset<N> ans;
int GaussElimination(int n, int m)
{
    int i,j,cnt=0;
    for(i=0;i<n;++i)
    {
        for(j=cnt;j<m && !a[j][i];++j){}
        if(j==m)
            continue;
        if(j != cnt)
            swap(a[j], a[cnt]);
        for(j=0;j<m;j++)
        {
            if(cnt==j)
                continue;
            if(a[j][i])
                a[j]^=a[cnt];
        }
        ++cnt;
    }
    if(cnt<n)
    {
        for(;cnt<n;++cnt)
        {
            if(a[cnt][n])
                return -1;
        }
        return 0;
    }
    for (i = 0; i < n; i++)
        ans[i] = a[i][n];
    return 1;
}
```

# 行列式

```c++
const int N=1e2+1;
const double eps=1e-6;
double a[N][N];
double GaussianElimination(int n)
{
    int i,maxx,j,k;
    double temp,res=1;
    for(i=0;i<n;++i)
    {
        maxx=i;
        for(j=i+1;j<n;++j)
        {
            if(fabs(a[j][i])>fabs(a[maxx][i]))
                maxx=j;
        }
        if(fabs(a[maxx][i])<eps)
            return 0.0;
        if(maxx!=i)
        {
            swap(a[maxx],a[i]);
            res=-res;
        }
        res*=a[i][i];
        for(j=0;j<n;++j)
        {
            if(j==i)
                continue;
            temp=a[j][i]/a[i][i];
            if(fabs(temp)<eps)
                continue;
            for(k=i;k<=n;++k)
                a[j][k]-=a[i][k]*temp;
        }
    }
    return res;
}
```

# 数论导读

## 因子个数

$\prod\limits_{i=1}^s (1+k_i)$

## 因子和

$\prod\limits_{i=1}^s \frac{p_i^{k_i+1}-1}{p_i-1}
$

## $gcd$性质

$gcd(a,b)=gcd(a-b,b)$

$gcd(a,b)=gcd(a,a-b)$

$gcd(a,b)=gcd(b,a\%b)$

## 欧拉函数

$\sum\limits_{i=1}^{n} i*(gcd(i,n)==1)=n*φ(n)/2$

特例：$n=1,result=1$

> 一个常识：$d\mid i,d\mid j⇔d\mid gcd(i,j)$

# 米勒-拉宾素性检验

## 时间复杂度

$O(klog n)$

但因为我们使用了固定的一组数，所以 $k=7$

```c++
typedef unsigned long long ll;
ll qpow(ll a, ll n, ll p)
{
    ll ans = 1;
    while (n)
    {
        if (n & 1)
            ans = (__int128)ans * a % p; // 注意！中间结果可能溢出，需要使用__int128过渡
        a = (__int128)a * a % p;
        n >>= 1;
    }
    return ans;
}
bool Miller_Rabin(ll x)
{
    if (x < 3)
        return x == 2;
    if (x % 2 == 0)
        return false;
    ll A[] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022}, d = x - 1, r = 0;
    while (d % 2 == 0)
        d /= 2, ++r;
    for (auto a : A)
    {
        ll v = qpow(a, d, x);
        if (v <= 1 || v == x - 1)
            continue;
        for (int i = 0; i < r; ++i)
        {
            v = (__int128)v * v % x; // 同样使用__int128过渡
            if (v == x - 1 && i != r - 1)
            {
                v = 1;
                break;
            }
            if (v == 1)
                return false;
        }
        if (v != 1)
            return false;
    }
    return true;
}
```

# 逆元

1. exgcd（单个数）

```c++
long long exgcd(long long a,long long b,long long &x,long long &y)
{
	if(!b)
	{
		x=1;
		y=0;
		return a;
	}
	long long r=exgcd(b,a%b,y,x);
	y-=x*(a/b);
	return r;
}
long long inv(long long a,long long n)
{
    long long x,y;
    if(exgcd(a,n,x,y)==1ll)
        return (x%n+n)%n;
    else
        return -1;
}
```

2. 顺序打表

```c++
const int N = 1e6 + 5;
long long inv[N];
void getinv()
{
    inv[1] = 1;
    for(ll i=2; i<N; ++i)
        inv[i] =  (mod - mod / i) * inv[mod%i] % mod;
}
```

3. 任意 $n$ 个数

```cpp
//a下标从1开始
const int N=1e5+3;
long long preprod[N],inv[N];
long long exgcd(long long a,long long b,long long &x,long long &y)
{
	if(!b)
	{
		x=1;
		y=0;
		return a;
	}
	long long r=exgcd(b,a%b,y,x);
	y-=x*(a/b);
	return r;
}
long long getinv(long long a,long long n)
{
    long long x,y;
    if(exgcd(a,n,x,y)==1ll)
        return (x%n+n)%n;
    else
        return -1;
}
void getINV(int n)
{
    preprod[0]=1;
    for(int i=1;i<=n;++i)
        preprod[i]=preprod[i-1]*a[i]%mod;
    long long sis=getinv(preprod[n],mod);
    for(int i=n;i>=1;--i)
    {
        inv[i]=sis*preprod[i-1]%mod;
        sis=sis*a[i]%mod;
    }
}
```

# 线性筛

## 欧拉函数 φ

```c++
const int N=1e7+3;
bitset<N> v;
int p[N>>2],phi[N];
void seive()
{
	int cnt=0;
    phi[1]=1;
    for(int i=2;i<N;++i)
    {
        if(!v[i])
        {
            p[cnt++]=i;
            phi[i]=i-1;
        }
        for(int j=0;j < cnt && p[j]*i < N;++j)
        {
            v[i*p[j]]=1;
            if(i%p[j]==0)
            {
                phi[i*p[j]]=phi[i]*p[j];
                break;
            }
			phi[i*p[j]]=phi[i]*(p[j]-1);
        }
    }
}
```

## 莫比乌斯函数 μ

```c++
const int N=1e7+3;
bitset<N> v;
int p[N>>2],mu[N];
void seive()
{
	int cnt=0;
	mu[1]=1;
	for(int i=2;i<N;++i)
	{
		if(!v[i])
		{
			p[cnt++]=i;
			mu[i]=-1;
		}
		for(int j=0;j < cnt && i*p[j] < N;++j)
		{
			v[i*p[j]]=1;
			if(!(i%p[j]))
				break;
			mu[i*p[j]]=-mu[i];
		}
	}
}
```

## 约数个数

```c++
//dn约数个数
const int N=1e7+3;
bitset<N> v;
int p[N>>2],dn[N],mpdn[N];
void seive()
{
	int cnt=0;
	for(int i=2;i<N;++i)
    {
        if(!v[i])
		{
			p[cnt++]=i;
			dn[i]=2;
			mpdn[i]=1;
		}
        for(int j=0;j < cnt && i*p[j] < N;++j)
        {
            v[i*p[j]]=1;
            if(i%p[j]==0)
            {
				mpdn[i*p[j]] = mpdn[i]+1;
                dn[i*p[j]]=dn[i]/(mpdn[i]+1)*(mpdn[i]+2);
                break;
            }
			dn[i*p[j]]=dn[i]*dn[p[j]];
			mpdn[i*p[j]]=1;
        }
    }
}
```

## 约数和

```c++
//sd约数和
const int N=1e7+3;
bitset<N> v;
int p[N>>2],sd[N],smpd[N];
void seive()
{
	int cnt=0;
    sd[1]=1;
    for(int i=2;i<N;++i)
    {
        if(!v[i])
		{
			p[cnt++]=i;
			sd[i]=i+1;
			smpd[i]=i+1;
		}
        for(int j=0;j<cnt && i*p[j]<N;++j)
        {
            v[i*p[j]]=1;
            if(i%p[j]==0)
            {
				smpd[i*p[j]]=smpd[i]*p[j]+1;
                sd[i*p[j]]=sd[i]/smpd[i]*smpd[i*p[j]];
                break;
            }
			sd[i*p[j]]=sd[i]*sd[p[j]];
			smpd[i*p[j]]=p[j]+1;
        }
    }
}
```

# 拓展欧拉定理

如果$gcd(a,n)\ne1$，且$b>φ(n)$时  
$a ^ b ≡ a ^ {b \% φ(n) + φ(n) } \pmod n$

# 狄利克雷卷积

## 常用数论函数

单位函数 $ε(n)=\begin{cases}1&n=1\\0&otherwise\end{cases}$

---

幂函数 $Id_k(n)=n^k$.  
k=1 时为恒等函数 $Id(n)$  
k=0 时为常数函数 $1(n)$

---

除数函数 $σ_k(n)=\sum\limits_{d\mid n} d^k$  
k=1 时为因数和函数 $σ(n)$  
k=0 时为因数个数函数 $σ_0(n)$  
$σ_0(n)$ 的一个性质：
$$σ_0(ij)=\sum_{x|i} \sum_{y|j} ε(gcd(x,y))$$
$$=\sum\limits_{d\mid \gcd(i,j)}μ(d)σ_0(i/d)σ_0(j/d)$$

---

欧拉函数 $φ(n)$

---

这些函数都是积性函数，前二者还是完全积性函数

## 常用数论函数联系

除数函数与幂函数  
 $Id_k*1=σ_k$  
欧拉函数与恒等函数  
 $φ*1=Id$  
注意：$1$此时是常数函数

## 狄利克雷卷积性质

1. 函数间交换律，即 $f*g=g*f$
2. 函数间结合律，即 $(f*g)*h=f*(g*h)$
3. 函数间卷积分配律，即  
   $(f*(g+h))(n)=(f*g)(n)+(f*h)(n)$
4. 若$f$,$g$是积性函数，则$f*g$也是积性函数
5. 函数常数间结合律，即 $(xf)*g=x(f*g)$
6. 单位元是单位函数$ε$
7. 狄利克雷逆存在必要条件是$f(1)\ne 0$，，没有在网上找到充分条件
8. 积性函数必然存在狄利克雷逆，且狄利克雷逆仍是积性函数。

## 狄利克雷逆求法

因为 $f*g=ε$，所以

$g(n)=\frac 1{f(1)}(ε(n)-\sum\limits_{i\mid n,i\ne 1} f(i)g(\frac ni))$

# 莫比乌斯反演

## 莫比乌斯函数

常数函数 $1$ 的狄利克雷逆，称之为莫比乌斯函数 $μ$

## 莫比乌斯反演公式

因数形式：  
$g(n)=\sum\limits_{d\mid n} f(d) ⇔ f(n)=\sum\limits_{d\mid n} μ(d)\times g(n/d)$  
狄利克雷卷积形式：  
$g=f*1 ⇔ f=g*u$  
倍数形式：  
$g(n)=\sum\limits_{n\mid N} f(N) ⇔ f(n)=\sum\limits_{n\mid N} g(N)\times μ(N/n)$

# 重要结论

给定一个函数 $f$，$g$ 满足 $f=1*g$

$\sum\limits_{i=1}^n\sum\limits_{j=1}^m f(gcd(i,j))=\sum\limits_{d=1}^{min(n,m)} g(d)\lfloor\frac nd\rfloor\lfloor\frac md\rfloor$

## 解题步骤

1. 将 $f$ 替换成题目所给具体函数
2. 预处理 $g$，$g=\mu*f$
3. 数论分块计算

## 卷积证明

枚举 gcd

$\sum\limits_{d=1}^{min(n,m)} f(d) \sum\limits_{i=1}^n\sum\limits_{j=1}^m [gcd(i,j)=d]$

枚举 d 的倍数

$\sum\limits_{d=1}^{min(n,m)} f(d) \sum\limits_{i=1}^{\lfloor\frac nd\rfloor}\sum\limits_{j=1}^{\lfloor\frac md\rfloor} [gcd(i,j)=1]$

$\mu * 1=\epsilon$

$\sum\limits_{d=1}^{min(n,m)} f(d) \sum\limits_{i=1}^{\lfloor\frac nd\rfloor}\sum\limits_{j=1}^{\lfloor\frac md\rfloor} \sum\limits_{t\mid gcd(i,j)}\mu(t)$

枚举 t

$\sum\limits_{d=1}^{min(n,m)} f(d) \sum\limits_{t=1}^{min(\lfloor\frac nd\rfloor,\lfloor\frac md\rfloor)} \mu(t)\sum\limits_{i=1}^{\lfloor\frac nd\rfloor}\sum\limits_{j=1}^{\lfloor\frac md\rfloor} [t\mid gcd(i,j)]$

枚举 t 的倍数

$\sum\limits_{d=1}^{min(n,m)} f(d) \sum\limits_{t=1}^{min(\lfloor\frac nd\rfloor,\lfloor\frac md\rfloor)} \mu(t)\sum\limits_{i=1}^{\lfloor\frac n{dt}\rfloor}\sum\limits_{j=1}^{\lfloor\frac m{dt}\rfloor} 1$

$\sum\limits_{d=1}^{min(n,m)} f(d) \sum\limits_{t=1}^{min(\lfloor\frac nd\rfloor,\lfloor\frac md\rfloor)} \mu(t)\lfloor\frac n{dt}\rfloor\lfloor\frac m{dt}\rfloor$

设 $T=dt$

$\sum\limits_{T=1}^{min(n,m)} \lfloor\frac nT\rfloor\lfloor\frac mT\rfloor \sum\limits_{d\mid T} f(d)\mu(T/d)$

发现 $\sum\limits_{d\mid T} f(d)\mu(T/d)$ 可以表示为 $g(T)=f*\mu$

$\sum\limits_{T=1}^{min(n,m)} g(T)\lfloor\frac nT\rfloor\lfloor\frac mT\rfloor$

## 莫反证明

$f=1*g$

$\sum\limits_{i=1}^n\sum\limits_{j=1}^m \sum\limits_{d\mid gcd(i,j)} g(d)$

枚举 $d$

$\sum\limits_{d=1}^{\min(n,m)} g(d) \sum\limits_{i=1}^n\sum\limits_{j=1}^m [d\mid gcd(i,j)]$

枚举 $d$ 的倍数

$\sum\limits_{d=1}^{min(n,m)} g(d)\lfloor\frac nd\rfloor\lfloor\frac md\rfloor$

## 预处理

若 $f$ 是积性函数，则可以线性筛预处理(卷积性质 4)，否则至少 $O(n\log\log n)$

```c++
void get_g_1(int N, const int *f, int *g)
{
    for (int i = 1; i <= N; i++)
        g[i] = 0;
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; i * j <= N; j++)
            g[i * j] = (g[i * j] + mu[i] * f[j]) % mod;
    }
} // 依照卷积定义，O(nlogn)

void get_g_2(int N, const int *f, int *g)
{
    for (int i = 1; i <= N; i++)
        g[i] = f[i];
    for (int i = 1; i <= N; i++)
    {
        for (int j = 2; i * j <= N; j++)
            g[i * j] = (g[i * j] - g[i]) % mod;
    }
} // 类似求狄利克雷卷积逆的方式，不需要线性筛 mu ，O(nlogn)

void get_g_3(int N, const int *f, int *g)
{
    for (int i = 1; i <= N; i++)
        g[i] = f[i];
    for (int i = 0; i < prime_count; i++)
    {
        for (int j = N / prime[i]; j >= 1; j--)
            g[j * prime[i]] = (g[j * prime[i]] - g[j]) % mod;
    }
} // Magic! O(nloglogn)
```

最后一种可以理解成 DP:
$$g_{i,n}=\sum\limits_{d\mid n,d只含前i种质因子} \mu(d)f(n/d)$$
具体转移就是
$$g_{i,n}=\begin{cases}g_{i-1,n}&p_i\nmid n\\ g_{i-1,n}-g_{i-1,n/p_i}&p_i\mid n\end{cases}$$

大部分题目第二种就够用，不排除 currywoe 没遇到毒瘤题（bushi

## 例题

$\sum\limits_{i=1}^n \sum\limits_{j=1}^m [gcd(i,j)=1]$

显然 $f=ε$，那么 $g=\mu$

---

$\sum\limits_{i=1}^n \sum\limits_{j=1}^m [gcd(i,j)=k]$

显然 $f(x)=[x=k]$，稍微推一下式子，则 $g=\mu$

---

稍难：求 $\sum\limits_{p∈prime}\sum\limits_{i=1}^n \sum\limits_{j=1}^m [gcd(i,j)=p]$

显然 $f(x)=[x∈prime]$,那么 $g=\sum\limits_{d\mid x} \mu(x/d)[d∈prime]$

换种写法就是 $g(x)=\sum\limits_{p∈prime,p\mid x} μ(x/p)$

此题特殊之处，可以线性筛处理出 $g$

$g(x=i*p)=\begin{cases}1&i=1\\μ(i)&i\mod p=0\\μ(i)-g(i)&i\mod p\neq 0\end{cases}$

---

$\sum\limits_{i=1}^n \sum\limits_{j=1}^m gcd(i,j)$

显然 $f=id$，则 $g=φ$

---

变形：求 $\sum\limits_{i=1}^n \sum\limits_{j=1}^m ij\times gcd(i,j)$

卷积处理，留作思考

参考答案 $=\sum\limits_{d=1}^{\min(n,m)} φ(d)*d^2*g(\lfloor\frac nd\rfloor)*g(\lfloor\frac md\rfloor)$

$g(x)=(1+x)*x/2$

---

变形：$\sum\limits_{i=1}^n \sum\limits_{j=1}^m lcm(i,j)$

卷积处理，留作思考，很好的练习题

参考答案 $=\sum\limits_{d=1}^{min(n,m)} d*sum(\lfloor\frac nd\rfloor,\lfloor\frac md\rfloor)$

$sum(n,m)=\sum\limits_{d=1}^{min(n,m)} μ(d)*d^2*g(\lfloor\frac nd\rfloor,\lfloor\frac md\rfloor)$

$g(n,m)=[(n+1)n/2]*[(m+1)*m/2]$

---

求 $\sum\limits_{i=1}^n \sum\limits_{j=1}^m σ_0(ij)$

先自行尝试把常用数论函数里给出的性质化成下面那个式子

再带回本题

原式 $=\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{p \mid \gcd(i,j)}\mu(p)σ_0\left(\frac{i}{p}\right)σ_0\left(\frac{j}{p}\right)$

枚举 $p$

$=\sum\limits_{p=1}^{min(n,m)} \sum\limits_{i=1}^n\sum\limits_{j=1}^m [p \mid \gcd(i,j)]\cdot\mu(p)σ_0\left(\frac{i}{p}\right)σ_0\left(\frac{j}{p}\right)$

$i,j$ 枚举 $p$ 的倍数

$=\sum\limits_{p=1}^{min(n,m)} \sum\limits_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac{m}{p}\right\rfloor} \mu(p)σ_0(i)σ_0(j)$

$μ(p)$ 和 $i,j$ 无关，提到前面去，$σ_0(i)$ 同理

$=\sum\limits_{p=1}^{min(n,m)}\mu(p) \sum\limits_{i=1}^{\left\lfloor\frac{n}{p}\right\rfloor}σ_0(i) \sum\limits_{j=1}^{\left\lfloor\frac{m}{p}\right\rfloor}σ_0(j)$

简化形式

$=\sum\limits_{p=1}^{min(n,m)}\mu(p)*S\left(\left\lfloor\frac{n}{p}\right\rfloor\right)*S\left(\left\lfloor\frac{m}{p}\right\rfloor\right)$

$S(n)=\sum\limits_{i=1}^{n} σ_0(i)$

# 杜教筛

求数论函数前缀和

## 复杂度

$O(n^{\frac 23})$

## 原理

设数论函数 $f$，其前缀和 $S(n)=\sum\limits_{i=1}^n f(i)$，另一数论函数 $g$

$\sum\limits_{i=1}^nf*g(i)=\sum\limits_{i=1}^n\sum\limits_{d|i}f(i)g(\frac id)$

$=\sum\limits_{i=1}^n\sum\limits_{j=1}^{\lfloor\frac ni\rfloor}f(j)g(i)$

$=\sum\limits_{i=1}^ng(i)\sum\limits_{j=1}^{\lfloor\frac ni\rfloor}f(j)$

$=\sum\limits_{i=1}^ng(i)S(\lfloor\frac ni\rfloor)$

$g(1)S(n)=\sum\limits_{i=1}^nf*g(i)-\sum\limits_{i=2}^ng(i)S(\lfloor\frac ni\rfloor)$

假如可以快速求 $\sum\limits_{i=1}^nf*g(i)$，数论分块求 $\sum\limits_{i=2}^ng(i)S(\lfloor\frac ni\rfloor)$，则 $S(n)$ 可求

线性筛预处理前 $n^{\frac 23}$，记忆化中间结果(map 和 um，洛谷数据测试二者差别不大)

## 莫比乌斯函数前缀和

$f=\mu$，$g=1$，$f*g=\epsilon$

$S(n)=1-\sum\limits_{i=2}^nS(\lfloor\frac ni\rfloor)$

```cpp
const int N=1e8+3;
const int M=6e6;
bitset<N> v;
int p[M];
int mu[N],summu[N];
map<ll,ll> mpmu;
void seive()
{
	int cnt=0;
	mu[1]=1;
	for(int i=2;i<N;++i)
	{
		if(!v[i])
		{
			p[cnt++]=i;
			mu[i]=-1;
		}
		for(int j=0;j < cnt && i*p[j] < N;++j)
		{
			v[i*p[j]]=1;
			if(!(i%p[j]))
				break;
			mu[i*p[j]]=-mu[i];
		}
	}
    for(int i=1;i<N;++i)
        summu[i]=summu[i-1]+mu[i];
}
long long Smu(long long x)
{
    if (x < N)
        return summu[x];
    if (mpmu.count(x))
        return mpmu[x];
    long long res = 1;
    for (long long l = 2, r; l <= x; l = r + 1)
    {
        r = x / (x / l);
        res -= Smu(x / l) * (r - l + 1);
    }
    return (mpmu[x] = res);
}
```

## 欧拉函数前缀和

莫反求：(速度更快，另一个了解就好)

$\sum\limits_{i=1}^n\phi(i)=\sum\limits_{i=1}^n\mu(i)\lfloor\frac nd\rfloor^2$

```cpp
long long Sphi(long long x)
{
    long long res =0;
    for (long long l = 1,r; l <= x; l = r + 1)
    {
        r = x / (x / l);
        res += (Smu(r) - Smu(l - 1)) * (x / l) * (x / l);
    }
    return (res + 1) / 2;
}
```

杜教筛求：

$f=\phi$，$g=1$，$f*g=ID$

$S(n)=\frac{n(n+1)}2-\sum\limits_{i=2}^nS(\lfloor\frac ni\rfloor)$

# 原根

# 阶

## 定义

若 $p>1$，$gcd(a,p)=1$，则必有一个 $x$ 满足

$a^x\equiv 1 \pmod p$,

且 $x$ 为最小正整数解,

则 $x$ 为 $a$ 模 $p$ 的阶,记作 $\delta_p(a)$

## 性质

1. $a,a^2,...,a^{\delta_p(a)}$ 模 $p$ 两两不同余

2. 若 $a^n\equiv 1 \pmod p$，则$\delta_p(a) \mid n$

3. 若 $a^r \equiv a^t \pmod p$，则 $r\equiv t \pmod {\delta_p(a)}$

4. 若 $\gcd(a,p)=\gcd(b,p)=1$，则 $\delta_p(ab)=\delta_p(a)\delta_p(b)$

的充分必要条件是 $\gcd\big(\delta_p(a),\delta_p(b)\big)=1$

5. 若 $\gcd(a,p)=1$，则$\delta_p(a^k)=\dfrac{\delta_p(a)}{\gcd\big(\delta_p(a),k\big)}$

# 原根

## 定义

$\delta_p(a)=φ(p)$

则 $a$ 为模 $p$ 的原根(Primitive Root)

## 原根存在定理

$p$ 能表示为下列形式之一：

$2,4,k^n,2*k^n$，其中 $k$ 为奇素数。

## 原根判定定理

若 $p>2$，$gcd(a,p)=1$或者$a^{φ(p)}\equiv 1 \pmod p$

前者用\_\_gcd 判断，后者用取模快速幂判断，根据 luogu p6091，二者效率差别不大

则 $a$ 是模 $p$ 的原根的充要条件是，对于 $φ(p)$ 的每个素因数 $j$，都有 $a^{\frac{φ(p)}{j}}\not\equiv 1\pmod p$。

## 数量

$φ(φ(p))$

最多是 $p/2$

## 常见数的最小原根

2——1,4——3,998244353——3,1e9+7——5

## 求 p 的所有原根的步骤

1. 线性筛处理

不大于 $p$ 的素数，不大于 $p$ 的正整数的欧拉函数值，不大于 $p$ 的有原根的模数

1. 判断 $p$ 是否有原根

2. 求最小原根

用已经筛出的素数求 $φ(p)$ 的质因数,并顺便标记和 $φ(p)$ 互素的数

枚举 $i$ （从 1 开始）,满足 $gcd(i,n)=1$,

对于 $φ(p)$ 的每个质因数 $j$

如果 $i^{φ(p)/j}\equiv 1 \pmod p$

说明 $i$ 不是原根

继续循环，直到找到合适的 $i$ 为止

有人证明过，最多 $n^{1/4}$ 次就能找到最小原根

4. 求所有原根

枚举 $φ(p)$ 以内的正整数 $s$

如果 $s$ 与 $φ(p)$ 互质，则 $a^s$ 是一个原根

### 时间复杂度

$O(nlogloglogn)$

### 优化

如果要求顺序输出原根，基数排序比快速排序更快

```c++
typedef long long ll;
const int N=1e6+7;
int p[N],phi[N],factor[15];
bool v[N],pr[N],coprime[N],proot[N];
void init(int n)//筛素数，欧拉函数，有原根的数
{
	pr[2]=pr[4]=phi[1]=1;
	int cnt=0;
	for(int i=2;i<=n;++i)
    {
		if(!v[i])
        {
            p[cnt++]=i;
            phi[i]=i-1;
        }
		for(int j=0;j<cnt && p[j]*i<=n;++j)
        {
			v[p[j]*i]=1;
			if(!(i%p[j]))
            {
				phi[i*p[j]]=phi[i]*p[j];
				break;
			}
			phi[i*p[j]]=phi[i]*phi[p[j]];
		}
	}
	for(int i=1;i<cnt;++i)
    {
        for(ll j=p[i];j<=n;j*=p[i])
            pr[j]=1;
        for(ll j=2*p[i];j<=n;j*=p[i])
            pr[j]=1;
	}
}
long long fast_power(long long base,long long exponent,ll mod)
{
    long long result=1;
    for(;exponent>0;exponent>>=1)
    {
        if(exponent&1)
            result=result*base%mod;
        base=base*base%mod;
    }
    return result;
}
vector<int> PrimitiveRoot(int n)
{
    vector<int> vec;
    if(!pr[n])//模数n没有原根
        return vec;
    if(n==2 || n==4)
    {
        vec.push_back(n-1);
        return vec;
    }
    int temp=phi[n];
    int cnt=0;
    for(int i=0;p[i]*p[i]<=temp;++i)//求φ(n)的质因子，用埃氏筛的思想筛出与φ(n)互质的数(即coprime[i]=0)
    {
        if(!(temp%p[i]))
        {
            factor[cnt++]=p[i];
            while(!(temp%p[i]))
                temp/=p[i];
            for(int j=p[i];j<phi[n];j+=p[i])
                coprime[j]=1;
        }
    }
    if(temp>1)//处理大于根号φ(n)的质因子
    {
        factor[cnt++]=temp;
        for(int i=temp;i<phi[n];i+=temp)
            coprime[i]=1;
    }
    int minPr=1;
    for(;;++minPr)//求最小原根
    {
        for(;__gcd(minPr,n)!=1;++minPr);
        int j=0;
        for(;j<cnt && fast_power(minPr,phi[n]/factor[j],n)!=1;++j);
        if(j>=cnt)
            break;
    }
    temp=minPr;
    for(int i=1;i<phi[n];++i,temp=temp*minPr%n)//求所有原根
    {
        if(!coprime[i])
            proot[temp]=1;
        else
            coprime[i]=0;//清零
    }
    for(int i=1;i<n;++i)//排序原根
    {
        if(proot[i])
        {
            proot[i]=0;//清零
            vec.push_back(i);
        }
    }
    return vec;
}
```

## 原根应用

1. 乘法转化为加法

若 $p$ 有原根，

根据阶的性质 1 和原根的定义，

若 $g$ 是 $p$ 的原根，$1 \le k \le φ(p)$

$g^k \pmod p$ 能生成$[1, p-1]$ 中 $φ(p)$ 个数

换句话说就是

$g^1,g^2...g^{φ(p)} \pmod p$与 $[1,p-1]$ 中的数形成了单射

当 $p$ 是素数时，就形成了双射

> 把 x 比作萝卜，y 比作坑：  
> 单射就是一个萝卜一个坑，有的坑有可能没萝卜；  
> 满射就是所有坑都有萝卜，有的坑可能有不止一个萝卜；  
> 双射就是严格的一个萝卜一个坑，一个坑一个萝卜，所有萝卜都有坑，所有坑都有萝卜。

若 $p$ 是素数，$1 \le a,b$

则 $a*b=g^{Ind_ga+Ind_gb} \pmod p$

Ind 是离散对数，在 bsgs&exbsgs 里会介绍

因此求出 $p$ 的原根 $g$，然后我们就可以把原序列 $a[i]$ 变成 $g^{b[i]}$ ，从而我们就把乘法变成了加法，即

$a[i]*a[j]=a[k] \pmod p$ 变成

$b[i]+b[j]=b[k] \pmod {p-1}$

要特判 0,因为原根不会生成 0

# 离散对数

### 定义

当模 $m$ 有原根时，设 $l$ 为模 $m$ 的一个原根，则当 $x\equiv l^k \pmod m$ 时，$Ind_lx\equiv k \pmod {φ(m)}$

这里的 $Ind_lx$ 为 $x$ 以 $l$ 为底，模 $φ(m)$ 时的离散对数值

$1 \le k \le φ(m)$

### 性质

离散对数和普通对数有类似的性质

$Ind_lxy\equiv Ind_lx+Ind_ly \pmod {φ(m)}$

$Ind_lx^y\equiv yInd_lx \pmod {φ(m)}$

通过这些性质，可以将乘法操作变成加法操作，来简化或者解决一些运算问题.

# BSGS

求离散对数

### 前提条件

$gcd(base,mod)=1$

### 原理

由欧拉定理推论

$a^b=a^{b\%φ(n)} \pmod n$

得知 $a^b$ 在模 $n$ 下有长度为 $φ(n)$ 的循环节

所以最多枚举 $φ(n)$ 次 $a^b$ 就可以求出离散对数

但是如果 $n$ 是质数，那暴力枚举时间复杂度就是 $O(n)$

bsgs 时间复杂度更优

$y^x \equiv z \pmod p$

给定 $y$ , $z$ , $p$ , 求 $x$ 最小正整数解

设$x=am-b$，$m=\left\lceil \sqrt p\right\rceil$，$a\in[1,m],b\in[1,m]$

> $\left\lceil x\right\rceil$是向上取整

$a$,$b$的值域保证$x$取遍$[0,p]$

原式变为

$y^{am} ≡ z*y^b  \pmod p$

如果发现这个式子成立，说明有解

### 时间复杂度

$O(\sqrt {mod})$

### 算法流程

右边的$b$枚举$[1,m]$，算出$z∗y^b \pmod p$，哈希存起来

PS：map 也可以过一些题，但是如果卡常就不行，所以最好用哈希表

左边$a$枚举$[1,m]$，算出$(y^m)^a \pmod p$查表就行了

如果$p\mid base^m$，那么 remain 只能是 0，否则无解

### 代码

```c++
long long bsgs(long long base,long long remain,long long p)
{
	base%=p;
	remain%=p;
	ll t=ceil(sqrt(1.0*p));
	for(ll i=1;i<=t;++i)
    {
        remain=remain*base%p;
        insert(i,remain);
    }
	base=fast_power(base,t,p);
	if(!base)
        return !remain ? 1 : -1;
    remain=1;
    int flag;
	for(ll i=1;i<=t;++i)
    {
		remain=remain*base%p;
        flag=find(remain);
        if(flag!=-1)
            return i*t-flag;
	}
	return -1;
}
```

# exbsgs

解决$gcd(base,modulus)\ne 1$的情况

### 原理

$y^x \equiv z \pmod p$

设$g=gcd(y,p)$

发现此时的$z$必须要是$g$的倍数，否则无解。

因此，除掉 g

<font size=4>$\frac{y}{g} * y^{x-1} \equiv \frac{z}{g} \pmod {\frac{p}{g}}$</font>

不断检查$gcd(p,y)$，一直除到互质为止

此时的形式就变成了

<font size=6>$\frac{y^k}{\prod\limits_{i=1}^k g_i} *y^{x-k} = \frac{z}{\prod\limits_{i=1}^k g_i} \pmod {\frac{p}{\prod\limits_{i=1}^k g_i}}$</font>

互质之后就可以套用 bsgs 了

```c++
ll EXbsgs(ll base,ll remain,ll mod)
{
    base%=mod;
    remain%=mod;
	if(remain==1)
        return 0;
	ll k=0,a=1;
	for(ll g=__gcd(base,mod);g>1;g=__gcd(base,mod))
	{
		if(remain%g)
            return -1;
		remain/=g;
        mod/=g;
        ++k;
        a=a*(base/g)%mod;
		if(remain==a)
            return k;
	}
    clear();
	ll m=ceil(sqrt(1.0*mod));
	for(int i=1;i<=m;++i)
    {
        remain=remain*base%mod;
        insert(i,remain);
    }
    base=fast_power(base,m,mod);
    remain=a;
    ll flag;
	for(ll i=1;i<=m;++i)
	{
        remain=remain*base%mod;
        flag=find(remain);
        if(flag!=-1)
            return (i*m-flag+k);
	}
	return -1;
}
//返回值要求余mod,但不能在子函数里，因为mod变了
```

## 哈希表

链地址法解决冲突

```c++
typedef long long ll;
const int MAXN=1e7+1;
struct hash
{
    ll id,value;
    int next;
}e[MAXN];
int head[MAXN];
int tot;
inline ll hashfunc(ll x)
{
    return x%MAXN;
}
void insert(ll id,ll x)
{
    e[++tot]={id,x,head[hashfunc(x)]};
    head[hashfunc(x)]=tot;
}
ll find(ll x)
{
    for(int i=head[hashfunc(x)];i;i=e[i].next)
    {
        if(e[i].value==x)
            return e[i].id;
    }
    return -1;
}
void clear()
{
    for(;tot;--tot)
        head[hashfunc(e[tot].value)]=0;
}
```

# CRT

## 时间复杂度

$O(nlog n)$

求解如下形式的一元线性同余方程组

$x\equiv a_1 \pmod {n_1}$

$x\equiv a_2 \pmod {n_2}$

.

.

.

$x\equiv a_k \pmod {n_k}$

## 限制条件

$n_i$两两互质

## 算法流程

1. 计算所有模数的积 $n=\prod\limits_{i=1}^k n_i$
2. 对于第 $i$ 个方程：

   a. 计算 $m_i=n/n_i$ ;

   b. 计算 $m_i$ 在模 $n_i$ 意义下的逆元 $m_i^{-1}$;

   c. 计算 $c_i=m_i*m_i^{-1}$ (不要对 $n_i$ 取模)

3. 方程组的唯一解为 $x=\sum\limits_{i=1}^k a_i*c_i \pmod n$

```c++
long long CRT(int number,long long* remainder,long long* modulus)
{
    long long m,x,y,product = 1, ans = 0;
    for (int i = 1; i <= number; i++)
        product = product * modulus[i];
    for (int i = 1; i <= number; i++)
    {
        m = product / modulus[i];
        exgcd(m, modulus[i], x, y);
        ans = (ans + remainder[i] * m * x % product) % product;
    }
    return (ans % product + product) % product;
}
```

# excrt

解决模数不互质的情况

设两个方程分别是

$x=a_1 \pmod {n_1}$

$x=a_2 \pmod {n_2}$

将它们转化为不定方程：

$x=n_1*p+a_1=n_2*q+a_2$

其中 $p$ , $q$ 是整数,则有 $n_1*p-n_2*q=a_2-a_1$

由裴蜀定理，当 $a_2-a_1$ 不能被 $gcd(n1,n2)$ 整除时，无解

> 裴蜀定理：设 $a,b$ 是不全为零的整数，则存在整数 $x,y$, 使得 $ax+by=gcd(a,b)$.

其他情况下，可以通过扩展欧几里得算法解出来一组可行解$(p,q)$

则原来的两方程组成的模方程组的解为

$x=n_1*p+a_1 \pmod {lcm(m1,m2)}$

多个方程,用上面的方法两两合并即可

```c++
long long CRT(int number,long long* remainder,long long* modulus)
{
    long long lcm = modulus[1],sum = remainder[1],x,y,gcd;
    int fail = 0;
    for(int i = 2;i <= number;++i)
    {
        remainder[i] = ((remainder[i] - sum) % modulus[i] + modulus[i]) % modulus[i];
        gcd = exgcd(lcm,modulus[i],x,y);
        if(remainder[i] % gcd == 0)
            x = x * (remainder[i] / gcd) % modulus[i];
        else
        {
            fail = 1;
            break;
        }
        sum += x * lcm;
        lcm = lcm / gcd * modulus[i];
        sum = (sum % lcm + lcm) % lcm;
    }
    return fail ? -1 : sum;
}
```

# exgcd

$Ax\equiv C \pmod B$
，其中$A$、$B$、$C$都为常量，$x$是未知数

exgcd 解出特解$x_0,y_0$

通解：

$x=C/d*x_0+B/d*k$，$y=C/d*y_0-A/d*k$。

exgcd 函数返回值是最大公约数

## 代码

```c++
int exgcd(int a,int b,int &x,int &y)
{
	if(!b)
	{
		x=1;
		y=0;
		return a;
	}
	int r=exgcd(b,a%b,y,x);
	y-=x*(a/b);
	return r;
}
```

# 多项式

```
/*
快速傅立叶变换（fast Fourier transform）简称fft
时间复杂度O(nlogn)
空间复杂度O(2^t),（2^t>单项式合并后项数）
快速求出两个多项式相乘的结果
1个1元二次和一个1元3次相乘，最多有6项，空间复杂度里的t=3
应用：
1.从题目中抽象出多项式
2.求出答案和多项式之间联系
3.用fft求解多项式相乘（fft本体，学到后面会要求对fft本质优化，所以原理要看懂）
*/
const int MAXN = 1e7 + 10;
const double Pi = acos(-1.0);
struct comp//c++complex头文件的complex类运行速度很慢，所以自己定义复数结构体
{
    double x, y;
    comp (double xx = 0, double yy = 0) {x = xx, y = yy;}
    comp operator + (const comp b) const {return comp(x + b.x,y + b.y);}
    comp operator - (const comp b) const {return comp(x - b.x,y - b.y);}
    comp operator * (const comp b) const {return comp(x * b.x - y * b.y,x * b.y + y * b.x);}
} a[MAXN], b[MAXN];
int l, limit, r[MAXN];
int N,M;
void fft(comp *A, int type)
{
    for (int i = 0; i < limit; i++)//求出要迭代的序列
    {
        if (i < r[i])
            swap(A[i], A[r[i]]);
    }
    for (int mid = 1; mid < limit; mid <<= 1)//待合并区间的中点
    {
        comp Wn( cos(Pi / mid) , type * sin(Pi / mid) );//单位根
        for (int R = mid << 1, j = 0; j < limit; j += R)//R是区间的右端点，j表示前已经到哪个位置了
        {
            comp w(1, 0);//幂
            for (int k = 0; k < mid; k++, w = w * Wn)//枚举左半部分
            {
                comp x = A[j + k], y = w * A[j + mid + k];//蝴蝶效应
                A[j + k] = x + y;
                A[j + mid + k] = x - y;
            }
        }
    }
    if(type==-1)
    {
        for (int i = 0; i <= N + M; i++)
            a[i].x=(double)((int)(a[i].x / limit + 0.5));//四舍五入取整
    }
}
void init(int x)//x表示2个多项式相乘最多有几个单项式
{
    limit=1;
    l=-1;
    while (limit < x)
        limit <<= 1, l++;
    for (int i = 0; i < limit; i++)
        r[i] = ( r[i >> 1] >> 1 ) | ( (i & 1) << l );
}
init(N+M+1);
fft(a, 1);
fft(b, 1);
for (int i = 0; i < limit; i++)
    a[i] = a[i] * b[i];
fft(a, -1);
/*
三次变两次优化：
(a+bi)^2=a^2-b^2+2abi
所以把b放在虚部，答案是虚部/2，注意把fft除limit改成虚部
*/
分治fft
void solve(int l,int r,int logn)
{
    if(logn<=0) return;
    if(l>=n) return;
    int mid=(l+r)>>1,i;
    ll t=inv(r-l);
    solve(l,mid,logn-1); // 计算左区间
    calcrev(logn);
    memset(a+(r-l)/2,0,sizeof(ll)*(r-l)/2); // 拷贝左区间
    memcpy(a,f+l,sizeof(ll)*(r-l)/2); // 填充0
    memcpy(b,g,sizeof(ll)*(r-l)); // 拷贝g
    FFT(a,logn,0),FFT(b,logn,0); // 卷积
    for(i=0;i<r-l;i++) a[i]=a[i]*b[i]%kcz;
    FFT(a,logn,1);
    for(i=0;i<r-l;i++) a[i]=a[i]*t%kcz;
    for(i=(r-l)/2;i<r-l;i++)
        f[l+i]=(f[l+i]+a[i])%kcz; // 把卷积后的右半段的数加到f数组后半段
    solve(mid,r,logn-1); // 计算右区间
}
```

# ntt

```cpp
typedef long long ll;
const int MAXN = 3e6 + 10;
const int P = 998244353;
const int G = 3;
const int Gi = 332748118;//G在模P的逆元
int N, M, limit, l, r[MAXN];
ll a[MAXN], b[MAXN];
ll fastpow(ll a, ll k)
{
	ll base = 1;
	for(;k;k>>=1)
    {
		if(k & 1)
            base = (base * a ) % P;
		a = (a * a) % P;
	}
	return base % P;
}
void NTT(ll *A, int type)
{
	for(int i = 0; i < limit; i++)
    {
		if(i < r[i])
            swap(A[i], A[r[i]]);
    }
	for(int mid = 1; mid < limit; mid <<= 1)
    {
		ll Wn = fastpow( type == 1 ? G : Gi , (P - 1) / (mid << 1));
		for(int j = 0,R=mid<<1; j < limit; j +=R)
        {
			ll w = 1;
			for(int k = 0; k < mid; k++, w = (w * Wn) % P)
            {
				 int x = A[j + k], y = w * A[j + k + mid] % P;
				 A[j + k] = (x + y) % P,
				 A[j + k + mid] = (x - y + P) % P;
			}
		}
	}
    if(type==-1)
    {
        ll inv = fastpow(limit, P - 2);
        for(int i=N+M;i>=0;--i)
            A[i]=A[i]*inv%P;
    }
}
void init(int x)
{
    limit=1;
    l=-1;
    while(limit<x)
        limit<<=1,++l;
    for(int i=0;i<limit;++i)
        r[i]=(r[i>>1]>>1)|((i&1)<<l);
}
init(N+M+1);
NTT(a, 1);
NTT(b, 1);
for(int i = 0; i < limit; i++)
    a[i] = (a[i] * b[i]) % P;
NTT(a, -1);
```

# 数学杂

# 线性回归

一堆点 $(x_i,y_i)$ ，求一条直线 $F(x):y=Ax+B$ ，使得 $\sum\limits_{i=1}^n (y_i-F(x_i))^2$ 最小

设 $\overline{x}=\frac{\sum\limits_{i=1}^n x_i}n$ ， $\overline{y}=\frac{\sum\limits_{i=1}^n y_i}n$

$A=\frac{\sum\limits_{i=1}^n x_iy_i-n\overline{x} \overline{y}}{\sum\limits_{i=1}^n x_i^2-n\overline{x}^2}$

$B=\overline{y}-A\overline{x}$

# 自然数前 n 项 p 次方求和

$\sum\limits_{i=1}^n i=n(n+1)/2$

$\sum\limits_{i=1}^n i^2=n(n+1)(2n+1)/6$

$\sum\limits_{i=1}^n i^3=n^2(n+1)^2/4$

$\sum\limits_{i=1}^n i^4=n(n+1)(6n^3+9n^2+n-1)/30$

$\sum\limits_{i=1}^n i^5=n^2(n+1)(2n^3+4n^2+n-1)/12$

## 递推式推导

设 $f_n^p=\sum\limits_{i=1}^n i^{p}$

$(n+1)^p-n^p=C_p^1n^{p-1}+C_p^2n^{p-2}+...+1$

$\sum\limits_{n=1}^m(n+1)^p-n^p=\sum\limits_{n=1}^mC_p^1n^{p-1}+C_p^2n^{p-2}+...+1$

$(m+1)^p-1=C_p^1f_m^{p-1}+C_p^2f_m^{p-2}+...+m$

$f_m^{p-1}=((m+1)^p-1-(C_p^2f_m^{p-2}+...+m))/C_p^1$

$f_m^{p}=((m+1)^{p+1}-1-(C_{p+1}^2f_m^{p-1}+...+m))/(p+1)$

# 调和级数近似公式

n 很大时

$f_n\approx \ln n+0.5772156649+\frac 1{2n}$

```cpp
log(n)+0.5772156649+1.0/(2*n)
```

# 广义斐波那契数列求循环节

$f_n=af_{n-1}+bf_{n-2}$

## $f_n\pmod p$的最小循环节长度

1. 分解$p$为素因子幂的形式，即$p=\prod p_i^{a_i}$
2. 计算数列模$p_i^{a_i}$的循环节长度，设长度为$x_i$

$x_i=G(p_i)*p^{a_i-1}$

$G(p)$ 表示模$p$的最小循环节长度

求$G(p)$,设$c=a^2+4b$

$p=2$要特判（具体怎么判待研究）

## 欧拉准则

若 p 是奇质数且$p\nmid d$，

d 是模 p 的二次剩余当且仅当：

$d^{(p-1)/2}=1 \pmod p$

否则，d 是模 p 的二次非剩余

---

若$c$是$p$的二次剩余,枚举$p-1$的因子

若$c$是$p$的二次非剩余,枚举$(p-1)(p+1)$的因子

找到$G(p)$满足

$\begin{bmatrix}a&b\\1&0\end{bmatrix}^{G(p)} =\begin{bmatrix}1&0\\0&1\end{bmatrix} \pmod {p}$

3. 循环节长度$L=lcm(x_i)$

## 求较小循环节

注意到 $G(p)$一定是$(p-1)(p+1)$的因子

所以$x_i$一定是$(p_i-1)(p_i+1)*p_i^{a_i-1}$的因子

循环节长度$L=\prod (p_i-1)(p_i+1)*p_i^{a_i-1} \pmod p$
