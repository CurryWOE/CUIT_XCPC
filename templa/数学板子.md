- 概率论
- 博弈论
- 组合数学
  - 导读
  - 组合数取模
  - 球盒问题
  - 容斥原理
  - 卡特兰数高精
  - 二项式反演
  - 斯特林数
- 群论
  - polya定理
- 线性代数
  - 矩阵快速幂
  - 高斯消元
  - 线性基
- 多项式
  - 生成函数
  - fft
  - ntt
  - 拉格朗日插值
- 高数
- 杂

# 概率论
当概率论和DP复合时，问题转化为图上问题，状态看成点，状态转移看成边

如果该问题无后效性，那么按照拓扑序DP，否则高斯消元

如果纯概率论题，套公式即可
## 随机变量
定义：值无法预先确定，仅以一定可能性取值的量

按照取值数量是否有限分为“离散型”和“连续型”

另有两篇文章介绍XCPC中可能用到的“离散型”相关知识和“连续型”相关知识
## 概率DP
根据全概率公式，设点 $v$ 的入边的另一个点 $u$
$$P(v)=\sum P(u)P(v|u)$$
## 期望DP
$P(X)，E(X)$ 通常有两种定义

1. 起点到 $X$ 的概率，期望
2. $X$ 到终点的概率，期望

第二种用的比较多，因为第二种定义的概率常常为 1，方便编写

如果有自环，需要移项使得两边没有同样的式子

第二种需要建反图跑DP

第1种定义（统计入边）
$$E(Y)=\sum [E(X)+W(X\rightarrow Y)P(X)]P(Y|X)$$

第2种定义（统计出边）
$$E(Y)=\sum [E(X)+W(Y\rightarrow X)P(Y)]P(X|Y)$$
## 第一种定义期望公式的证明
>第二种类似

设 $x_i$ 为起点到 $X$ 的入边的另一个点 $Y$ 的路径长度，$p_i$ 为走该路径的概率

有一条 $Y$ 到 $X$ 的边,边权为 $w_j$

定义得
$$E(Y)=\sum x_ip_i$$
$$E(X)=\sum (x_i+w_j)p_iP(X|Y)$$
$P(X|Y)$ 提到前面去，$p_i$ 乘法分配律
$$E(X)=P(X|Y)\sum x_ip_i+w_jp_i$$
求和号可以拆成两个，前面一个就是 $E(Y)$，$w_j$ 提到前面去
$$E(X)=P(X|Y)[E(Y)+w_j\sum p_i]$$
显然后面一个就是 $P(Y)$
$$E(X)=P(X|Y)[E(Y)+w_jP(Y)]$$
## 例题讲解
## 前缀和技巧
$P(X=k)=P(X\le k)-P(X\le k-1)$
## 取球游戏
箱子里有 $n$ 个球 $1 \cdots n$，你要从里面拿 $m$ 次球，求取出的数字之和的期望。

1. 取出后放回
2. 取出后不放回
3. 取出后有 $p$ 的几率放回，有 $1-p$ 的几率放回两个

无论是哪种情况，因为过程中所有的球都是等价的，答案都是 $\frac{m(n+1)}2$
## 游走问题(马尔可夫过程)
在图上随机移动，从A点到B点的期望步数
### 链(一端到另一端)
设 $f_i$ 表示 $i$ 第一次游走到 $i+1$ 的期望步数，显然 $f_1 = 1$

考虑在 $i$ 点的可行策略可以得到转移 $f_{i} = \frac{1}{2}* 1 + \frac{1}{2}(1+f_{i-1}+f_{i})$

略加整理可得 $f_{i} = 2+f_{i-1}$

有 $f_n = (n-1)^2$
### 完全图
显然从任意一个点到任意一个点的期望步数是相同的，概率也是相同的

考虑每次到达指定点是一个概率为 $\frac{1}{n-1}$ 的事件，期望就是 $n-1$
### 完全二分图
类似于完全图，这里每一边的点概率均等

我们设 $E_1,E_2$ 分别表示从同侧点到达目标点的代价和异侧点到目标点的代价

转移有 $E_1 = \frac{1}{2} + \frac{1}{2}(1+E_2)$，$E_2 = 1+E_1$

可以得到 $E_2 = 2n-1$，$E_1 = 2n$
### 菊花图
菊花图上每个叶到叶，根到叶，叶到根的期望都是相同的

并且考虑叶之间并没有任何不同 但是在根和叶之间是区分出题目给出的起点和终点的

所以设 $E_1$ 表示根到叶的期望， $E_2$ 表示叶到叶的期望，显然叶到根点的期望为 $1$

所以可以得到 $E_1 = \frac{1}{n-1}+\frac{n-2}{n-1}(1+E_2)$,$E_2 = 1+E_1$

可以得到 $E_1 = 2n-3,E_2 = 2n-2$
### 树(根为起点)
考虑树形 dp。设 $x$ 为 $i$ 的父亲，$d[v]$ 表示点 $v$ 的度数，$son[v]$ 表示 $v$ 的孩子集合

设 $f_i$ 表示 $i$ 走到它父亲的期望步数，$g_i$ 表示 $i$ 的父亲走到 $i$ 的期望步数。可以写出 $f$ 的转移：

$$f_{i} = \frac{1+(\sum_{v \in son[i]}1+f_v+f_i)}{d_i}$$

化简可得：

$$f_{i} = d[i]+\sum_{v \in son_i} f_v$$

同样的可以写出 $g$ 的转移：

$$g_i = frac{1+(1+g_x+g_i)+(sum_{v in son_x且v neq i}1+f_v+g_i)}{d[x]}$$

化简可得：

$$g_i = g_x+d[x]+\sum_{v \in son_x且v \neq i}f_v$$
### 构造一个图
构造一张200个点的无向图，使得上面从S走到T的随机游走期望步数 $\ge 1e6$

我们构造一个n=100个点的团，以及一个 100 个点的链，考虑他们的连接点u，则u沿着链走一步的期望步数为

$\begin{aligned}E(u)&=\frac 1n+\frac{n-1}n(n-1+E(u))\\&=1+(n-1)^2\end{aligned}$

而我们知道在链上走的期望，于是得到走到终点的总期望为

$\frac{(E(u)+E(u)+2n)(n+1)}2$
​
可以达到要求
## 贡献拆分
>其实很多题，不止概率论，用得到这个技巧

第 $i$ 个人的排名，等价于 $\sum\limits_{j=1,j\ne i}^n[rk_j<rk_i]$
### 例题1
有 $n$ 堆石头，第 $i$ 堆个数为 $a_i$。每次随机选一个石头然后把那一整堆都扔了，求第1堆石头期望第几次被扔
### 例题2
给1,2,⋯,n这n个数，每次随机选择一个还在的数，删掉他的所有约数。求期望几次删完
### 例题3
给出一棵树, 一开始每个点都是白的, 每次选一个白点将他子树里所有点染黑，求期望几次染黑整个树
## 离散型概率
发生事件 $A$ 的概率，记做 $P(A)$

加法公式
$$P(A\cup B)=P(A)+P(B)-P(A\cap B)$$
$P(A\cup B)$ 表示发生A或B的概率

$P(A\cap B)$ 表示同时发生A和B的概率，以下简写为 $P(AB)$

条件概率
$$P(B|A)=\frac{P(AB)}{P(A)}$$
$P(B|A)$ 表示已经发生 $A$，再发生 $B$ 的概率

乘法公式
$$P(AB)=P(A)P(B|A)=P(B)P(A|B)$$

全概率公式
$$P(B)=\sum\limits_{i=1}^nP(A_i)P(B|A_i)$$

贝叶斯公式
$$P(B_i|A)=\frac{P(B_i)P(A|B_i)}{\sum\limits_{j=1}^nP(B_j)P(A|B_j)}$$
## 常见分布
### 两点分布 $X$ ~ $B(1,p)$
实际模型：事件发生的概率为 $p$，一次随机事件中，发生的事件数

$P(X=1)=p,P(X=0)=1-p$
### 二项分布 $X$ ~ $B(n,p)$
实际模型：事件每次发生的概率为 $p$，n次独立重复随机事件中，发生的事件数

$P(X=k)=\dbinom{n}{k}p^k(1-p)^{n-k},(k=0,1,...,n)$
### 泊松分布 $X$ ~ $P(\lambda)$
实际模型：每次事件发生与否相互独立，统计超长时间内事件发生次数，得出单位时间内事件平均发生次数 $\lambda$。那么单位时间内事件发生X次概率为：

$P(X=k)=\frac{\lambda^k}{k!}e^{-\lambda},(k=0,1,2,...)$
### 几何分布 $X$ ~ $G(p)$
实际模型：重复进行随机事件，直到事件发生为止才停下。$X$ 为首次发生时共做的事件的次数。每次发生的概率均为 $p$

$P(X=k)=(1-p)^{k-1}p,(k=1,2,...)(0<p<1)$
### 帕斯卡分布 $X$ ~ $Pas(r,p)$
实际模型：重复进行随机事件，直到发生 $r$ 次为止才停止。$X$ 为到停止为止时事件发生与未发生的次数之和

$P(X=k)=\dbinom{k-1}{r-1}(1-p)^{k-r}p^r,(k=r,r+1,...)$
### 超几何分布 $X$ ~ $H(n,M,N)$
实际模型：$N$ 个产品，其中 $M$ 个次品，从中任取 $n$ 个。$X$ 为这 $n$ 个中的次品数

$P(X=k)=\frac{\dbinom Mk\dbinom{N-M}{n-k}}{\dbinom{N}{n}}$

## 离散型期望
$$E(X)=\sum\limits_{i=1}^nx_iP_i$$

全期望公式
$$E(Y)=\sum P(X=a)E(Y|X=a)$$

min-max容斥计算期望
$$max(S)=\sum\limits_{T\subseteq S}min(T)(-1)^{|T|-1}$$
max表示满足所有条件的期望，min表示满足至少一个条件的期望
## 期望性质
期望的“线性”性质
$$E(aX+b)=aE(x)+b$$
$$E(X+Y)=E(X)+E(Y)$$
若 $X，Y$ 独立，则
$$E(XY)=E(X)E(Y)$$
独立：$P(AB)=P(A)P(B)$
## 期望和概率的一个联系
期望是概率的倒数

证明：如果你平均取 n 个球才会出现 1 个红球，也就是说期望是 n，那又可以说成是平均每 n 个球中出现 1 个红球，所以概率是 $\frac{1}{n}$
## 连续型概率
设连续型随机变量 $X$，设概率密度函数 $f$，简称密度
$$P(a<X\le b)=\int_{a}^bf(x)dx$$
## 密度性质
$$\int_{-\infty}^{+\infty}f(x)dx=1$$

$$\lim_{\epsilon\rightarrow 0}\int_{a-\epsilon}^{a+\epsilon}f(x)dx=0$$

## 分布函数$F(x)$
$$F(x)=P(X\le x)=\int_{-\infty}^xf(x)dx$$
若$F(x)$处处连续可微，则
$$F'(x)=f(x)$$
## 分布函数性质
1. $F(-\infty)=0，F(+\infty)=1$
2. $F(x)$ 单调非递减
## 常见分布
### 均匀分布 $X$ ~ $U[a,b]$
$f(x)=\begin{cases}\frac 1{b-a}&x\in[a,b]\\0&x\in(-\infty,a)\bigcup(b,\infty)\end{cases}$

$F(x)=\begin{cases}0&x\in(-\infty,a)\\\frac{x-a}{b-a}&x\in[a,b]\\1&x\in(b,\infty)\end{cases}$

$E(X)=\frac{a+b}2$
### 指数分布 $X$ ~ $\varepsilon(\lambda)$
服从泊松分布的事件，相邻两次发生的时间间隔服从指数分布，指数分布 $\lambda$ 参数意义和泊松分布 $\lambda$ 相同

$f(x)=\begin{cases}0&x\in(-\infty,0]\\\lambda e^{-\lambda x}&x\in(0,\infty)\end{cases}$

$F(x)=\begin{cases}0&x\in(\infty,0)\\1-e^{-\lambda x}&x\in[0,\infty)\end{cases}$

$E(X)=\frac 1\lambda$
### 正态分布 $X$ ~ $N(\mu,\sigma^2)$
根据中心极限定理，如果一个事物受到多种因素的影响，且因素彼此独立，不管每个因素本身是什么分布，它们加总后，结果的平均值就是正态分布

$f(x)=\frac 1{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}$

$F(x)=\int_{-\infty}^xf(t)dt$

$E(X)=\mu$

$N(0,1)$，称为标准正态分布
### 伽马分布 $X$ ~ $\Gamma(\alpha,\beta)$
指数分布是相邻两次，伽马分布是相邻 $\alpha+1$ 次的时间间隔

$\Gamma(\alpha)=\int_{0}^{\infty}x^{\alpha-1}e^{-x}dx$ 为伽马函数

$f(x)=\frac{\beta^{\alpha}}{\Gamma(\alpha)}x^{\alpha-1}e^{-\beta x}$

$E(X)=\frac{\alpha}{\beta}$
## 连续型期望
$$E(X)=\int_{-\infty}^{+\infty}xf(x)dx$$

$f(x)$ 为密度函数
# 博弈论导读
最简单的博弈论是奇偶性，比如[cf round 885A](https://codeforces.com/contest/1848/problem/A)。还有一个比较常见的技巧是下模仿棋，就是对方怎么做，你做一模一样的或者对称地做。
## 公平组合游戏(Impartial Combinatorial Games,ICG)
* 两名选手，交替进行预先规定好的操作
* 任何时刻，合法操作只取决于局面本身，与选手无关
* 不能合法操作的选手判负
### 和图论的联系
把一种局面看成一个点，一次操作会改变局面，每个局面向其后继局面连边，那么可以得到一个博弈状态图

定义必胜态是先手必胜的状态，必败态是先手必败的状态。之后也沿用这个概念

根据ICG定义，没有后继状态的状态是必败态

根据贪心策略，若后继状态有必败态，则当前状态是必胜态；否则当前状态是必败态

如果博弈图是有向无环图，那么每个点的状态都是确定的
# 常见结论
这部分感觉就了解一下，碰到了相关题翻一下板子
## Chomp游戏
问题：Chomp是一个双人游戏，有 $n*m$ 块曲奇饼排成一个矩形格状，称作棋盘。两个玩家轮流自选吃掉一块还剩下的曲奇饼，而且要把它右边和下面所有的曲奇饼都被取走（如果存在）。如果不吃左上角的那一块曲奇饼（位置记为(1, 1)）就没有其他选择的玩家为失败。

答案：除了$1*1$ 的情况，必胜

解释：如果先手吃了 (1,1)，而后手有必败策略，那么先手直接走后手策略，使得必胜

对于棋盘特殊形状可以找到具体执行策略，但是一般情形尚未有具体执行策略
## Bash博弈
问题：一堆 n 个石子，可取出 1~m 个。$m<n$，拿走最后一个石子者获胜

答案：当 n 不是 m+1 的倍数，必胜，否则必败

解释：

$n\%(m+1)\ne 0$ 可以变成 $n\%(m+1)\ne 0$ 或 $n\%(m+1)= 0$

而 $n\%(m+1)= 0$ 只能变成 $n\%(m+1)\ne 0$

必胜证明：先手把 $n\%(m+1)\ne 0$ 变成 $n\%(m+1)= 0$，后手只能变成 $n\%(m+1)\ne 0$，不断重复此过程，最终 $n=0,n\%(m+1)=0$ ，所以最后一个石子是先手拿的。

必败证明：后手模仿棋使得必败
## Fibonacci博弈
问题：一堆n个石子，先手者第一次可以取任意多个，但是不能取完，以后每次取的石子数不能超过上次取子数的2倍。取完者胜

答案：n是斐波那契数，必败，否则必胜

解释：

当 $n\le 3$，显然必败，即 $f_3,f_4$ 必败

当 $i>=5,n=f_i=f_{i-1}+f_{i-2}$，$2f_{i-2}>f_{i-1}$

必败证明：如果先手取大于等于 $f_{i-2}$ 个石子，那么后手可以拿完剩下石子。如果先手拿小于 $f_{i-2}$ 石子，那么局面转换到谁拿完 $f_{i-2}$ 胜，因为拿完后局面变成 $f_{i-1}$ ，碰到此局面者输。而拿完 $f_{i-2}$ 的局面先手也是输，因此先手必败

齐肯多夫定理：任何正整数n可以被表示成若干个不连续的斐波那契数之和

$n=f_{a_1}+f_{a_2}+f_{a_3}+...$ ，$a_1+1<a_2,a_2+1<a_3,...$

$2f_{a_{i-1}}<f_{a_i}$

必胜证明：如果先手拿完 $f_{a_1}$ ，那么后手不可能拿完 $f_{a_2}$ ，因为局面和必败局面类似，类似地，后手也不可能拿完 $f_{a_3},f_{a_4},...$ ，所以最后一个是先手拿
## Wythoff博弈
问题：两堆各若干石子，从任意一堆中至少取出一个或者从两堆中取出同样多的石子，规定每次至少取一个，至多不限，最后取光者胜。

这里的必输局势：(0，0)、(1，2)、(3，5)、(4，7)、(6，10)、(8，13)、(9，15)、(11，18)、(12，20)...

通过Beatty序列计算（这里省去），可以得出必输局势：

$(a_i,b_i)=(i∗\frac{1+\sqrt 5}2,i∗\frac{1+\sqrt 5}2+i),i=0,1,2,3...$

```cpp
double r = (sqrt(5) + 1) / 2;
int d = abs(a - b) * r;
return (d != min(a, b));
```
>如果a,b的值非常大的话，需要高精度来计算这个double类型的r。
## Nim博弈
问题：有n堆石子，两人轮流取，每次取某堆中不少于1个，最后无合法操作者输

答案：所有堆石子数量，异或和不为0，必胜，否则必败

证明等后面介绍了SG函数和SG定理再说
# SG函数(Sprague-Grundy)
给定博弈状态图，且是有向无环图，定义每个点的SG函数如下：

$$ SG(x)=mex\{SG(y) | y是x的后继\} $$

如果 $SG(x)=n$ ，说明从当前状态可以转移到 $SG(y)=0,1,...,n-1$ 的局面

根据ICG定义，$SG=0$ 是必败态，否则是必胜态

对于单堆Nim游戏，SG(0)=0，那么SG(1)=1,SG(2)=2，归纳证明 SG(n)=n
## 求mex
```cpp
int mex(auto v) // v可以是vector、set等容器 
{
    set<int> S(v.begin(),v.end());
    for (int i = 0;; ++i)
        if (S.find(i) == S.end())
            return i;
}
```
## 求所有点的SG函数
1. 找出必败态，其SG=0
2. 找出当前所有状态的前驱结点
3. 根据定义计算结点SG值
4. 重复上述步骤，直到所有点的SG函数值被计算过
## 求游戏SG函数（SG定理）
游戏：若干ICG的组合，这里ICG称为子游戏，每位玩家每回合只能选择一个子游戏操作，不能合法操作者输

游戏SG函数意义和点SG函数意义一样，后续局面的mex，但是真的去求后续局面，再求mex时间不现实，SG定理可以加速计算

SG定理：游戏SG函数等于它的所有子游戏的SG函数值的异或和

SG定理证明略

单堆石子就是一个子游戏，因此证明了上面的Nimm博弈
## Anti-SG
如果是ICG，胜者判定改为不能合法操作者胜；如果是游戏，规定所有子游戏SG=0时，游戏结束

必胜仅当：游戏SG不为0且存在一个子游戏SG大于1，或者，游戏SG为0且不存在一个子游戏SG大于1
## Multi-SG
在符合拓扑原则的前提下，一个子游戏的后继可以为多个子游戏。

上面这个说法有点抽象，结合最简单的Muti-SG模型理解：

有n堆石子，两个人可以从任意一堆石子中拿任意多个石子(不能不拿)或把一堆数量不少于2
石子分为两堆不为空的石子，无合法操作者输

SG(3)的后继状态有{(0),(1),(2),(1,2)}，他们的SG值分别为{0,1,2,SG(1) XOR SG(2)}
，因此SG(3)=mex{0,1,2,3}=4
## Every-SG
每个人每回合必须同时操作全部尚未结束的子游戏，无合法操作者输

玩家目标实际上变成最后一个子游戏的胜利，那么必胜的子游戏尽可能拖时间，相反，必输的子游戏尽快结束。时间，就是距离游戏结束还有多少回合。必胜找剩余回合数最多的，必败找剩余回合数最少的

$step(u) = \begin{cases} 0&&u为终止状态\\ max{step(v)}&& sg(u)≠0∧v为u的后继∧sg(v)=0\\ min{step(v)} && \text{sg(u)=0∧v为u的后继} \end{cases}$

必胜当且仅当子游戏最大的step为奇数
## 树的删边游戏
给出一个有 N个点的树，有一个点作为树的根节点。游戏者轮流从树中删去边，删去一条边后，不与根节点相连的部分将被移走。谁无法移动谁输。

叶子节点的SG值为0；中间节点的SG值为它的所有子节点的SG值加1后的异或和。
## 无向图的删边游戏
一个无相联通图，有一个点作为图的根。游戏者轮流从图中删去边，删去一条边后，不与根节点相连的部分将被移走。谁无路可走谁输。

边数是偶数的环缩成一个点，奇数的环缩成一个点加一条边

将任意一个无向图改成树结构，“无向图的删边游戏”就变成了“树的删边游戏”。
## Nim-k
可以同时取最多k堆石头

结论：若满足：将 $a_i$ 写成二进制，若对于每一个二进制位，所有的 $a_i$ 那一位的1的数量 %k=0，则先手必败，否则必胜
## 阶梯Nim
每次将所取第i堆的石头转移到第i-1堆，到0停止

若所有奇数位的数异或起来，若不为0则必胜

证明：移入偶数堆的石头可以看做是被清除了

如果有人拿出来就再将其丢去下一个偶数堆，对局面不影响

之所以是偶数是因为0是偶数，移入0的石头无法再移出，不再有影响。
## 二分图博弈
给出一张二分图和起始点 H ，A和B轮流操作，每次只能选与上个被选择的点（第一回合则是点 H ）相邻的点，且不能选择已选择过的点，无法选点的人输掉。一个经典的二分图博弈模型是在国际象棋棋盘上，双方轮流移动一个士兵，不能走已经走过的格子，问谁先无路可走。

如果最大匹配一定包含 H ，那么先手必胜，否则先手必败。

如果采用Dinic，在建图时把涉及 H 点的边存下来，跑完第一次Dinic后再建这些边，第二次Dinic看有没有增加流量。
## K倍动态减法游戏
有n个石子，两个游戏者轮流操作，第一个操作的人最多能拿走n-1个石子，以后，每个游戏者最多能拿走前一个游戏者拿走数目的k倍

k=1,必败态是 $2^i$

k=2,Fibonacci博弈

k>2，类似Fibonacci博弈，把n分解成数列中不连续项的和，如果n就是数列中的数，必败
```cpp
ll f[N],g[N];//f代表类Fibonacci数列，g[i]表示f[0-i]能组成的最大数
void init(int k)
{
    f[0]=g[0]=1;
    for(int i=1,j=0;i<N;++i)
    {
        f[i]=g[i-1]+1;
        while(f[j+1]*k<f[i])
            ++j;
        if(f[j]*k<f[i])
            g[i]=g[j]+f[i];
        else
            g[i]=f[i];
    }
}
```

# 组合数学导读
### 多重集的排列数
$$\frac{n!}{\prod_{i=1}^k(n_i!)}$$
### 多重集的组合数
$$\binom{r+k-1}{k-1}$$
## 不相邻的排列

$1 \sim n$ 这 $n$ 个自然数中选 $k$ 个，这 $k$ 个数中任何两个数都不相邻的组合有 $\displaystyle \binom {n-k+1}{k}$ 种。

## 圆排列

$n$ 个人全部来围成一圈，所有的排列数记为 $\mathrm Q_n^n$。考虑其中已经排好的一圈，从不同位置断开，又变成不同的队列。
所以有

$$\mathrm Q_n^n \times n = \mathrm A_n^n \Longrightarrow \mathrm Q_n = \frac{\mathrm A_n^n}{n} = (n-1)!$$

由此可知部分圆排列的公式：

$$\mathrm Q_n^r = \frac{\mathrm A_n^r}{r} = \frac{n!}{r \times (n-r)!}$$

## 组合数性质

$$\binom{n}{m}=\binom{n}{n-m}\tag{1}$$

相当于将选出的集合对全集取补集，故数值不变。（对称性）

$$\binom{n}{k} = \frac{n}{k} \binom{n-1}{k-1}\tag{2}$$

由定义导出的递推式。

$$\binom{n}{m}=\binom{n-1}{m}+\binom{n-1}{m-1}\tag{3}$$

组合数的递推式（杨辉三角的公式表达）

$$\binom{n}{0}+\binom{n}{1}+\cdots+\binom{n}{n}=\sum_{i=0}^n\binom{n}{i}=2^n\tag{4}$$

这是二项式定理的特殊情况。取 $a=b=1$ 就得到上式。

$$\sum_{i=0}^m \binom{n}{i}\binom{m}{m-i} = \binom{m+n}{m}\ \ \ (n \geq m)\tag{5}$$

拆组合数的式子，在处理某些数据结构题时会用到。

$$\sum_{i=0}^n\binom{n}{i}^2=\binom{2n}{n}\tag{6}$$

这是 $(5)$ 的特殊情况，取 $n=m$ 即可。

$$\sum_{i=0}^ni\binom{n}{i}=n2^{n-1}\tag{7}$$

带权和的一个式子，通过对 $(3)$ 对应的多项式函数求导可以得证。

$$\sum_{i=0}^ni^2\binom{n}{i}=n(n+1)2^{n-2}\tag{8}$$

与上式类似，可以通过对多项式函数求导证明。

$$\sum_{l=0}^n\binom{l}{k} = \binom{n+1}{k+1}\tag{9}$$

在恒等式证明中较常用。

$$\binom{n}{r}\binom{r}{k} = \binom{n}{k}\binom{n-k}{r-k}\tag{10}$$

通过定义可以证明。

$$\sum_{i=0}^n\binom{n-i}{i}=F_{n+1}\tag{11}$$

其中 $F$ 是斐波那契数列。
## 常见数列

### 错排问题

$f_n=(n-1)(f_{n-1}+f_{n-2})$。

错位排列数列的前几项为 $0,1,2,9$。

### 卡特兰数

#### 经典题：进出栈序列

n 个元素进栈序列为：1，2，3，4，...，n，则有多少种出栈序列

我们将进栈表示为 +1，出栈表示为 -1

出栈序列的所有前缀和必然大于等于 0，并且序列 +1 的数量 等于 -1 的数量

接下来让我们观察一下 n = 3 的一种出栈序列：+1 -1 -1 +1 -1 +1。序列前三项和小于 0，显然这是个非法的序列。

如果将 第一个 前缀和小于 0 的前缀，即前三项元素都进行取反，就会得到：-1 +1 +1 +1 -1 +1。此时有 3 + 1 个 +1 以及 3 - 1 个 -1。

因为这个小于 0 的前缀和必然是 -1，且 -1 比 +1 多一个，取反后，-1 比 +1 少一个，则 +1 变为 n + 1 个，且 -1 变为 n - 1 个。进一步推广，对于 n 元素的每种非法出栈序列，都会对应一个含有 n + 1 个 +1 以及 n - 1 个 -1 的序列。

如何证明这两种序列是一一对应的？

假设非法序列为 A，对应的序列为 B。每个 A 只有一个"第一个前缀和小于 0 的前缀"，所以每个 A 只能产生一个 B。而每个 B 想要还原到 A，就需要找到"第一个前缀和大于 0 的前缀"，显然 B 也只能产生一个 A。

每个 B 都有 n + 1 个 +1 以及 n - 1 个 -1，因此 B 的数量为 $\dbinom {2n}{n+1}$ ，相当于在长度为 2n 的序列中找到 n + 1 个位置存放 +1。相应的，非法序列的数量也就等于 $\dbinom {2n}{n+1}$ 。

出栈序列的总数量共有 $\dbinom {2n}{n}$ ，因此，合法的出栈序列的数量为 $\dbinom {2n}{n}-\dbinom {2n}{n+1}$ 。

此时我们就得到了卡特兰数的通项 $\dbinom {2n}{n}-\dbinom {2n}{n+1}=\dbinom{2n}{n}/(n+1)$

#### 例题

n 对括号，则有多少种 “括号匹配” 的括号序列

左括号+1，有括号-1

n + 1 个叶子节点能够构成多少种形状不同的满二叉树

> 如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。

非叶节点，左子树+1，右子树-1

电影票一张 50 coin，且售票厅没有 coin。m 个人各自持有 50 coin，n 个人各自持有 100 coin。则有多少种排队方式，可以让每个人都买到电影票。

50+1，100-1

公式不同，$\dbinom {n+m}n-\dbinom{n+m}{m+1}$

节点数为 $i$ 时二叉树构造的方案数

> 写题就是寻找满足下列公式的特点

#### 公式

$C_n=\dbinom{2n}{n}/(n+1)$

$C_1=1,C_n=C_{n-1}\times\frac{4n-2}{n+1}$

$C_n=\begin{cases}1&n=0,1\\\sum\limits_{i=1}^n C_{i-1}*C_{n-i}&2\le n\end{cases}$

$C_n=\dbinom {2n}{n}-\dbinom {2n}{n+1}$

# 组合数取模
## 阶乘
```cpp
const int N=1e6+3;
long long fac[N],inv[N];
long long fast_power(long long base, long long exponent)
{
    long long result = 1;
    for (; exponent > 0; exponent >>= 1)
    {
        if (exponent & 1)
            result = result * base % mod;
        base = base * base % mod;
    }
    return result;
}
void getC()
{
    fac[0]=1;
    for(int i=1;i<N;++i)
        fac[i]=fac[i-1]*i%mod;
    inv[N-1]=fast_power(fac[N-1],mod-2);
    for(int i=N-1;i;--i)
        inv[i-1]=inv[i]*i%mod;
}
long long C(int n,int m)
{
    return fac[n]*inv[m]%mod*inv[n-m]%mod;
}
```

## Lucas 定理

### 适用条件

$n,m$ 较大，$p$ 为素数

### 公式

$C(n,m)\%p=C(n/p,m/p)*C(n\%p,m\%p)\%p$

### 时间复杂度

$O(f(x)+g(n)log_p n)$

$f(x)$ 为预处理组合数的复杂度，$g(n)$ 为单次求组合数的复杂度

$p$ 小，逆元打表，$O(n+p+log_p n)$

//$n$ 为处理阶乘，$p$ 为打表，$log_p n$为单次查询

$p$ 大，exgcd 求逆元,$O(n+ln p*log_p n)$

//$n$ 为处理阶乘，$\ln p*log_p n$ 为单次查询

```c++
long long Lucas(long long n, long long m, long long p)
{
    if (m == 0) return 1;
    return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p;
}
```

## exLucas

### 适用条件

$n,m$ 较大，$p$ 不为素数

### 时间复杂度

$O(plog p)$

```c++
ll qpow(ll base,ll exponent,ll mod)
{
    ll result=1;
    for(;exponent;base=base*base%mod,exponent>>=1)
    {
        if(exponent&1)
            result=result*base%mod;
    }
    return result;
}
ll g(ll n,ll p)
{
    if(n<p)
        return 0;
    return g(n/p,p)+n/p;
}
ll calc(ll n,ll p,ll MOD)
{
    if(n==0)
        return 1;
    ll res=1;
    for(ll i=1;i<=MOD;i++)
    {
        if(i%p)
            res=res*i%MOD;
    }
    res=qpow(res,n/MOD,MOD);
    for(ll i=n/MOD*MOD+1;i<=n;i++)
    {
        if(i%p)
            res=res*(i%MOD)%MOD;
    }
    return res*calc(n/p,p,MOD)%MOD;
}
ll exgcd(ll a,ll b,ll &x,ll &y)
{
	if(!b) {x=1,y=0;return a;}
	ll r=exgcd(b,a%b,y,x);
	y-=x*(a/b);
	return r;
}
ll inv(ll a,ll n)
{
    ll x,y;
    if(exgcd(a,n,x,y)==1ll)
        return (x%n+n)%n;
    else
        return -1;
}
ll lucas(ll n,ll m,ll p,ll MOD)
{
    ll pw=qpow(p,g(n,p)-g(m,p)-g(n-m,p),MOD);
    return calc(n,p,MOD)*inv(calc(m,p,MOD),MOD)%MOD*inv(calc(n-m,p,MOD),MOD)%MOD*pw%MOD;
}
ll CRT(const vector<ll> &a,const vector<ll> &m)
{
    int siz=a.size();
    ll mul=1,sum=0;
    for(auto tmp:m)
        mul*=tmp;
    for(int i=0;i<siz;i++)
    {
        ll M=mul/m[i];
        sum=(sum+a[i]*M%mul*inv(M,m[i]))%mul;
    }
    return sum%mul;
}
ll exlucas(ll n,ll m,ll MOD)
{
    vector<ll> a,mod;
    ll tmp=MOD;
    for(int p=2;p<=tmp/p;p++)
    {
        if(tmp%p==0)
        {
            ll mul=1;
            while(tmp%p==0)
                mul*=p,tmp/=p;
            mod.push_back(mul),a.push_back(lucas(n,m,p,mul));
        }
    }
    if(tmp>1) mod.push_back(tmp),a.push_back(lucas(n,m,tmp,tmp));
    return CRT(a,mod);
}
```
# 球盒问题
$n$ 个球，放入 $m$ 个盒中,共8种情况
## 球同，盒不同，无空箱
$C(n-1,m-1)$

使用插板法：$n$ 个球中间有 $n-1$ 个间隙，现在要分成 $m$ 个盒子，而且不能有空箱子，所以只要在 $n-1$ 个间隙选出 $m-1$ 个间隙即可
## 球同，盒不同，允许空箱
$C(n+m-1,m-1)$

如果给每个盒子一个球，就可以把问题转化为不能空的情况了,就相当于 $n+m$ 个小球放入 $m$ 个盒子且不能空
## 球不同，盒相同，无空箱
第二类斯特林数 $\begin{Bmatrix}n\\ m\end{Bmatrix}$
```c++
const int N=5e3+3;
ll S[N][N];
void cal()
{
    S[0][0]=1;
    for(int i=1;i<N;++i)
    {
        for(int j=1;j<=i;++j)
            S[i][j]=S[i-1][j-1]+(ll)j*s[i-1][j];
    }
}
```
## 球不同，盒相同，允许空箱
$\sum\limits_{i=1}^m\begin{Bmatrix}n\\ i\end{Bmatrix}$

枚举使用的箱子的个数
## 球不同，盒不同，无空箱
$m!\times \begin{Bmatrix}n\\ m\end{Bmatrix}$

给盒子定义顺序
## 球不同，盒不同，允许空箱
$m^n$

每个球都有 $m$ 种选择
## 球同，盒同，无空箱
等同于把一个正整数n拆分成m个正整数之和的方案数，即分拆数的k部分拆 $p(n,m)$
```cpp
const int N=5e3+3;
ll p[N][N];
void cal()
{
    p[0][0]=1;
    for(int i=1;i<N;++i)
    {
        for(int j=1;j<=i;++j)
            p[i][j]=p[i-j][j]+p[i-1][j-1];
    }
}
```
## 球同，盒同，允许空箱
等同于把一个正整数拆分成几个正整数之和的方案数，即分拆数 $p(n)=\sum\limits_{i=1}^m p(n,i)$

# 容斥原理
## min-max 容斥

通过集合最小值计算集合最大值，或者反过来
$$max(S)=\sum\limits_{T\subseteq S}min(T)(-1)^{|T|-1}$$
$|T|$ 表示 $T$ 的元素个数
$$min(S)=\sum\limits_{T\subseteq S}max(T)(-1)^{|T|-1}$$
如果只是计算集合最大最小值，$O(n)$ 即可完成，但是这个结论可以放到期望上

即，max 表示满足所有条件的期望，min 表示满足至少一个条件的期望

## Kthmin-max 容斥

$$Kthmax(S)=\sum\limits_{T\subseteq S}min(T)\dbinom{|T|-1}{k-1}(-1)^{|T|-k}$$

## gcd-lcm 容斥

$$lcm(S)=\sum\limits_{T\subseteq S}gcd(T)(-1)^{|T|-1}$$

# 卡特兰数高精

$C_n=\dbinom{2n}{n}/(n+1)$

将乘除部分按照质因数存储，乘法即答案的相应质因数 +1 ，除法则 −1 ，可以优化掉高精除低精这个过程。

同时，应用高精度压位技巧，即数组中的每一位存储多个数字

```c++
typedef long long ll;
int exponential[1010];
struct big
{
    int len;
    ll x[1000];
    int bit=1e9;
    ll& operator [](int a)
    {return x[a];}
    friend void operator *=(big &a,int b)
    {
        int len=a.len,bit=a.bit;
        for(int i=1;i<=len;i++)a[i]*=b;
        int now=1;
        while(now<=len)
        {
            if(a[now]>=bit)a[now+1]+=a[now]/bit,a[now]%=bit;
            if(now==len&&a[len+1])len++;
            now++;
        }
        a.len=len;
    }
    void print()
    {
        cout<<x[len];
        for(int i=len-1;i>=1;i--)
            cout<<setw(9)<<setfill('0')<<x[i];
    }
}catalennumber;
void add(int x,int v)
{
    for(int i=2;i*i<=x;++i)
    {
        while(x%i==0)
        {
            x/=i;
            exponential[i]+=v;
        }
    }
    if(x!=1)
        exponential[x]+=v;
}
void catalan(int n)
{
    int t=n<<1;
    for(int i=n+2;i<=t;++i)
        add(i,1);
    for(int i=1;i<=n;++i)
        add(i,-1);
    catalennumber[1]=catalennumber.len=1;
    for(int i=1;i<=t;++i)
    {
        while(exponential[i])
        {
            catalennumber*=i;
            --exponential[i];
        }
    }
    catalennumber.print();
}
```
# 二项式反演
## 形式1
$f(k)=\sum\limits_{i=k}^n \dbinom ik g(i)$

$g(k)=\sum\limits_{i=k}^n (-1)^{i-k}\dbinom ikf(i)$
## 形式2
$f(k)=\sum\limits_{i=m}^{k} \dbinom ki g(i)$

$g(k)=\sum\limits_{i=m}^k (-1)^{k-i}\dbinom kif(i)$
# 斯特林数
## 第一类斯特林数
n个不同元素构成m个圆排列的方案数，记为 $s(n,m)$，或 $\begin{bmatrix}n\\ m\end{bmatrix}$

分为无符号 $s_u(n,m)$ 和有符号 $s_s(n,m)$ ，关系是 $S_s(n,m)=(-1)^{n-m}s_u(n,m)$
### $O(n^2)$求第一类斯特林数
1-n的一个排列，划分为m个圆排列，第n个数，要么放在一个新的圆，要么放在旧的圆

$\begin{bmatrix}n\\ m\end{bmatrix}=\begin{bmatrix}n-1\\ m-1\end{bmatrix}+(n-1)\times\begin{bmatrix}n-1\\ m\end{bmatrix}$

边界情况： $\begin{bmatrix}n\\ n \end{bmatrix}=1(n\ge 0)$ ， $\begin{bmatrix}n\\ 0 \end{bmatrix}=0 (n\ge 1)$
```cpp
const int N=5e3+3;
ll s[N][N];
void cal()
{
    s[0][0]=1;
    for(int i=1;i<N;++i)
    {
        for(int j=1;j<=i;++j)
            s[i][j]=s[i-1][j-1]+(ll)(i-1)*s[i-1][j];
    }
}
```
### 无符号第一类斯特林数性质
1. $s_u(n,1)=(n-1)!$
2. $s_u(n,2)=(n-1)!\sum\limits_{i=1}^{n-1}\frac 1i$
3. $s_u(n,n-1)=\dbinom n2$
4. $s_u(n,n-2)=2\dbinom n3+3\dbinom n4$
5. $\sum\limits_{i=0}^ns_u(n,i)=n!$
## 第二类斯特林数
n个不同元素构成m个互不区分的非空子集的方案数，记为 $S(n,m)$，或 $\begin{Bmatrix}n\\ m\end{Bmatrix}$
### $O(n^2)$求第二类斯特林数
1-n的一个排列，划分为m个互不区分的非空子集，第n个数，要么放在一个新的集合，要么放在旧的集合

$\begin{Bmatrix}n\\ m\end{Bmatrix}=\begin{Bmatrix}n-1\\ m-1\end{Bmatrix}+m\times\begin{Bmatrix}n-1\\ m\end{Bmatrix}$

边界情况： $\begin{Bmatrix}n\\ n \end{Bmatrix}=1(n\ge 0)$ ， $\begin{Bmatrix}n\\ 0 \end{Bmatrix}=0 (n\ge 1)$
```cpp
const int N=5e3+3;
ll S[N][N];
void cal()
{
    S[0][0]=1;
    for(int i=1;i<N;++i)
    {
        for(int j=1;j<=i;++j)
            S[i][j]=S[i-1][j-1]+(ll)j*S[i-1][j];
    }
}
```
### $O(n)$求第二类斯特林数
$\begin{Bmatrix}n\\ m\end{Bmatrix}=\sum\limits_{i=0}^m\frac{(-1)^{m-i}i^n}{i!(m-i)!}$
```cpp
const int N=2e5+3;
ll v[N];
int p[N>>2],n;
void seive()
{
	int cnt=0;
    v[1]=1;//!!
	for(int i=2;i<N;++i)
	{
		if(!v[i])
        {
			p[cnt++]=i;
            v[i]=fast_power(i,n);
        }
		for(int j=0;j<cnt && i*p[j]<N;++j)
		{
			v[i*p[j]]=v[i]*v[p[j]]%mod;
			if(i%p[j]==0)
				break;
		}
	}
}
ll cal(int m)
{
    ll res=0;
    for(int i=0;i<=m;++i)
    {
        if((m-i)&1)
            res=(res-v[i]*inv[i]%mod*inv[m-i]%mod+mod)%mod;
        else
            res=(res+v[i]*inv[i]%mod*inv[m-i]%mod)%mod;
    }
    return res;
}
```
### 第二类斯特林数性质
1. $S(n,1)=1$
2. $S(n,2)=2^{n-1}-1$
3. $S(n,3)=\frac 12(3^{n-1}+1)-2^{n-1}$
4. $S(n,n-1)=\dbinom n2$
5. $S(n,n-2)=\dbinom n3+3\dbinom n4$
6. $S(n,n-3)=\dbinom n4+10\dbinom n5+15\dbinom n6$
7. $\sum\limits_{i=0}^nS(n,i)=B_n$ ，$B_n$ 是贝尔数
8. $\sum\limits_{i=0}^n(-1)^i\dbinom ni(n-i)^n=n!$
9. $n^k=\sum\limits_{i=0}^kS(k,i)(i!)\dbinom ni$
## 上升幂和下降幂
普通幂：$x^n$

上升幂：$x^{\overline n}=\prod\limits_{i=0}^{n-1}(x+i)$

上升幂和普通幂转换：

$$x^{\overline n}=\sum\limits_{i=0}^n\begin{bmatrix}n\\ i\end{bmatrix}x^i$$

$$x^n=\sum\limits_{i=0}^n\begin{Bmatrix}n\\ i\end{Bmatrix}(-1)^{n-i}x^{\overline i}$$

下降幂：$x^{\underline n}=\prod\limits_{i=0}^{n-1}(x-i)$

下降幂和普通幂转换：

$$x^{\underline n}=\sum\limits_{i=0}^n\begin{bmatrix}n\\ i\end{bmatrix}(-1)^{n-i}x^i$$

$$x^n=\sum\limits_{i=0}^n\begin{Bmatrix}n\\ i\end{Bmatrix}x^{\underline i}$$

普通幂转下降幂是常用套路，注意恒等式 $\dbinom nii^{\underline j}=\dbinom{n-j}{i-j}n^{\underline j}$
# 群论入门与polya定理
Burnside引理不方便计算，这里仅介绍polya定理
# 置换
一个集合到它自己本身的双射称为置换
## 轮换表达式
上面写法过于麻烦，通常用轮换表达式表示，$i$ 向 $f(i)$ 连边，置换就是多个环形成的图

$\pi=\begin{matrix}1&2&3&4&5&6\\2&4&5&1&3&6\end{matrix}$

可以表示为 $(124)(35)(6)$ ,轮换个数记为 $C(\pi)=3$，即环的个数
## 置换群
对自身的双射显然满足群对运算符的要求，因此 $(所有置换组成的集合,对自身的双射)$ 是一个群，称为置换群
# Polya 定理
设 $G=\{\pi_1,\pi_2,\pi_3,...,\pi_k\}$是 $X=\{a_1,a_2,a_3,...,a_n\}$ 上一个置换群，

用 $m$ 种颜色对 $X$ 中的元素进行染色，那么不同的染色方案数为：

$\frac{1}{|G|} * \sum\limits_{i=1}^{k} m^{C(\pi_i)}$

在xcpc中的置换主要是旋转(rotate)和翻转(reflection to the axis of symmetry)
## 旋转
设环有 $n$ 个元素，群阶等于 $n$ 。因为旋转n次等于旋转0次

当旋转 $i$ 个位置，轮换个数为 $gcd(n,i)$，且每个轮换的长度为 $L=n/gcd(n,i)$。可以手动模拟理解一下

应用polya定理：

$\frac 1n\sum\limits_{i=1}^n m^{gcd(n,i)}$

优化上述式子：

$\frac 1n\sum\limits_{d|n}m^d\sum\limits_{i=1}^n[gcd(i,n)=d]$

$\frac 1n\sum\limits_{d|n}m^d\sum\limits_{i=1}^{\frac nd}[gcd(i,\frac nd)=1]$

$\frac 1n\sum\limits_{d|n}m^d\phi(\frac nd)$

### 例题
黑白两种颜色对下面的 $2\times 2$ 方格进行染色,

如果允许方格可以绕中心点旋转, 问有多少种不同的着色方案数?

$\begin{matrix}1&2\\3&4\end{matrix}$

---
方格可以旋转 $0°,90°,180°,270°$ 。 $G$ 中所有的置换是

$\pi_1 = (1)(2)(3)(4)$

$\pi_2 = (1234)$

$\pi_3 = (14)(23)$

$\pi_4 = (1432)$

$C(\pi_1) = 4 , C(\pi_2) = 1  , C(\pi_3) = 2 , C(\pi_4) = 1$

带入 Polya 定理

$ans = \frac{1}{4}*(2^4+2^1+2^2+2^1) = 6$

## 翻转
- 当 $n$ 为奇数时，只有一种形式，以顶点 $i$ 与中心的连线为轴的翻转  
$\pi_i=\begin{matrix}...&i-1&i&i+1&...\\...&i+1&i&i-1&...\end{matrix}$  
群阶等于 $n$，因为总共就n个元素。每个置换的轮换个数都等于 $(n+1)/2$ ，对照上式理解一下
- 当 n 为偶数时，有两种形式：
    - 以顶点 $i$ 与中心的连线为轴的翻转  
$\pi_i=\begin{matrix}...&i-1&i&i+1&...\\...&i+1&i&i-1&...\end{matrix}$  
群阶等于 $\frac n2$，因为对称性。每个置换的轮换个数都等于 $\frac n2+1$，对照上式理解一下
    - 以顶点 $i$ 和 $i+1$ 的中点与中心的连线为轴翻转  
$\pi_i=\begin{matrix}...&i-1&i&i+1&i+2&...\\...&i+2&i+1&i&i-1&...\end{matrix}$  
群阶等于 $\frac n2$，因为对称性。每个置换的轮换个数都等于 $\frac n2$，对照上式理解一下

应用polya定理：

$\begin{cases}m^{\frac{n+1}2}&n\ is\ odd\\\frac{m+1}2m^{\frac n2}&n\ is\ even\end{cases}$

## 板子
当同时考虑旋转和翻转：

$\frac{\sum\limits_{d|n}m^d\phi(\frac nd)+\begin{cases}nm^{\frac{n+1}2}&n\ is\ odd\\\frac{n(m+1)}2m^{\frac n2}&n\ is\ even\end{cases}}{2n}$

```c++
typedef long long ll;
ll fast_power(ll base,ll exponent)
{
    ll result=1;
    while(exponent>0)
    {
        if(exponent&1)
            result=result*base;
        base=base*base;
        exponent>>=1;
    }
    return result;
}
ll polya(ll n,ll m)
{
    if(!n)
        return 0;
    ll sum=0;
    for(ll i=0;i<n;++i)
        sum+=fast_power(m,__gcd(n,i));
    if(n&1)
        sum+=n*fast_power(m,(n+1)/2);
    else
        sum+=n/2*(1ll+m)*fast_power(m,n/2);
    sum/=(2*n);
    return sum;
}
```
# 线性代数
向量各分量元素值为 $[0,p-1]$ 的整数，一个已经确定的，秩为 $j$ 的 $n$ 维向量组，能线性组合成的两两不同的向量，有 $p^j$ 个
# 矩阵快速幂
## 时间复杂度
$O(t^3*log n)$,$t$ 是矩阵边长，$t^3$ 表示矩阵乘法
## 常见多项式抽象

1. $f(n) = a * f(n-1) + b * f(n-2) +c$

$\begin{pmatrix}a&b&1\\1&0&0\\0&0&1\end{pmatrix}*
\begin{pmatrix}f(n-1)\\f(n-2)\\c\end{pmatrix}=
\begin{pmatrix}f(n)\\f(n-1)\\c\end{pmatrix}$

2. $f(n) = f(n-1) + c^n$

$\begin{pmatrix}1&c\\0&c\end{pmatrix}*
\begin{pmatrix}f(n-1)\\c^{n-1}\end{pmatrix}=
\begin{pmatrix}f(n)\\c^{n}\end{pmatrix}$

3. $f(n)= f(n-1) + n^3$

因为

$n^3$

$= (n - 1 + 1)^3$

$= C(0,3)*(n-1)^3 + C(1,3)*(n-1)^2 + C(2,3)*(n-1)^1 + C(3,3)*(n-1)^0$

所以

$\begin{pmatrix}1&C(0,3)&C(1,3)&C(2,3)&C(3,3)\\
0&C(0,3)&C(1,3)&C(2,3)&C(3,3)\\
0&0&C(0,2)&C(1,2)&C(2,2)\\
0&0&0&C(0,1)&C(1,1)\\
0&0&0&0&C(0,0)\end{pmatrix}*
\begin{pmatrix}f(n-1)\\(n-1)^3\\(n-1)^2\\(n-1)^1\\(n-1)^0\end{pmatrix}=
\begin{pmatrix}f(n)\\n^3\\n^2\\n^1\\n^0\end{pmatrix}$
```c++
const int N = 4;
struct matrix
{
    ll m[N][N];
    void init()//单位矩阵
    {
        memset(m,0,sizeof(m));
        for(int i=0;i<N;++i)
            m[i][i]=1;
    }
    matrix operator*(matrix y)
    {
        matrix c;
        memset(c.m,0,sizeof(c.m));
        //稠密矩阵
        for(int i=0;i<N;++i)
        {
            for(int j=0;j<N;++j)
            {
                for(int k=0;k<N;++k)
                    c.m[i][j] = (c.m[i][j] + m[i][k] * y.m[k][j] % mod) % mod;
            }
        }
        //稀疏矩阵(指矩阵中很多数为0)
        for(int i=0;i<N;++i)
        {
            for(int j=0;j<N;++j)
            {
                if(!m[i][j])
                    continue;
                for(int k=0;k<N;++k)
                    c.m[i][k] = (c.m[i][k] + m[i][j] * y.m[j][k] % mod) % mod;
            }
        }
        return c;
    }
    matrix operator^(ll exponent)
    {
        matrix result;
        result.init();
        for(;exponent;exponent>>=1)
        {
            if(exponent&1)
                result = result*(*this);
            (*this) = (*this)*(*this);
        }
        return result;
    }
};
matrix base{1,1,1,2,
            0,1,1,2,
            0,1,0,0,
            0,1,0,1};
base=base^(n-2);
ll ans=(((base.m[0][0]*2%mod+base.m[0][1])%mod+base.m[0][2])%mod+base.m[0][3])%mod;
```
# 高斯消元
注意处理无解，无穷解情况

-1 无解，0 无穷解，1 唯一解
## 线性方程组
```c++
const int N=1e2+1;
const double eps=1e-6;
double a[N][N],ans[N];
int GaussianElimination(int n)
{
    int i,maxx,j,k,cnt=0;
    double temp;
    for(i=0;i<n;++i)
    {
        maxx=cnt;
        for(j=cnt+1;j<n;++j)
        {
            if(fabs(a[j][i])>fabs(a[maxx][i]))
                maxx=j;
        }
        if(fabs(a[maxx][i])<eps)
            continue;
        if(maxx!=cnt)
            swap(a[maxx],a[cnt]);
        for(j=0;j<n;++j)
        {
            if(j==cnt)
                continue;
            temp=a[j][i]/a[cnt][i];
            for(k=i+1;k<=n;++k)
                a[j][k]-=a[cnt][k]*temp;
        }
        ++cnt;
    }
    if(cnt<n)
    {
        for(;cnt<n;++cnt)
        {
            if(fabs(a[cnt][n])>eps)
                return -1;
        }
        return 0;
    }
    for(i=0;i<n;++i)
        ans[i]=a[i][n]/a[i][i];
    return 1;
}
```
## 矩阵求逆
```cpp
const int N=402,mod=1e9+7;
int a[N][N],ih[N],jh[N];//a,1-index
bool inverseMatrix(int n)
{
    for(int k=1;k<=n;++k)
    {
        for(int i=k;i<=n && !ih[k];++i)
        {
            for(int j=k;j<=n;++j)
            {
                if(!a[i][j])
                    continue;
                ih[k]=i;
                jh[k]=j;
                break;
            }
        }
        if(!ih[k])
            return false;
        for(int j=1;j<=n;++j)
            swap(a[k][j],a[ih[k]][j]);
        for(int i=1;i<=n;++i)
            swap(a[i][k],a[i][jh[k]]);
        if(!a[k][k])
            return false;
        a[k][k]=inv(a[k][k]);
        for(int i=1;i<=n;++i)
        {
            if(i!=k)
                a[k][i]=(ll)a[k][i]*a[k][k]%mod;
        }
        for(int i=1;i<=n;++i)
        {
            if(i==k)
                continue;
            for(int j=1;j<=n;++j)
            {
                if(j!=k)
                    a[i][j]=(a[i][j]+(ll)(mod-a[i][k])*a[k][j])%mod;
            }
        }
        for(int i=1;i<=n;++i)
        {
            if(i!=k)
                a[i][k]=(ll)(mod-a[i][k])*a[k][k]%mod;
        }
    }
    for(int k=n;k;--k)
    {
        for(int j=1;j<=n;++j)
            swap(a[k][j],a[jh[k]][j]);
        for(int i=1;i<=n;++i)
            swap(a[i][k],a[i][ih[k]]);
    }
    return true;
}
```
## 异或方程组
```c++
const int N=1e2+3;
bitset<N> a[N];
bitset<N> ans;
int GaussElimination(int n, int m)
{
    int i,j,cnt=0;
    for(i=0;i<n;++i)
    {
        for(j=cnt;j<m && !a[j][i];++j){}
        if(j==m)
            continue;
        if(j != cnt)
            swap(a[j], a[cnt]);
        for(j=0;j<m;j++)
        {
            if(cnt==j)
                continue;
            if(a[j][i])
                a[j]^=a[cnt];
        }
        ++cnt;
    }
    if(cnt<n)
    {
        for(;cnt<n;++cnt)
        {
            if(a[cnt][n])
                return -1;
        }
        return 0;
    }
    for (i = 0; i < n; i++)
        ans[i] = a[i][n];
    return 1;
}
```
## 行列式
```c++
const int N=1e2+1;
const double eps=1e-6;
double a[N][N];
double GaussianElimination(int n)
{
    int i,maxx,j,k;
    double temp,res=1;
    for(i=0;i<n;++i)
    {
        maxx=i;
        for(j=i+1;j<n;++j)
        {
            if(fabs(a[j][i])>fabs(a[maxx][i]))
                maxx=j;
        }
        if(fabs(a[maxx][i])<eps)
            return 0.0;
        if(maxx!=i)
        {
            swap(a[maxx],a[i]);
            res=-res;
        }
        res*=a[i][i];
        for(j=0;j<n;++j)
        {
            if(j==i)
                continue;
            temp=a[j][i]/a[i][i];
            if(fabs(temp)<eps)
                continue;
            for(k=i;k<=n;++k)
                a[j][k]-=a[i][k]*temp;
        }
    }
    return res;
}
```
# 线性基
1. 第k大异或和
2. 合法值是所有异或值的第几大
3. 是否可以线性表出某个值
4. 线性基合并
5. x和线性基的异或最小值
6. 1 到 n 的路径的最小异或和
7. 所有异或值的和
8. 带删线性基
## 线性表出
一个向量如果可以被其他向量通过运算表示，那么称这个向量可以被线性表出。

例如2维平面上的任意向量，都可以被(0,1),(1,0)这组向量通过矢量合成与放缩表示

在XCPC中，通常是一个数可以被其他数通过异或表示
## 线性相关&线性无关
如果向量组中有一个向量可以被向量组其他向量线性表出，那么称这个向量组线性相关，否则线性无关
## 极大线性无关组
线性相关可以理解为有多余的向量，删完之后，就是极大线性无关组
## 线性基
向量组的极大线性无关组就是线性基，简称基

一个向量组可以对应多个基，因此需要构造出一种合法基
### 性质
1. 原序列里的任意一个数都可以通过线性基中的一些数异或得到
2. 线性基里的任意一些数异或起来都不能得到 0
3. 每个序列的线性基的元素数量唯一，在性质一的前提下，有最少的数

序列里的元素相互异或一下，它的线性基不变

本构造得到的基，有2个性质：

1. 每个元素最高有效位各不相同

2. 如果某一位是一个元素的最高有效位，则其他元素在这一位均为 0
```cpp
typedef unsigned long long ull;
long long fast_power(long long base,long long exponent)
{
    long long result=1;
    for(;exponent>0;exponent>>=1)
    {
        if(exponent&1)
            result=result*base;
        base=base*base;
    }
    return result;
}
struct linearBasis
{
    vector<ull> B;
    int zero,cnt,tot;
    vector<int> rnk;
    void init()
    {
        B.clear();
        zero=tot=0;
    }
    void insert(ull x)
    {
        for (ull &b : B)
            x = min(x, b ^ x);
        for (ull &b : B)
            b = min(b, b ^ x);
        if (x)
            B.push_back(x);
        ++tot;
    }
    int msb(ull x)
    {
        return 63 - __builtin_clzll(x);
    }
    void init2()
    {
        sort(B.begin(),B.end());
        cnt=B.size();
        if(cnt<tot)
            zero=1;
        for(ull &b:B)
            rnk.push_back(msb(b));
    }
    ull kthxorsum(ull k)
    {
        k-=zero;
        ull ans=0;
        for(ull &b:B)
        {
            if(k&1)
                ans^=b;
            k>>=1;
        }
        return ans;
    }
    ull askrank(ull x)
    {
        ull ans=0;
        for (int i = 0; i < cnt; ++i)
        {
            if (x >> rnk[i] & 1)
                ans +=1<<i;
        }
        return ans*fast_power(2,tot-cnt)+1;
    }
    bool check(ull x)
    {
        for (ull &b : B)
            x = min(x, b ^ x);
        return (!x);
    }
    void merge(linearBasis &o)
    {
        for(ull &u:o.B)
            (*this).insert(u);
    }
    ull minXorSumWithX(ull x)
    {
        for (ull &b : B)
            x = min(x, b ^ x);
        return x;
    }
};
```
## 1 到 n 的路径的最小异或和
所有路径异或和，都可以由任意一条 1 到 n 路径的异或和与图中的一些环的异或和来组合得到。

从1先走到一个环，绕环一次，再原路返回，即可得到环的异或和，来路的异或和被抵消了。

A，B是两条1到n的路径，A，B组成环，如果A更优，走B前绕这个环一圈即可得到A的结果，所以是任意一条路径。

dfs搜出部分环，线性基自己可以解决环套环

最小异或和前面介绍过了
```cpp
typedef unsigned long long ull;
struct linearBasis
{
    vector<ull> B;
    void insert(ull x)
    {
        for (ull &b : B)
            x = min(x, b ^ x);
        for (ull &b : B)
            b = min(b, b ^ x);
        if (x)
            B.push_back(x);
    }
    ull minXorSumWithX(ull x)
    {
        for (ull &b : B)
            x = min(x, b ^ x);
        return x;
    }
}lb;
int vis[N],xorsum[N];
void dfs(int u,int sum)
{
    xorsum[u]=sum;
    vis[u]=1;
    for(auto &[v,w]:e[u])
    {
        if(vis[v])
            lb.insert(sum^w^xorsum[v]);
        else
            dfs(v,sum^w);
    }
}
dfs(1,0);
cout<<lb.minXorSumWithX(xorsum[n]);
```
# 多项式
# 生成函数
用一个函数来表示一个序列 $a_0,a_1,...,a_n$ ，假设是 $G(x)=\sum\limits_{i=0}^na_ix^i$，那么系数就表示了序列

由于只关心系数，自变量 $x$ 具体取值不重要，所以称这种函数为形式幂级数

$G(x)$ 是一个多项式。多项式有加减乘除，求逆，ln，exp等运算。下面用多项式乘法解决一些问题
## 普通生成函数
有三种物品，分别有3,2,3个，问拿出4个进行组合的方案数是多少

显然有背包做法，但是这里使用生成函数做

对每个物品构造一个多项式，$a_i$ 表示选了 $i$ 个物品的方案数

$G_1(x)=\sum\limits_{i=1}^3x^i$

$G_2(x)=\sum\limits_{i=1}^2x^i$

$G_3(x)=\sum\limits_{i=1}^3x^i$

先说结论：答案为 $G_1(x)*G_2(x)*G_3(x)$ 的第 4 项的系数(0-indexed)

考虑两个多项式相乘如何得到各个系数的，$a_k=\sum\limits_{i=0}^kf_ig_{k-i}$

这个过程实际上就是枚举第一种物品选了多少个，所以背包的过程就是模拟多项式乘法

形如 $G(x)=\sum\limits_{i=0}^na_ix^i$ 的多项式，称为普通生成函数
## 指数生成函数
普通生成函数解决组合问题，指数生成函数解决排列问题

有三种物品，分别有3,2,3个，问拿出4个进行排列的方案数是多少

背包可以做，但是这里使用生成函数做

先得到所有组合，再对每种组合计算多重集排列数，最后全部加起来

形如 $G(x)=\sum\limits_{i=0}^na_i\frac{x^i}{i!}$ 的多项式，称为指数生成函数

构造出 $G_1(x)=\sum\limits_{i=0}^3\frac{x^i}{i!}$

$G_2(x)=\sum\limits_{i=0}^2\frac{x^i}{i!}$

$G_3(x)=\sum\limits_{i=0}^3\frac{x^i}{i!}$

$G_1(x)*G_2(x)*G_3(x)=1+3x+\frac 92x^2+\frac {14}3x^3+\frac{35}{12}x^4+\frac{17}{12}x^5+\frac{35}{72}x^6+\frac{1}{9}x^7+\frac{1}{71}x^8$

先说结论：答案为 $\frac{35}{12}*(4!)=70$

$4!$ 就是4种不同物品排列数，$G(x)$ 的 $\frac{1}{i!}$ 相当于多重集排列数的分母
## 普通生成函数的推广
$\frac{1}{1-x}=\sum\limits_{i=0}^{\infty}x^i,x\in(-1,1)$
### 证明(必看，推式子要用)
$S=\sum\limits_{i=0}^{\infty}x^i$

$xS=\sum\limits_{i=1}^{\infty}x^i$

$S-xS=1$

$S=\frac{1}{1-x}$

---
因为是形式幂级数，所以函数定义域不为空即可，然后可以用上面这个代换式来得到序列

也可以通过递推公式得到通项公式，做法和证明类似

$\frac{1}{1-x}\rightarrow 1,1,1,...$

x替换成-x，$\frac{1}{1+x}\rightarrow 1,-1,1,-1,...$

x替换成2x，$\frac{1}{1-2x}\rightarrow 1,2,4,8,...$

x替换成 $x^2$，$\frac{1}{1-x^2}=1+x^2+x^4+...\rightarrow 1,0,1,0,1...$

分子乘2，$\frac{1}{1-x}\rightarrow 2,2,2,...$

分子乘 $x^3$，$\frac{1}{1-x}=x^3+x^4+x^5+...\rightarrow 0,0,0,1,1,1,...$

求导，$\frac{1}{(1-x)^2}=1+2x+3x^2+...\rightarrow 1,2,3,4,5,...$

对于任意多项式 $P(x),Q(x)$，生成函数 $\frac{P(x)}{Q(x)}$ 的展开式。先求出 $Q(x)=0$ 的根，把分母表示为 $\prod(1-p_ix)^{d_i}$ 的形式，然后把多余常系数乘到分子上

当对分母进行因式分解但有重根时，每有一个重根就要多一个分式

比如 $F(x)=\frac{1}{(1-x)(1-2x)^2}=\frac{c_1}{1-x}+\frac{c_2}{1-2x}+\frac{c_3}{(1-2x)^2}$

题目通常是先用代换式相乘，然后再展开为多项式求系数
## 广义二项式定理
$(x+y)^{\alpha}=\sum\limits_{i=0}^{\infty}\frac{\alpha^{\underline i}}{i!}x^{\alpha-i}y^i$
## 例题
一种物品最多选n个，就是普通生成函数只有前n+1项

一种物品必须选k的倍数个，也就是普通生成函数只有k的倍数项
## 指数生成函数的推广
$e^x=\sum\limits_{i=0}^{\infty}\frac{x^i}{i!}$
## 总结(快速查表)
$\sum\limits_{i=0}^nx^{ki}=\frac{1-x^{kn+k}}{1-x^k}$

$\sum\limits_{i=0}^n\dbinom nip^ix^i=(1+px)^n$

$\sum\limits_{i=0}^{\infty}x^{ki}=\frac 1{1-x^k}$

$\sum\limits_{i=0}^{\infty}p^ix^i=\frac 1{1-px}$

$\frac{1}{(1-x)^{n+1}}=\sum\limits_{i=0}^{\infty}\dbinom{n+i}{i}x^i$

$e^{px}=\sum\limits_{i=0}^{\infty}p^i\frac{x^i}{i!}$

$\ln{(1+x)}=\sum\limits_{i=1}^{\infty}(-1)^{i-1}\frac{x^i}{i}$

$-\ln{(1-x)}=\sum\limits_{i=1}^{\infty}\frac{x^i}{i}$

$\sin x=\sum\limits_{i=0}^{\infty}(-1)^i\frac{x^{2i+1}}{(2i+1)!}$

$\cos x=\sum\limits_{i=0}^{\infty}(-1)^i\frac{x^{2i}}{(2i)!}$

$\arcsin x=\sum\limits_{i=0}^{\infty}\frac{(2i)!}{4^i(i!)(2i+1)}x^{2i+1}$
## 指数生成函数中的多项式exp的组合意义
$exp\ G(x)$ 表示有标号元素划分为任意个无标号非空子集的总方案数

如果 $exp\ ⁡G(x)$ 好求，但是 $G(x)$不好求，我们可以对 $exp\ ⁡G(x)$做多项式 $\ln$，来求得 $G(x)$

如果 $G(x)$ 好求，但是 $exp\ ⁡G(x)$ 不好求，我们可以对 $G(x)$ 做多项式 $\exp$，来求得 $exp⁡\ G(x)$
# fft
```cpp
const int MAXN = 1e7 + 10;
const double Pi = acos(-1.0);
struct comp
{
    double x, y;
    comp (double xx = 0, double yy = 0) {x = xx, y = yy;}
    comp operator + (const comp b) const {return comp(x + b.x,y + b.y);}
    comp operator - (const comp b) const {return comp(x - b.x,y - b.y);}
    comp operator * (const comp b) const {return comp(x * b.x - y * b.y,x * b.y + y * b.x);}
} a[MAXN], b[MAXN];
int l, limit, r[MAXN];
int N,M;
void fft(comp *A, int type)
{
    for (int i = 0; i < limit; i++)//求出要迭代的序列
    {
        if (i < r[i])
            swap(A[i], A[r[i]]);
    }
    for (int mid = 1; mid < limit; mid <<= 1)//待合并区间的中点
    {
        comp Wn( cos(Pi / mid) , type * sin(Pi / mid) );//单位根
        for (int R = mid << 1, j = 0; j < limit; j += R)//R是区间的右端点，j表示前已经到哪个位置了
        {
            comp w(1, 0);//幂
            for (int k = 0; k < mid; k++, w = w * Wn)//枚举左半部分
            {
                comp x = A[j + k], y = w * A[j + mid + k];//蝴蝶效应
                A[j + k] = x + y;
                A[j + mid + k] = x - y;
            }
        }
    }
    if(type==-1)
    {
        for (int i = 0; i <= N + M; i++)
            a[i].x=(double)((int)(a[i].x / limit + 0.5));//四舍五入取整
    }
}
void init(int x)//x表示2个多项式相乘最多有几个单项式
{
    limit=1;
    l=-1;
    while (limit < x)
        limit <<= 1, l++;
    for (int i = 0; i < limit; i++)
        r[i] = ( r[i >> 1] >> 1 ) | ( (i & 1) << l );
}
init(N+M+1);
fft(a, 1);
fft(b, 1);
for (int i = 0; i < limit; i++)
    a[i] = a[i] * b[i];
fft(a, -1);
```
### 三次变两次优化
(a+bi)^2=a^2-b^2+2abi
所以把b放在虚部，答案是虚部/2，注意把fft除limit改成虚部

## 分治fft
```cpp
void solve(int l,int r,int logn)
{
    if(logn<=0) return;
    if(l>=n) return;
    int mid=(l+r)>>1,i;
    ll t=inv(r-l);
    solve(l,mid,logn-1); // 计算左区间
    calcrev(logn);
    memset(a+(r-l)/2,0,sizeof(ll)*(r-l)/2); // 拷贝左区间
    memcpy(a,f+l,sizeof(ll)*(r-l)/2); // 填充0
    memcpy(b,g,sizeof(ll)*(r-l)); // 拷贝g
    FFT(a,logn,0),FFT(b,logn,0); // 卷积
    for(i=0;i<r-l;i++) a[i]=a[i]*b[i]%kcz;
    FFT(a,logn,1);
    for(i=0;i<r-l;i++) a[i]=a[i]*t%kcz;
    for(i=(r-l)/2;i<r-l;i++)
        f[l+i]=(f[l+i]+a[i])%kcz; // 把卷积后的右半段的数加到f数组后半段
    solve(mid,r,logn-1); // 计算右区间
}
```

# ntt

```cpp
typedef long long ll;
const int MAXN = 3e6 + 10;
const int P = 998244353;
const int G = 3;
const int Gi = 332748118;//G在模P的逆元
int N, M, limit, l, r[MAXN];
ll a[MAXN], b[MAXN];
ll fastpow(ll a, ll k)
{
	ll base = 1;
	for(;k;k>>=1)
    {
		if(k & 1)
            base = (base * a ) % P;
		a = (a * a) % P;
	}
	return base % P;
}
void NTT(ll *A, int type)
{
	for(int i = 0; i < limit; i++)
    {
		if(i < r[i])
            swap(A[i], A[r[i]]);
    }
	for(int mid = 1; mid < limit; mid <<= 1)
    {
		ll Wn = fastpow( type == 1 ? G : Gi , (P - 1) / (mid << 1));
		for(int j = 0,R=mid<<1; j < limit; j +=R)
        {
			ll w = 1;
			for(int k = 0; k < mid; k++, w = (w * Wn) % P)
            {
				 int x = A[j + k], y = w * A[j + k + mid] % P;
				 A[j + k] = (x + y) % P,
				 A[j + k + mid] = (x - y + P) % P;
			}
		}
	}
    if(type==-1)
    {
        ll inv = fastpow(limit, P - 2);
        for(int i=N+M;i>=0;--i)
            A[i]=A[i]*inv%P;
    }
}
void init(int x)
{
    limit=1;
    l=-1;
    while(limit<x)
        limit<<=1,++l;
    for(int i=0;i<limit;++i)
        r[i]=(r[i>>1]>>1)|((i&1)<<l);
}
init(N+M+1);
NTT(a, 1);
NTT(b, 1);
for(int i = 0; i < limit; i++)
    a[i] = (a[i] * b[i]) % P;
NTT(a, -1);
```
## 拉格朗日插值
### 原版
$n$ 个不同点 $(x_i,y_i)$ 确定唯一 $n-1$ 次多项式 $g$

已知 $n$ 个点值，可以 $O(n^2)$ 预处理，$O(nlog(mod))$ 求出 $g(k)$

```cpp
const int N=2e3+3;
const ll mod=998244353;
struct lagrange
{
    int n;
    ll x[N],y[N],w[N];
    long long inv(long long base)
    {
        long long result=1,exponent=mod-2;
        for(;exponent>0;exponent>>=1)
        {
            if(exponent&1)
                result=result*base%mod;
            base=base*base%mod;
        }
        return result;
    }
    void init()
    {
        n=0;
    }
    void insert(ll xx,ll yy)
    {
        x[++n]=xx;
        y[n]=yy;
        ll s=1;
        for(int i=1;i<n;++i)
        {
            w[i]=w[i]*(x[i]-xx)%mod;
            s=s*(xx-x[i])%mod;
        }
        w[n]=s;
    }
    void init2()
    {
        for(int i=1;i<=n;++i)
            w[i]=y[i]*inv(w[i])%mod;
    }
    ll lag(ll k)
    {
        ll s=1;
        for(int i=1;i<=n;++i)
        {
            if(k==x[i])
                return y[i];
            s=s*(k-x[i])%mod;
        }
        ll ans=0;
        for(int i=1;i<=n;++i)
            ans=(ans+s*inv(k-x[i])%mod*w[i]%mod)%mod;
        return (ans+mod)%mod;
    }
}la;
la.init();
la.insert(x,y);
la.init2();
la.lag(k);
```
### 特化版
当给定点值 $x_i$ 连续，可以 $O(n)$ 预处理，$O(n)$ 求 $g(k)$

$g(n)=\sum\limits_{i=1}^{k}y_i\prod\limits_{j=1,j\ne i}^{k}\frac{n-j}{i-j}$

$g(n)=\sum\limits_{i=1}^{k}y_i\left(\prod\limits_{j=1,j\ne i}^{k}(i-j)\right)^{-1}\prod\limits_{j=1,j\ne i}^{k}(n-j)$

$g(n)=\sum\limits_{i=1}^{k}y_i\left(\prod\limits_{j=1}^{i-1}(i-j)\prod\limits_{j=i+1}^{k}(i-j)\right)^{-1}\prod\limits_{j=1}^{i-1}(n-j)\prod\limits_{j=i+1}^{k}(n-j)$

$g(n)=\sum\limits_{i=1}^{k}y_i\left(\prod\limits_{j=1}^{i-1}j\prod\limits_{j=i-k}^{-1}j\right)^{-1}\prod\limits_{j=1}^{i-1}(n-j)\prod\limits_{j=i+1}^{k}(n-j)$

$pre_i=\prod\limits_{j=1}^i(n-j)，suf_i=\prod\limits_{j=i}^k(n-j)$

$g(n)=\sum\limits_{i=1}^{k}y_i(-1)^{k-i}\left((i-1)!(k-i)!\right)^{-1}pre_{i-1}suf_{i+1}$
```cpp
const int N=1e6+3;
const ll mod=1e9+7;
long long fac[N],inv[N];
long long fast_power(long long base, long long exponent)
{
    long long result = 1;
    for (; exponent > 0; exponent >>= 1)
    {
        if (exponent & 1)
            result = result * base % mod;
        base = base * base % mod;
    }
    return result;
}
void getC()
{
    fac[0]=1;
    for(int i=1;i<N;++i)
        fac[i]=fac[i-1]*i%mod;
    inv[N-1]=fast_power(fac[N-1],mod-2);
    for(int i=N-1;i;--i)
        inv[i-1]=inv[i]*i%mod;
}
struct lagrange
{
    ll y[N],pre[N],suf[N];
    ll lag(ll m,int k)//g(m)，k个点
    {
        if(m<=k)
            return y[m];
        pre[0]=suf[k+1]=1;
        for(int i=1;i<k;++i)
            pre[i]=pre[i-1]*(m-i)%mod;
        for(int i=k;i>1;--i)
            suf[i]=suf[i+1]*(m-i)%mod;
        ll ans=0;
        for(int i=1;i<=k;++i)
            ans=(ans+y[i]*inv[i-1]%mod*inv[k-i]%mod*pre[i-1]%mod*suf[i+1]%mod*((k-i)&1?-1:1))%mod;
        return (ans+mod)%mod;
    }
}la;
la.y[i]=y;
la.lag(m,k);
```
# 高等数学
## 函数
### 有界性
$\forall x,f(x)\le MAX$，$MAX$ 称为上界

$\forall x,f(x)\ge MIN$，$MIN$ 称为下界

$\forall x,|f(x)|<=M$，$M$ 称为界
### 初等函数
1. 幂函数：$y=x^k$
2. 指数函数：$y=a^x$
3. 对数函数：$y=\log_a x$
4. 三角函数：$y=\sin x,\cos x,\tan x=\frac{\sin x}{\cos x},\cot x=\frac 1{\tan x},\sec x=\frac 1{\cos x},\csc x=\frac 1{\sin x}$
5. 反三角函数：$y=\arcsin x$ 等

由以上5种，基本初等函数，经过有限次的四则运算和有限次的函数复合，的函数为初等函数
## 函数的极限存在的充分必要条件
$x$ 从左侧趋于 $x_0$ 记作 $x\rightarrow x_0^-$，$x$ 从右侧趋于 $x_0$ 记作 $x\rightarrow x_0^+$

$\lim\limits_{x\rightarrow x_0^-}f(x)=A=\lim\limits_{x\rightarrow x_0^+}f(x)$
## 无穷小与无穷大
### 无穷小定义
如果函数 $\lim\limits_{x\rightarrow x_0或x\rightarrow \infty}f(x)=0$，那么称函数 $f(x)$ 为当 $x\rightarrow x_0或x\rightarrow \infty$ 时的无穷小
### 无穷大定义
如果函数 $\lim\limits_{x\rightarrow x_0或x\rightarrow \infty}f(x)=\infty$，那么称函数 $f(x)$ 为当 $x\rightarrow x_0或x\rightarrow \infty$ 时的无穷大
### 无穷大和无穷小的联系
在自变量的同一变化过程中，如果 $f(x)$ 为无穷大，那么 $\frac 1{f(x)}$ 为无穷小；

反之，如果 $f(x)$ 为无穷小，且 $f(x)\ne 0$，那么 $\frac 1{f(x)}$ 为无穷大；
## 极限运算法则
1. 有限个无穷小之和是无穷小
2. 有界函数与无穷小的乘积是无穷小
3. 有限个无穷小之积是无穷小
4. 四则运算，即 $\lim f(x)=A,\lim g(x)=B$  
$\lim[f(x)+g(x)]=\lim f(x)+\lim g(x)=A+B$  
$\lim[f(x)-g(x)]=\lim f(x)-\lim g(x)=A-B$  
$\lim[f(x)g(x)]=\lim f(x)\lim g(x)=AB$  
$\lim[\frac{f(x)}{g(x)}]=\frac {\lim f(x)}{\lim g(x)}=\frac AB$，且 $B\ne 0$
5. 4的推论，$c$ 为常数，$\lim[cf(x)]=c\lim f(x)$
6. 4的推论，$n$ 为正整数，$\lim[f(x)]^n=[\lim f(x)]^n$
7. 复合函数的极限运算法则，先求内层函数的极限，再把这个极限代回去求外层函数的极限
## 几个重要极限
1. $\lim\limits_{x\rightarrow 0}\frac {\sin x}{x}=1$
2. $\lim\limits_{x\rightarrow 0}\cos x=1$
3. $\lim\limits_{x\rightarrow\infty}\left(1+\frac 1x \right)^x=e$
## 无穷小的比较
### 常见等价无穷小
1. $\sin x\sim x$
2. $\tan x\sim x$
3. $1-\cos x\sim \frac 12 x^2$
4. $e^x-1\sim x$
5. $\ln(1+x)\sim x$
6. $\sqrt[n]{1+x}-1\sim\frac xn$
### 等价无穷小运算法则
设 $\alpha\sim\tilde\alpha,\beta\sim\tilde\beta$，且 $\lim\frac{\tilde\beta}{\tilde\alpha}$ 存在，则 $\lim\frac{\beta}{\alpha}=\lim\frac{\tilde\beta}{\tilde\alpha}$
## 函数的求导法则
1. 设 $u=u(x),v=v(x)$  
$[u+v]'=u'+v'$  
$[u-v]'=u'-v'$  
$[uv]'=u'v+uv'$  
$[\frac uv]'=\frac{u'v+uv'}{v^2}$，且 $v\ne 0$
2. 反函数的求导法则，即函数 $x=f(y)$，反函数 $y=f^{-1}(x)$  
$[f^{-1}(x)]'=\frac 1{f'(y)}$
3. 复合函数的求导法则，即 $y=f(u),u=g(x)$  
$[f(g(x))]'=f'(u)g'(x)$
## 基本初等函数的导数公式
1. $(x^k)'=kx^{k-1}$
2. $(a^x)'=a^x\ln a$
3. $(\log_a x)'=\frac 1{xln a}$
4. $(\sin x)'=\cos x$
5. $(\cos x)'=-\sin x$
6. $(\tan x)'=\sec^2 x$
7. $(\cot x)'=-\csc^2 x$
8. $(\sec x)'=\sec x\tan x$
9. $(\csc x)'=-\csc x\cot x$
10. $(\arcsin x)'=\frac 1{\sqrt{1-x^2}}$
11. $(\arccos x)'=-\frac 1{\sqrt{1-x^2}}$
12. $(\arctan x)'=\frac 1{1+x^2}$
13. $(arccot~x)'=-\frac 1{1+x^2}$
## 高阶导数
对导数再次求导，即可得更高阶导数
## 洛必达法则
对于 $\frac 00,\frac{\infty}{\infty}$ 型的极限的商，不能用“商的极限等于极限的商”这一法则，因此用洛必达法则，即

$\lim\frac{f(x)}{F(x)}=\lim\frac{f'(x)}{F'(x)}$
## 泰勒公式
用多项式近似表达函数，即

$f(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)$
## 题目

## [2021ICPC网络赛2G](https://pintia.cn/market/item/1442013218528759808)
Given $2n$ integers, $a_1,a_2,…,a_n,b_1,b_2,…,b_n,$ and an integer $t$. You need to calculate:

$\lim\limits_{x→0}\frac{\sum\limits_{i=1}^na_i\times ln(1+b_i\times x)}{x^t}$.
### Input
The first line consists of two integers $n,t$.

In the following $n$ lines, the $i$-th line consists of two integers $a_i,b_i$.

$1≤n≤100000,−100≤a_i,b_i≤100,0≤t≤5$.
### Output
Please output the result of this limit.

If the result is $\infty$, please output "infinity" (without quotes). And if the result is an integer, please output this integer directly. Otherwise, the answer must be $\frac ab$, such that $a$ and $b$ are coprime and $b≥2$, please output "$a/b$".
### Sample Input 1
```
2 2
1 1
1 -1
```
### Sample Output 1
```
-1
```
### Sample Input 2
```
2 1
1 1
1 -1
```
### Sample Output 2
```
0
```
### Sample Input 3
```
2 3
1 1
1 -1
```
### Sample Output 3
```
infinity
```
### Solution
$\lim\limits_{x→0}\frac{\sum\limits_{i=1}^na_i\times ln(1+b_i\times x)}{x^t}$

$\sum\limits_{i=1}^na_i\lim\limits_{x→0}\frac{ln(1+b_i\times x)}{x^t}$

直接对后半部分洛必达会发现洛1次之后就不是 $\frac 00$ 的形式，因此泰勒公式来近似后半部分

$f(x)=ln(1+b_i\times x)$

$f'(x)=\frac{b_i}{1+b_ix}$

$f''(x)=\frac{-b_i^2}{1+2b_ix+b_i^2x^2}$

$f'''(x)=\frac{2b_i^3+2b_i^4x}{1+4b_ix+6b_i^2x^2+4b_i^3x^3+b_i^4x^4}$

$f''''(x)=\frac{-6b_i^4-24b_i^5x-36b_i^6x^2-24b_i^7x^3-6b_i^8x^4}{(1+4b_ix+6b_i^2x^2+4b_i^3x^3+b_i^4x^4)^2}$

$f'''''(x)=...$

$x_0=0$

$f(x)=b_ix-\frac 12b_i^2x^2+\frac{1}{3}b_i^3x^3-\frac 1{4}b_i^4x^4+\frac 15b_i^5x^5+...$

$ans=\sum\limits_{i=1}^na_i\lim\limits_{x\to 0}\frac {f(x)}{x^t}$

$t=0,ans=0$

$t=1,ans=\sum\limits_{i=1}^na_ib_i$

$t=2,ans=\sum\limits_{i=1}^na_i\frac{-b_i^2}{2}$

$t=3,ans=\sum\limits_{i=1}^na_i\frac{b_i^3}{3}$

$t=4,ans=\sum\limits_{i=1}^na_i\frac{-b_i^4}{4}$

$...$

由于只有 $\frac 00$ 形式能一直洛，所以中间结果如果不是 $\frac 00$，那答案为 $\infty$
```cpp
ll g[7];
string solve(int n,int t)
{
    if(t==0)
        return "0";
    ll a,b;
    for(int i=0;i<n;++i)
    {
        cin>>a>>b;
        for(int j=1;j<=t;++j)
        {
            a*=b;
            if(j&1)
                g[j]+=a;
            else
                g[j]-=a;
        }
    }
    for(int i=1;i<t;++i)
    {
        if(g[i])
            return "infinity";
    }
    ll gc=__gcd(g[t],(ll)t);
    string ans=to_string(g[t]/gc);
    if(t!=gc)
        ans+=" "+to_string(t/gc);
    return ans;
}
```
## [2021ICPC昆明C](https://ac.nowcoder.com/acm/contest/32708/C)
There is an empty cup, and a dumb robot is going to fill it with $1$ liter of water.

For every turn, the robot will randomly select a real number $t$ between $0$ and $x$ ($x$ is a given number) and then fill the cup with $t$ liter of water. The robot will repeat it until the cup is full (at least $1$ liter of water has been filled).

You need to answer the expected number of turns the robot should fill.
### Input
The first line contains an integer $T(T\leq 10000)$, denoting the number of test cases.

In the following $T$ lines, each line contains a real number $x(0.05\leq x\leq 10^9)$, describing a test case.

It is guaranteed that $x$ contains no more than $3$ decimal places.
### Output
For each test case, output one line with a real number, denoting the expected number of turns.

Any answer with a relative or absolute error less than $10^{-4}$ will be accepted.
### Sample Input 1
```
2
0.3
1.5
```
### Sample Output 1
```
7.3332227396
1.9477340411
```
### Solution
设 $E(x)$ 为每次均匀随机走 $[0,a]$，达到大于等于 $x$ 的期望次数，由全期望公式

$$E(X)=\int_{-\infty}^{+\infty}xf(x)dx$$

由于是均匀分布，所以 $f(x)=\frac 1a$

抽到一个数t，因为希望刚刚好达到x，所以应该从E(x-t)转移过来，因此积分上下限改为x和max(0,x-a)

$$E(x)=1+\int_{max(0,x-a)}^x\frac{E(t)}adt$$

对两边求导

$$aE'(x)=E(x)-E(x-a)$$

### 定义近似计算
$$a\frac{f(x+\Delta x)-f(x)}{\Delta x}=f(x)-f(x-a)$$

$$f(x+\Delta x)=f(x)+\frac{\Delta x}a(f(x)-f(x-a))$$

$f(0)=1$ 表示无穷小期望为1，那么 $ans=f(1)$

由于是多组数据，原问题步长 $[0,a]$，大于等于1的期望步数，等价于，步长 $[0,1]$，大于等于 $\frac 1a$ 的期望步数，故上式改为

$$f(x+\Delta x)=f(x)+\Delta x(f(x)-f(x-1))$$

$ans=f(\frac 1a)$
```cpp
const int maxn = 1e5;
const double dx = 1.0 / maxn;
double f[maxn * 20 + 100];
void init()
{
    f[0] = 1;
    for(int i=0;i<maxn;++i)
        f[i + 1] = (dx+1) * f[i];
    for (int i = maxn; i < 20 * maxn + 99; i++)
        f[i + 1] = f[i] + dx * (f[i] - f[i - maxn]);
}
double solve(double x)
{
    return f[(int)(maxn / x)];
}
```
### 推精准式子
转化为步长为 $[0,1]$ 的问题

$$f'(x)=f(x)-f(x-1)$$

对 $x$ 范围分类讨论

---
当 $x\in(0,1],f(x-1)=0$

$f'(x)=f(x)$，满足这个式子，已知的有 $e^x$

所以，$f(x)=Ce^x$

当 $x\to 0^+$,$f(x)\to 1$，所以 $f(x)=e^x$

---
当 $x\in(1,2],f(x-1)=e^{x-1}$

$f'(x)=f(x)-e^{x-1}$，满足这个式子，嗯凑凑出 $-xe^{x-1}$

所以，$f(x)=-xe^{x-1}$

当 $x\to 1^-$,$f(x)\to e$，

由于连续性，$x\to 1^+$,$f(x)\to e$，

和 $f(1^+)=-1e^{1-1}$ 差了 $1+e$

因此补上一些东西使式子成立，而 $Ce^x$ 不影响式子成立

所以，$f(x)=Ce^x-xe^{x-1}=(1+\frac 1e)e^x-xe^{x-1}=e^x-(x-1)e^{x-1}$

---
当 $x\in(2,3],f(x-1)=e^{x-1}-(x-2)e^{x-2}$

$f'(x)=f(x)-(e^{x-1}-(x-2)e^{x-2})$，满足这个式子，嗯凑凑出 $-xe^{x-1}+\frac 12(x-2)^2e^{x-2}$

所以，$f(x)=-xe^{x-1}+\frac 12(x-2)^2e^{x-2}$

当 $x\to 2^-$,$f(x)\to e$，

由于连续性，$x\to 1^+$,$f(x)\to e^2-e$，

和 $f(2^+)=-2e^{2-1}$ 差了 $e^2+e$

因此补上一些东西使式子成立，而 $Ce^x$ 不影响式子成立

所以，$f(x)=Ce^x-xe^{x-1}+\frac 12(x-2)^2e^{x-2}=(1+\frac 1e)e^x-xe^{x-1}+\frac 12(x-2)^2e^{x-2}=e^x-(x-1)e^{x-1}+\frac 12(x-2)^2e^{x-2}$

---
仿照以上方法，发现规律，$x\in(k,k+1]$

$$f(x)=\sum\limits_{i=0}^k\frac{(-1)^i}{i!}(x-i)^ie^{x-i}$$

$ans=f(\frac 1a)$
```cpp
double solve(double x)
{
    x = 1 / x;
    double ans = 0, fac = 1;
    for (int i = 0; i < x; i++)
    {
        if (i & 1)
            ans -= fac * pow(x - i, i) * exp(x - i);
        else
            ans += fac * pow(x - i, i) * exp(x - i);
        fac /= (i + 1);
    }
    return ans;
}
```
## [2022ICPC沈阳A](https://codeforces.com/gym/104160/problem/A)
Both Alice and Bob have a set of real numbers, and both sets are the union of some disjoint closed
intervals. They will independently pick a real number uniformly at random from their own set, and you
need to calculate the expected absolute difference between the two real numbers.

More formally, given a set of real numbers $S=\cup
[l,r]$ , picking a real number $x$ from the set $S$ uniformly
at random means that $P(x \in [l1, r1]) = P(x \in [l2, r2])$ holds for any two intervals $[l1, r1], [l2, r2]  \subseteq S$ with the same length, i.e., $r1 − l1 = r2 − l2$.
### Input
The first line contains two integers $n$ and $m (1 ≤ n, m ≤ 10^5)$, the number of intervals that form Alice’s
set and Bob’s set respectively.

Each of the following $n + m$ lines contains two integers $l$ and $r (−10^9 ≤ l ≤ r ≤ 10^9)$, describing a closed interval $[l, r]$. The first $n$ intervals form Alice’s set and the next $m$ intervals form Bob’s set. Note that an interval $[l, r]$ with $l = r$ is a degenerate interval that contains a single real number.

It is guaranteed that the intervals that form someone’s set are pairwise disjoint.
### Output
Output a single real number, indicating the expected absolute difference of the two real numbers picked
by Alice and Bob separately.

Your answer is acceptable if its absolute or relative error does not exceed $10^{−9}$. Formally speaking, suppose
that your output is $a$ and the jury’s answer is $b$, your output is accepted if and only if $\frac{|a−b|}{
max(1,|b|)} ≤ 10^{−9}$.
### Sample Input 1
```
1 1
0 1
0 1
```
### Sample Output 1
```
0.333333333333333
```
### Sample Input 2
```
1 1
0 1
1 1
```
### Sample Output 2
```
0.5
```
### Note
In the first sample case, both Alice and Bob can pick any real number from $[0, 1]$, and the expected
absolute difference is $\int_0^1\int_0^1 |x − y| dx dy =\frac 13$.

In the second sample case, Alice can pick any real number from $[0, 1]$ while Bob can only pick 1, and
therefore the expected absolute difference is $\int_0^1 |x − 1| dx =\frac 12$.
### Solution
先复习一下二重积分，以样例1为例

$\begin{aligned}\int_0^1\int_0^1 |x − y| dx dy &=\int_0^1\int_0^x (x − y) dx dy+\int_0^1\int_x^1 (y − x) dx dy\\&=\int_0^1[xy-\frac 12y^2]_0^x dx+\int_0^1[\frac 12y^2-xy]_x^1 dx\\&=\int_0^1(\frac 12x^2) dx+\int_0^1(\frac 12-x+\frac 12x^2) dx\\&=[\frac 16x^3]_0^1+[\frac 12x-\frac 12x^2+\frac 16x^3]_0^1\\&=\frac 16+\frac 12-\frac 12+\frac 16\\&=\frac 13\end{aligned}$

当两个积分区间不相交：

$\int_{l_1}^{r_1}\int_{l_2}^{r_2}|x-y|dxdy,l_1<r_1<l_2<r_2$

$\begin{aligned}\int_{l_1}^{r_1}\int_{l_2}^{r_2}|x-y|dxdy&=\int_{l_1}^{r_1}[\frac 12y^2-xy]_{l_2}^{r_2}dx\\&=\int_{l_1}^{r_1}[\frac 12(r_2^2-l_2^2)-x(r_2-l_2)]dx\\&=[\frac 12(r_2^2-l_2^2)x-\frac 12x^2(r_2-l_2)]_{l_1}^{r_1}\\&=\frac 12(r_2^2-l_2^2)(r_1-l_1)-\frac 12(r_1^2-l_1^2)(r_2-l_2)\\&=\frac 12(r_2-l_2)(r_1-l_1)(r_2+l_2-r_1-l_1)\end{aligned}$

当两个积分区间相交，可以拆分成重叠的区间和不相交的区间，这样可以复用上面结论

重叠：

$\begin{aligned}\int_l^r\int_l^r |x − y| dx dy &=\int_l^r\int_l^x (x − y) dx dy+\int_l^r\int_x^r (y − x) dx dy\\&=\int_l^r[xy-\frac 12y^2]_l^x dx+\int_l^r[\frac 12y^2-xy]_x^r dx\\&=\int_l^r[\frac 12x^2-lx+\frac 12l^2] dx+\int_l^r[\frac 12r^2-rx+\frac 12x^2]dx\\&=[\frac 16x^3-\frac 12lx^2+\frac 12l^2x]_l^r+[\frac 12r^2x-\frac 12rx^2+\frac 16x^3]_l^r\\&=\frac 13(r^3-l^3)-lr(r-l)\end{aligned}$

当一个区间退化成点，而集合里的其他区间没退化成点，那这个区间不会被选到，因为连续性变量选到一个值的概率为0(其实是无穷小)

而集合里的所有区间退化成点，那么当作离散型变量考虑

因此可以写出离散型对离散型，连续型对连续型，离散型对连续型三种情况的代码

>因为重叠部分的计算有3次方，而值域1e9，三次方之后就是1e27，long long 会溢出，因此需要__int128_t  
>下面代码离散型对离散型用前缀和优化为 $O(n\log m)$，离散型对连续性用前缀和优化为 $O(m\log n)$，连续性对连续型为 $O(nm)$  
>对于连续型对连续型，先考虑正确性，再从正确性的基础上考虑优化
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long double ld;
const int N = 1e5 + 5;
array<ld, 2> a[N], b[N];
ld pre[N],squarePre[N];
int n, m;
ld cal1(ld l1, ld r1, ld l2, ld r2)
{
    ld t1 = l1 + r1, t2 = l2 + r2;
    if (t1 < t2)
        return (ld)((r1 - l1) * (r2 - l2) * (t2 - t1)) / 2.0L;
    return (ld)((r1 - l1) * (r2 - l2) * (t1 - t2)) / 2.0L;
}
ld cal2(ld l, ld r)
{
    return (ld)(r * r * r - l * l * l) / 3.0L - l * r * (r - l);
}
ld discreteWithdiscrete()
{
    pre[0] = 0;
    for (int i = 1; i <= m; ++i)
        pre[i] = pre[i - 1] + b[i][0];
    ld ans = 0;
    for (int i = 1; i <= n; ++i)
    {
        int pos = upper_bound(b + 1, b + m + 1, a[i]) - b;
        assert(pos != 0);
        ans += (ld)(pos - 1) * a[i][0] - pre[pos - 1];
        ans += pre[m] - pre[pos - 1] - (m - pos + 1) * a[i][0];
    }
    return ans;
}
ld discreteWithcontinuous()
{
    pre[0]=0;
    for(int i=1;i<=n;++i)
        pre[i]=pre[i-1]+a[i][0];
    squarePre[0]=0;
    for(int i=1;i<=n;++i)
        squarePre[i]=squarePre[i-1]+a[i][0]*a[i][0];
    ld ans = 0;
    for(int i=1;i<=m;++i)
    {
        if(b[i][0]==b[i][1])
            continue;
        ld l=b[i][0],r=b[i][1];
        int pos1=lower_bound(a+1,a+n+1,b[i])-a-1;
        int pos2=upper_bound(a+1,a+n+1,array<ld,2>{r,0})-a-1;
        ans+=((r*r-l*l)/2.0L)*(ld)pos1-pre[pos1]*(r-l);
        ans+=(pre[n]-pre[pos2])*(r-l)-((r*r-l*l)/2.0L)*(ld)(n-pos2);
        ans+=((l*l+r*r)/2.0L)*(ld)(pos2-pos1)-(pre[pos2]-pre[pos1])*(l+r)+(squarePre[pos2]-squarePre[pos1]);
    }
    return ans;
}
ld continuousWithcontinuous()
{
    ld ans = 0;
    for (int i = 1; i <= n; ++i)
    {
        if (a[i][0] == a[i][1])
            continue;
        for (int j = 1; j <= m; ++j)
        {
            if (b[j][0] == b[j][1])
                continue;
            ld l = max(a[i][0], b[j][0]), r = min(a[i][1], b[j][1]);
            if (l >= r)
                ans += cal1(a[i][0], a[i][1], b[j][0], b[j][1]);
            else
            {
                ans += cal2(l, r);
                if (a[i][1] > b[j][1])
                    ans += cal1(b[j][1], a[i][1], b[j][0], b[j][1]);
                else if (b[j][1] > a[i][1])
                    ans += cal1(a[i][1], b[j][1], a[i][0], a[i][1]);
                if (a[i][0] > b[j][0])
                    ans += cal1(b[j][0], a[i][0], a[i][0], r);
                else if (b[j][0] > a[i][0])
                    ans += cal1(a[i][0], b[j][0], b[j][0], r);
            }
        }
    }
    return ans;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    ld sum1 = 0, sum2 = 0;
    for (int i = 1; i <= n; ++i)
    {
        int l, r;
        cin >> l >> r;
        a[i] = {l, r};
        sum1 += r - l;
    }
    for (int i = 1; i <= m; ++i)
    {
        int l, r;
        cin >> l >> r;
        b[i] = {l, r};
        sum2 += r - l;
    }
    sort(a + 1, a + n + 1);
    sort(b + 1, b + m + 1);
    cout << fixed << setprecision(12);
    if (sum1 == 0 && sum2 == 0)
        cout << discreteWithdiscrete() / (ld)n / (ld)m;
    else if (sum1 && sum2)
        cout << continuousWithcontinuous() / (ld)sum1 / (ld)sum2;
    else
    {
        if (sum1)
        {
            swap(a, b);
            swap(n, m);
            swap(sum1, sum2);
        }
        cout << discreteWithcontinuous() / (ld)n / (ld)sum2;
    }
    return 0;
}
```
设Alice的集合为A，Bob的集合为B，可以证明：AB中各取一个区间作为一对，满足区间相交，总对数是 $O(n)$ 级别的

首先AB各自内的区间不相交，所以A一个内区间和B内多个区间相交，B内区间一定是连续的

如果 $A_i$ 和 $B_j,B_{j+1},B_{j+2},...,B_{j+k}$ 相交，那么只有 $B_j,B_{j+k}$ 这两个区间可能会与 A 的其他区间相交

那么使对数最多的构造类似于 $A:(1,3),(4,7),(8,11)...\ B:(2,5),(6,9),(10,13)...$

而这样的构造，对数是 $O(n)$ 级别，因此可以双指针优化

此外，为了避免精度丢失，前面用int128存，最后除掉分母
```cpp
#include <iostream>
#include <array>
#include <algorithm>
#include <iomanip>
using namespace std;
typedef __int128_t ll;
typedef long double ld;
const int N = 1e5 + 5;
array<ll, 2> a[N], b[N];
ll pre[N], squarePre[N];
ll cal1(ll l1, ll r1, ll l2, ll r2)
{
    ll t1 = l1 + r1, t2 = l2 + r2;
    if (t1 > t2)
        swap(t1,t2);
    return ((r1 - l1) * (r2 - l2) * (t2 - t1))*3ll;
}
ll discreteWithdiscrete(int n, int m)
{
    pre[0] = 0;
    for (int i = 1; i <= m; ++i)
        pre[i] = pre[i - 1] + b[i][0];
    ll ans = 0;
    for (int i = 1; i <= n; ++i)
    {
        int pos = upper_bound(b + 1, b + m + 1, a[i]) - b;
        ans += (ll)(pos - 1) * a[i][0] - pre[pos - 1];
        ans += pre[m] - pre[pos - 1] - (ll)(m - pos + 1) * a[i][0];
    }
    return ans;
}
ld discreteWithcontinuous(int n, int m)
{
    pre[0] = 0;
    for (int i = 1; i <= n; ++i)
        pre[i] = pre[i - 1] + a[i][0];
    squarePre[0] = 0;
    for (int i = 1; i <= n; ++i)
        squarePre[i] = squarePre[i - 1] + a[i][0] * a[i][0];
    ll ans = 0;
    for (int i = 1; i <= m; ++i)
    {
        ll l = b[i][0], r = b[i][1];
        int pos1 = lower_bound(a + 1, a + n + 1, array<ll, 2>{l, l}) - a - 1;
        int pos2 = upper_bound(a + 1, a + n + 1, array<ll, 2>{r, r}) - a - 1;
        ans += (r * r - l * l) * (ll)pos1 - pre[pos1] * (r - l)*2ll;
        ans += (pre[n] - pre[pos2]) * (r - l)*2ll - (r * r - l * l) * (ll)(n - pos2);
        ans += (l * l + r * r) * (ll)(pos2 - pos1) - (pre[pos2] - pre[pos1]) * (l + r)*2ll + (squarePre[pos2] - squarePre[pos1])*2ll;
    }
    return (ld)ans/2.0L;
}
ld continuousWithcontinuous(int n, int m)
{
    pre[0] = 0;
    for (int i = 1; i <= m; ++i)
        pre[i] = pre[i - 1] + b[i][1] - b[i][0];
    squarePre[0] = 0;
    for (int i = 1; i <= m; ++i)
        squarePre[i] = squarePre[i - 1] + b[i][1] * b[i][1] - b[i][0] * b[i][0];
    __int128_t ans = 0,ans2=0;
    for (int i = 1, j = 1; i <= n; ++i, j -= (j > 1))
    {
        __int128_t l = a[i][0], r = a[i][1];
        while (j <= m && b[j][1] <= l)
            ++j;
        ans += pre[j - 1] * (r * r - l * l) - squarePre[j - 1] * (r - l);
        for (; j <= m && b[j][0] < r; ++j)
        {
            ll L = max(l, b[j][0]), R = min(r, b[j][1]);
            ans2 += (R * R * R- L* L * L)*2ll - L * R * (R- L)*6ll;
            if (r > b[j][1])
                ans2 += cal1(b[j][1], r, b[j][0], b[j][1]);
            else if (b[j][1] > r)
                ans2 += cal1(r, b[j][1], l, r);
            if (l > b[j][0])
                ans2 += cal1(b[j][0], l, l, R);
            else if (b[j][0] > l)
                ans2 += cal1(l, b[j][0], b[j][0], R);
        }
        if (j > m)
            continue;
        ans += (squarePre[m] - squarePre[j - 1]) * (r - l) - (pre[m] - pre[j - 1]) * (r * r - l * l);
    }
    return (ld)((ld)ans/2.0L+(ld)ans2/6ll);
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n, m;
    cin >> n >> m;
    ll sum1 = 0, sum2 = 0;
    for (int i = 1; i <= n; ++i)
    {
        int l, r;
        cin >> l >> r;
        a[i] = {(ll)l, (ll)r};
        sum1 += r - l;
    }
    for (int i = 1; i <= m; ++i)
    {
        int l, r;
        cin >> l >> r;
        b[i] = {(ll)l, (ll)r};
        sum2 += r - l;
    }
    sort(a + 1, a + n + 1);
    sort(b + 1, b + m + 1);
    if(sum1)
    {
        int j = 0;
        for (int i = 1; i <= n; ++i)
        {
            if (a[i][0] == a[i][1])
                continue;
            a[++j] = a[i];
        }
        n = j;
    }
    if(sum2)
    {
        int j = 0;
        for (int i = 1; i <= m; ++i)
        {
            if (b[i][0] == b[i][1])
                continue;
            b[++j] = b[i];
        }
        m = j;
    }
    cout << fixed << setprecision(12);
    if (sum1 == 0 && sum2 == 0)
        cout << (ld)discreteWithdiscrete(n, m) / (ld)n / (ld)m;
    else if (sum1 && sum2)
        cout << (ld)continuousWithcontinuous(n, m)/(ld)sum1/(ld)sum2;
    else
    {
        if (sum1)
        {
            swap(a, b);
            swap(n, m);
            swap(sum1, sum2);
        }
        cout << (ld)discreteWithcontinuous(n, m) / (ld)n / (ld)sum2;
    }
    return 0;
}
```
# 数学杂
## 线性回归

一堆点 $(x_i,y_i)$ ，求一条直线 $F(x):y=Ax+B$ ，使得 $\sum\limits_{i=1}^n (y_i-F(x_i))^2$ 最小

设 $\overline{x}=\frac{\sum\limits_{i=1}^n x_i}n$ ， $\overline{y}=\frac{\sum\limits_{i=1}^n y_i}n$

$A=\frac{\sum\limits_{i=1}^n x_iy_i-n\overline{x} \overline{y}}{\sum\limits_{i=1}^n x_i^2-n\overline{x}^2}$

$B=\overline{y}-A\overline{x}$

## 自然数幂和
$\sum\limits_{i=1}^n i=n(n+1)/2$

$\sum\limits_{i=1}^n i^2=n(n+1)(2n+1)/6$

$\sum\limits_{i=1}^n i^3=n^2(n+1)^2/4$

$\sum\limits_{i=1}^n i^4=n(n+1)(6n^3+9n^2+n-1)/30$

$\sum\limits_{i=1}^n i^5=n^2(n+1)(2n^3+4n^2+n-1)/12$

## 递推式推导

设 $f_n^p=\sum\limits_{i=1}^n i^{p}$

$(n+1)^p-n^p=C_p^1n^{p-1}+C_p^2n^{p-2}+...+1$

$\sum\limits_{n=1}^m(n+1)^p-n^p=\sum\limits_{n=1}^mC_p^1n^{p-1}+C_p^2n^{p-2}+...+1$

$(m+1)^p-1=C_p^1f_m^{p-1}+C_p^2f_m^{p-2}+...+m$

$f_m^{p-1}=((m+1)^p-1-(C_p^2f_m^{p-2}+...+m))/C_p^1$

$f_m^{p}=((m+1)^{p+1}-1-(C_{p+1}^2f_m^{p-1}+...+m))/(p+1)$
## 求法
### 拉格朗日插值
如果有取模，那么模数必须质数

自然数k次幂和是k+1次函数，求前k+2个点的点值，插就完了
```cpp
const int N=1e6+3;
const ll mod=1e9+7;
long long fac[N],inv[N];
long long fast_power(long long base, long long exponent)
{
    long long result = 1;
    for (; exponent > 0; exponent >>= 1)
    {
        if (exponent & 1)
            result = result * base % mod;
        base = base * base % mod;
    }
    return result;
}
void getC()
{
    fac[0]=1;
    for(int i=1;i<N;++i)
        fac[i]=fac[i-1]*i%mod;
    inv[N-1]=fast_power(fac[N-1],mod-2);
    for(int i=N-1;i;--i)
        inv[i-1]=inv[i]*i%mod;
}
struct lagrange
{
    ll y[N],pre[N],suf[N];
    ll lag(ll m,int k)//g(m)，k个点
    {
        if(m<=k)
            return y[m];
        pre[0]=suf[k+1]=1;
        for(int i=1;i<k;++i)
            pre[i]=pre[i-1]*(m-i)%mod;
        for(int i=k;i>1;--i)
            suf[i]=suf[i+1]*(m-i)%mod;
        ll ans=0;
        for(int i=1;i<=k;++i)
            ans=(ans+y[i]*inv[i-1]%mod*inv[k-i]%mod*pre[i-1]%mod*suf[i+1]%mod*((k-i)&1?-1:1))%mod;
        return (ans+mod)%mod;
    }
}la;
getC();
for(int i=1;i<=k+2;++i)
    la.y[i]=(la.y[i-1]+fast_power(i,k))%mod;
cout<<la.lag(n,k+2);
```
### 第2类斯特林数
不需要逆元

$\sum\limits_{i=1}^ni^k=\sum\limits_{j=0}^{k}S_2(k,j)\frac{(n+1)^{\underline{j+1}}}{j+1}$
```cpp
struct powersum
{
    int k;
    ll s[K][K];
    void init(int kk)
    {
        k=kk;
	    s[0][0]=1;
	    for(int i=1;i<=k;++i)
		    for(ll j=1;j<=i;++j)
			    s[i][j]=s[i-1][j-1]+j*s[i-1][j];
    }
    ll cal(ll n)
    {
        ll res,ans=0;
        for(ll i=0;i<=k;++i)
        {
            res=s[k][i];
            for(ll j=0;j<=i;++j)
            {
                if((n+1-j)%(i+1))
                    res=res*(n+1-j);
                else
                    res=res*((n+1-j)/(i+1));
            }
            ans=ans+res;
        }
        return ans;
    }
};
```
## 调和级数近似公式

n 很大时

$f_n\approx \ln n+0.5772156649+\frac 1{2n}$

```cpp
log(n)+0.5772156649+1.0/(2*n)
```
## 狄利克雷前后缀
$O(n\log\log n)$

原缀已知 $a$，求 $b$

逆缀已知 $b$，求 $a$

答案保存在原数组上
## 狄利克雷前缀
$b_n=\sum\limits_{d|n}a_d$
```cpp
for(int i=1;i<=cnt && primes[i]<=n;++i)
{
    for(int j=1;j*primes[i]<=n;++j)
        a[j*primes[i]]+=a[j];
}
```
## 狄利克雷后缀
$b_d=\sum\limits_{d|n}a_n$
```cpp
for(int i=1;i<=cnt && primes[i]<=n;++i)
{
    for(int j=n/primes[i];j;--j)
        a[j]+=a[j*primes[i]];
}
```
## 逆狄利克雷前缀
$b_n=\sum\limits_{d|n}a_d$
```cpp
for(int i=cnt;i;--i)
{
    for(int j=n/primes[i];j;--j)
        a[j*primes[i]]-=a[j];
}
```
## 逆狄利克雷后缀
$b_d=\sum\limits_{d|n}a_n$
```cpp
for(int i=cnt;i;--i)
{
    for(int j=1;j*primes[i]<=n;++j)
        a[j]-=a[j*primes[i]];
}
```
```cpp
const long long N=1e18+1;
const long long N=1e18+(long double)1;
```
上面这个会丢精度，需要改成下面那个

---
n以内两点互质连边，连到m条边停止，可以两层循环，复杂度是 $O(min(n^2,m) log n)$ ，因为互质的还蛮多的

## Fibonacci数
$gcd(F_n,F_m)=F_{gcd(n,m)}$

$\sum\limits_{i=0}^n F_i=F_{n+2}-1$

模m意义下，循环节长度小于等于6m
## 最大质因子个数和最大因子个数
$n\le$|$10^1$|$10^2$|$10^3$|$10^4$|$10^5$|$10^6$|$10^7$|$10^8$|$10^9$|
---|---|---|---|---|---|---|---|---|---
$max\{w(n)\}$|2|3|4|5|6|7|8|8|9
$max\{d(n)\}$|4|12|32|64|128|240|448|768|1344

$n\le$|$10^{10}$|$10^{11}$|$10^{12}$|$10^{13}$|$10^{14}$|$10^{15}$|$10^{16}$|$10^{17}$|$10^{18}$|
---|---|---|---|---|---|---|---|---|---
$max\{w(n)\}$|10|10|11|12|12|13|13|14|15
$max\{d(n)\}$|2304|4032|6720|10752|17280|26880|41472|64512|103680
