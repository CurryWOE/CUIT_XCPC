- 概率论
- 博弈论
- 组合数学
  - 导读
  - 组合数取模
  - 球盒问题
  - 容斥原理
  - 卡特兰数高精
  - 二项式反演
  - 斯特林数
- 群论
  - polya定理
- 线性代数
  - 矩阵快速幂
  - 高斯消元
  - 线性基
- 多项式
  - fft
  - ntt
  - 拉格朗日插值
- 高数
- 杂

# 概率论

计算某个事件的概率和期望

当概率论和 DP 复合时，问题转化为图上问题，状态看成点，状态转移看成边

如果该问题无后效性，那么按照拓扑序 DP，否则高斯消元

如果纯概率论题，套公式即可

## 简要概念&公式

### 随机变量

值无法预先确定，仅以一定可能性取值的量

按照值的数量分为

离散型，值数量有限

连续型，值数量无限

> 以下按照这个分类讲述

### 连续型概率

$$\forall a，P(X=a)=0$$
设随机变量 $X$，设密度函数 $f$
$$P(a<X\le b)=\int_{a}^bf(x)dx$$
密度满足
$$\int_{-\infty}^{+\infty}f(x)dx=1$$
分布函数$F(x)$
$$F(x)=P(X\le x)=\int_{-\infty}^xf(x)dx$$
若$F(x)$处处连续可微，则
$$F'(x)=f(x)$$

### 分布函数性质

1. $F(-\infty)=0，F(+\infty)=1$
2. $F(x)$ 单调非递减

### 离散型概率

发生事件 $A$ 的概率，记做 $P(A)$

加法公式
$$P(A\cup B)=P(A)+P(B)-P(A\cap B)$$
$P(A\cup B)$ 表示发生 A 或 B 的概率

$P(A\cap B)$ 表示同时发生 A 和 B 的概率，以下简写为 $P(AB)$

条件概率
$$P(B|A)=\frac{P(AB)}{P(A)}$$
$P(B|A)$ 表示已经发生 $A$，再发生 $B$ 的概率

乘法公式
$$P(AB)=P(A)P(B|A)=P(B)P(A|B)$$

全概率公式
$$P(B)=\sum\limits_{i=1}^nP(A_i)P(B|A_i)$$

贝叶斯公式
$$P(B_i|A)=\frac{P(B_i)P(A|B_i)}{\sum\limits_{j=1}^nP(B_j)P(A|B_j)}$$

### 连续型期望

$$E(X)=\int_{-\infty}^{+\infty}xf(x)dx$$

### 离散型期望

$$E(X)=\sum\limits_{i=1}^nx_iP_i$$

### 期望性质

全期望公式
$$E(Y)=\sum P(X=a)E(Y|X=a)$$
期望的线性性
$$E(aX+b)=aE(x)+b$$
$$E(X+Y)=E(X)+E(Y)$$
若 $X，Y$ 独立，则
$$E(XY)=E(X)E(Y)$$
独立：$P(AB)=P(A)P(B)$

## 概率 DP

根据全概率公式，设点 $v$ 的入边的另一个点 $u$
$$P(v)=\sum P(u)P(v|u)$$

## 期望 DP

### 递推公式

$P(X)，E(X)$ 表示$X$ 到终点的概率，期望

如果有自环，需要移项使得两边没有同样的式子

需要建反图跑 DP

（统计出边）
$$E(Y)=\sum [E(X)+W(Y\rightarrow X)P(Y)]P(X|Y)$$

## 期望和概率的一个联系

全集有 n 种数，手上有 i 种数，全集中随机选数

获得新数的概率是 $\frac {n-i}n$

取得新数要取的次数的期望为 $\frac 1p=\frac n{n-i}$

那么获得全集的次数为 $\sum\limits_{i=0}^{n-1} \frac n{n-i}=\sum\limits_{i=1}^{n-1} \frac ni$

Q:为什么期望是概率分之一

A:如果你平均取 n 个球才会出现 1 个红球，也就是说期望是 n，那又可以说成是平均每 n 个球中出现 1 个红球，所以概率是 $\frac{1}{n}$

也可以用 DP 解释

设 $f_i$ 表示已取到 i 种数，还需要取的次数的期望

可得 $f_{i}=f_{i+1}\times \frac {n-i}n+f_{i}\times \frac {i}n+1$

可得 $f_{i}=f_{i+1}+\frac n{n-i}$

## min-max 容斥计算期望

$$max(S)=\sum\limits_{T\subseteq S}min(T)(-1)^{|T|-1}$$
max 表示满足所有条件的期望，min 表示满足至少一个条件的期望
# 博弈论导读
* 两名选手，交替进行预先规定好的操作
* 在任何情况下，合法操作只取决于情况本身，与选手无关
* 游戏失败的最终判定往往是选手无法进行合法操作了

>下文中，必胜必败指的都是先手

常见结论和SG函数打表
## Bash博弈
一堆n个物品，可取出1~m个，最后取光者胜

同余定理：n=k∗(m+1)+r，先者拿走r个，那么后者无论拿走1~m个，先者只要使数目和为m+1的倍数，那么必胜。反之后手可以复制操作，必败
## Fibonacci Nim博弈
一堆n个物品，先取者第一次可以去任意多个，但是不能取完，以后每次取的石子数不能超过上次取子数的2倍。取完者胜。

n不是斐波那契数，必胜
## Whthoff博弈
两堆各若干物品，从任意一堆中至少取出一个或者从两堆中取出同样多的物品，规定每次至少取一个，至多不限，最后取光者胜。

这里的必输局势：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。

从这些必输局势可以发现，每组的第一个是前面没有出现的最小正整数

ak=[k∗(1+5–√)/2], bk=ak+k, k=0,1,2,3...。

所以，先求出差值，差值*黄金分割比 != 最小值的话必胜
```cpp
double r = (sqrt(5) + 1) / 2;
int d = abs(a - b) * r;
return (d != min(a, b));
```
>如果a,b的值非常大的话，需要高精度来计算这个double类型的r。
## Nimm博弈
有n堆物品，两人轮流取，每次取某堆中不少于1个，最后取完者胜

所有的堆数量，异或和不为0，必胜

一般性博弈问题，通过SG函数转换为Nimm博弈
## SG函数
首先给出一种ICG博弈游戏模型，给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿着有向边进行移动，无法移动者判负。

将ICG问题进行转化：任何一个ICG都可以通过把每个局面看作一个顶点，对每个局面和它的子局面连一条有向边来抽象这个“有向图游戏”。

SG函数（Sprague-Grundy）：对于一个给定的有向无环图，定义关于这个图的每个顶点的SG函数如下：

$$ sg(x)=mex\{sg(y) | y是x的后继\} $$

```cpp
int mex(auto v) // v可以是vector、set等容器 
{
    unordered_set<int> S;
    for (auto e : v)
        S.insert(e);
    for (int i = 0;; ++i)
        if (S.find(i) == S.end())
            return i;
}
```
### SG函数的求法
1. 找出必败态
2. 找出当前所有状态的前驱结点
3. 根据定义计算结点SG值
4. 重复上述步骤，直到所有点的SG函数值被计算过
## SG定理
游戏的SG函数值就是它的所有子游戏的SG函数值的异或。
# 组合数学导读

## 排列数&组合数

### 排列数

$n$ 个数选 $m$ 个排列，情况总数=$A_n^m=\frac{n!}{(n-m)!}$

全排列，指 $n$ 个数选 $n$ 个排列，情况总数=$A_n^n=n!$

### 组合数

$n$ 个数选 $m$ 个组合，情况总数=$C_n^m=\frac{n!}{m!(n-m)!}$

组合数也常用$\displaystyle\binom{n}{m}$表示

组合数也被称为“二项式系数”
## 二项式定理

$$(a+b)^n=\sum\limits_{i=0}^n \displaystyle\binom{n}{i} a^ib^{n-i}$$

## 多重集

### 多重集的排列数

$$\frac{n!}{\prod_{i=1}^k(n_i!)}$$

### 多重集的组合数

$$\binom{r+k-1}{k-1}$$

## 不相邻的排列

$1 \sim n$ 这 $n$ 个自然数中选 $k$ 个，这 $k$ 个数中任何两个数都不相邻的组合有 $\displaystyle \binom {n-k+1}{k}$ 种。

## 圆排列

$n$ 个人全部来围成一圈，所有的排列数记为 $\mathrm Q_n^n$。考虑其中已经排好的一圈，从不同位置断开，又变成不同的队列。
所以有

$$\mathrm Q_n^n \times n = \mathrm A_n^n \Longrightarrow \mathrm Q_n = \frac{\mathrm A_n^n}{n} = (n-1)!$$

由此可知部分圆排列的公式：

$$\mathrm Q_n^r = \frac{\mathrm A_n^r}{r} = \frac{n!}{r \times (n-r)!}$$

## 组合数性质

$$\binom{n}{m}=\binom{n}{n-m}\tag{1}$$

相当于将选出的集合对全集取补集，故数值不变。（对称性）

$$\binom{n}{k} = \frac{n}{k} \binom{n-1}{k-1}\tag{2}$$

由定义导出的递推式。

$$\binom{n}{m}=\binom{n-1}{m}+\binom{n-1}{m-1}\tag{3}$$

组合数的递推式（杨辉三角的公式表达）

$$\binom{n}{0}+\binom{n}{1}+\cdots+\binom{n}{n}=\sum_{i=0}^n\binom{n}{i}=2^n\tag{4}$$

这是二项式定理的特殊情况。取 $a=b=1$ 就得到上式。

$$\sum_{i=0}^m \binom{n}{i}\binom{m}{m-i} = \binom{m+n}{m}\ \ \ (n \geq m)\tag{5}$$

拆组合数的式子，在处理某些数据结构题时会用到。

$$\sum_{i=0}^n\binom{n}{i}^2=\binom{2n}{n}\tag{6}$$

这是 $(5)$ 的特殊情况，取 $n=m$ 即可。

$$\sum_{i=0}^ni\binom{n}{i}=n2^{n-1}\tag{7}$$

带权和的一个式子，通过对 $(3)$ 对应的多项式函数求导可以得证。

$$\sum_{i=0}^ni^2\binom{n}{i}=n(n+1)2^{n-2}\tag{8}$$

与上式类似，可以通过对多项式函数求导证明。

$$\sum_{l=0}^n\binom{l}{k} = \binom{n+1}{k+1}\tag{9}$$

在恒等式证明中较常用。

$$\binom{n}{r}\binom{r}{k} = \binom{n}{k}\binom{n-k}{r-k}\tag{10}$$

通过定义可以证明。

$$\sum_{i=0}^n\binom{n-i}{i}=F_{n+1}\tag{11}$$

其中 $F$ 是斐波那契数列。
## 常见数列

### 错排问题

$f_n=(n-1)(f_{n-1}+f_{n-2})$。

错位排列数列的前几项为 $0,1,2,9$。

### 卡特兰数

#### 经典题：进出栈序列

n 个元素进栈序列为：1，2，3，4，...，n，则有多少种出栈序列

我们将进栈表示为 +1，出栈表示为 -1

出栈序列的所有前缀和必然大于等于 0，并且序列 +1 的数量 等于 -1 的数量

接下来让我们观察一下 n = 3 的一种出栈序列：+1 -1 -1 +1 -1 +1。序列前三项和小于 0，显然这是个非法的序列。

如果将 第一个 前缀和小于 0 的前缀，即前三项元素都进行取反，就会得到：-1 +1 +1 +1 -1 +1。此时有 3 + 1 个 +1 以及 3 - 1 个 -1。

因为这个小于 0 的前缀和必然是 -1，且 -1 比 +1 多一个，取反后，-1 比 +1 少一个，则 +1 变为 n + 1 个，且 -1 变为 n - 1 个。进一步推广，对于 n 元素的每种非法出栈序列，都会对应一个含有 n + 1 个 +1 以及 n - 1 个 -1 的序列。

如何证明这两种序列是一一对应的？

假设非法序列为 A，对应的序列为 B。每个 A 只有一个"第一个前缀和小于 0 的前缀"，所以每个 A 只能产生一个 B。而每个 B 想要还原到 A，就需要找到"第一个前缀和大于 0 的前缀"，显然 B 也只能产生一个 A。

每个 B 都有 n + 1 个 +1 以及 n - 1 个 -1，因此 B 的数量为 $\dbinom {2n}{n+1}$ ，相当于在长度为 2n 的序列中找到 n + 1 个位置存放 +1。相应的，非法序列的数量也就等于 $\dbinom {2n}{n+1}$ 。

出栈序列的总数量共有 $\dbinom {2n}{n}$ ，因此，合法的出栈序列的数量为 $\dbinom {2n}{n}-\dbinom {2n}{n+1}$ 。

此时我们就得到了卡特兰数的通项 $\dbinom {2n}{n}-\dbinom {2n}{n+1}=\dbinom{2n}{n}/(n+1)$

#### 例题

n 对括号，则有多少种 “括号匹配” 的括号序列

左括号+1，有括号-1

n + 1 个叶子节点能够构成多少种形状不同的满二叉树

> 如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。

非叶节点，左子树+1，右子树-1

电影票一张 50 coin，且售票厅没有 coin。m 个人各自持有 50 coin，n 个人各自持有 100 coin。则有多少种排队方式，可以让每个人都买到电影票。

50+1，100-1

公式不同，$\dbinom {n+m}n-\dbinom{n+m}{m+1}$

节点数为 $i$ 时二叉树构造的方案数

> 写题就是寻找满足下列公式的特点

#### 公式

$C_n=\dbinom{2n}{n}/(n+1)$

$C_1=1,C_n=C_{n-1}\times\frac{4n-2}{n+1}$

$C_n=\begin{cases}1&n=0,1\\\sum\limits_{i=1}^n C_{i-1}*C_{n-i}&2\le n\end{cases}$

$C_n=\dbinom {2n}{n}-\dbinom {2n}{n+1}$

# 组合数取模
## 阶乘
```cpp
const int N=1e6+3;
long long fac[N],inv[N];
long long fast_power(long long base, long long exponent)
{
    long long result = 1;
    for (; exponent > 0; exponent >>= 1)
    {
        if (exponent & 1)
            result = result * base % mod;
        base = base * base % mod;
    }
    return result;
}
void getC()
{
    fac[0]=1;
    for(int i=1;i<N;++i)
        fac[i]=fac[i-1]*i%mod;
    inv[N-1]=fast_power(fac[N-1],mod-2);
    for(int i=N-1;i;--i)
        inv[i-1]=inv[i]*i%mod;
}
long long C(int n,int m)
{
    return fac[n]*inv[m]%mod*inv[n-m]%mod;
}
```

## Lucas 定理

### 适用条件

$n,m$ 较大，$p$ 为素数

### 公式

$C(n,m)\%p=C(n/p,m/p)*C(n\%p,m\%p)\%p$

### 时间复杂度

$O(f(x)+g(n)log_p n)$

$f(x)$ 为预处理组合数的复杂度，$g(n)$ 为单次求组合数的复杂度

$p$ 小，逆元打表，$O(n+p+log_p n)$

//$n$ 为处理阶乘，$p$ 为打表，$log_p n$为单次查询

$p$ 大，exgcd 求逆元,$O(n+ln p*log_p n)$

//$n$ 为处理阶乘，$\ln p*log_p n$ 为单次查询

```c++
long long Lucas(long long n, long long m, long long p)
{
    if (m == 0) return 1;
    return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p;
}
```

## exLucas

### 适用条件

$n,m$ 较大，$p$ 不为素数

### 时间复杂度

$O(plog p)$

```c++
ll qpow(ll base,ll exponent,ll mod)
{
    ll result=1;
    for(;exponent;base=base*base%mod,exponent>>=1)
    {
        if(exponent&1)
            result=result*base%mod;
    }
    return result;
}
ll g(ll n,ll p)
{
    if(n<p)
        return 0;
    return g(n/p,p)+n/p;
}
ll calc(ll n,ll p,ll MOD)
{
    if(n==0)
        return 1;
    ll res=1;
    for(ll i=1;i<=MOD;i++)
    {
        if(i%p)
            res=res*i%MOD;
    }
    res=qpow(res,n/MOD,MOD);
    for(ll i=n/MOD*MOD+1;i<=n;i++)
    {
        if(i%p)
            res=res*(i%MOD)%MOD;
    }
    return res*calc(n/p,p,MOD)%MOD;
}
ll exgcd(ll a,ll b,ll &x,ll &y)
{
	if(!b) {x=1,y=0;return a;}
	ll r=exgcd(b,a%b,y,x);
	y-=x*(a/b);
	return r;
}
ll inv(ll a,ll n)
{
    ll x,y;
    if(exgcd(a,n,x,y)==1ll)
        return (x%n+n)%n;
    else
        return -1;
}
ll lucas(ll n,ll m,ll p,ll MOD)
{
    ll pw=qpow(p,g(n,p)-g(m,p)-g(n-m,p),MOD);
    return calc(n,p,MOD)*inv(calc(m,p,MOD),MOD)%MOD*inv(calc(n-m,p,MOD),MOD)%MOD*pw%MOD;
}
ll CRT(const vector<ll> &a,const vector<ll> &m)
{
    int siz=a.size();
    ll mul=1,sum=0;
    for(auto tmp:m)
        mul*=tmp;
    for(int i=0;i<siz;i++)
    {
        ll M=mul/m[i];
        sum=(sum+a[i]*M%mul*inv(M,m[i]))%mul;
    }
    return sum%mul;
}
ll exlucas(ll n,ll m,ll MOD)
{
    vector<ll> a,mod;
    ll tmp=MOD;
    for(int p=2;p<=tmp/p;p++)
    {
        if(tmp%p==0)
        {
            ll mul=1;
            while(tmp%p==0)
                mul*=p,tmp/=p;
            mod.push_back(mul),a.push_back(lucas(n,m,p,mul));
        }
    }
    if(tmp>1) mod.push_back(tmp),a.push_back(lucas(n,m,tmp,tmp));
    return CRT(a,mod);
}
```
# 球盒问题
$n$ 个球，放入 $m$ 个盒中,共8种情况
## 球同，盒不同，无空箱
$C(n-1,m-1)$

使用插板法：$n$ 个球中间有 $n-1$ 个间隙，现在要分成 $m$ 个盒子，而且不能有空箱子，所以只要在 $n-1$ 个间隙选出 $m-1$ 个间隙即可
## 球同，盒不同，允许空箱
$C(n+m-1,m-1)$

如果给每个盒子一个球，就可以把问题转化为不能空的情况了,就相当于 $n+m$ 个小球放入 $m$ 个盒子且不能空
## 球不同，盒相同，无空箱
第二类斯特林数 $\begin{Bmatrix}n\\ m\end{Bmatrix}$
```c++
const int N=5e3+3;
ll S[N][N];
void cal()
{
    S[0][0]=1;
    for(int i=1;i<N;++i)
    {
        for(int j=1;j<=i;++j)
            S[i][j]=S[i-1][j-1]+(ll)j*s[i-1][j];
    }
}
```
## 球不同，盒相同，允许空箱
$\sum\limits_{i=1}^m\begin{Bmatrix}n\\ i\end{Bmatrix}$

枚举使用的箱子的个数
## 球不同，盒不同，无空箱
$m!\times \begin{Bmatrix}n\\ m\end{Bmatrix}$

给盒子定义顺序
## 球不同，盒不同，允许空箱
$m^n$

每个球都有 $m$ 种选择
## 球同，盒同，无空箱
等同于把一个正整数n拆分成m个正整数之和的方案数，即分拆数的k部分拆 $p(n,m)$
```cpp
const int N=5e3+3;
ll p[N][N];
void cal()
{
    p[0][0]=1;
    for(int i=1;i<N;++i)
    {
        for(int j=1;j<=i;++j)
            p[i][j]=p[i-j][j]+p[i-1][j-1];
    }
}
```
## 球同，盒同，允许空箱
等同于把一个正整数拆分成几个正整数之和的方案数，即分拆数 $p(n)=\sum\limits_{i=1}^m p(n,i)$

# 容斥原理
## min-max 容斥

通过集合最小值计算集合最大值，或者反过来
$$max(S)=\sum\limits_{T\subseteq S}min(T)(-1)^{|T|-1}$$
$|T|$ 表示 $T$ 的元素个数
$$min(S)=\sum\limits_{T\subseteq S}max(T)(-1)^{|T|-1}$$
如果只是计算集合最大最小值，$O(n)$ 即可完成，但是这个结论可以放到期望上

即，max 表示满足所有条件的期望，min 表示满足至少一个条件的期望

## Kthmin-max 容斥

$$Kthmax(S)=\sum\limits_{T\subseteq S}min(T)\dbinom{|T|-1}{k-1}(-1)^{|T|-k}$$

## gcd-lcm 容斥

$$lcm(S)=\sum\limits_{T\subseteq S}gcd(T)(-1)^{|T|-1}$$

# 卡特兰数高精

$C_n=\dbinom{2n}{n}/(n+1)$

将乘除部分按照质因数存储，乘法即答案的相应质因数 +1 ，除法则 −1 ，可以优化掉高精除低精这个过程。

同时，应用高精度压位技巧，即数组中的每一位存储多个数字

```c++
typedef long long ll;
int exponential[1010];
struct big
{
    int len;
    ll x[1000];
    int bit=1e9;
    ll& operator [](int a)
    {return x[a];}
    friend void operator *=(big &a,int b)
    {
        int len=a.len,bit=a.bit;
        for(int i=1;i<=len;i++)a[i]*=b;
        int now=1;
        while(now<=len)
        {
            if(a[now]>=bit)a[now+1]+=a[now]/bit,a[now]%=bit;
            if(now==len&&a[len+1])len++;
            now++;
        }
        a.len=len;
    }
    void print()
    {
        cout<<x[len];
        for(int i=len-1;i>=1;i--)
            cout<<setw(9)<<setfill('0')<<x[i];
    }
}catalennumber;
void add(int x,int v)
{
    for(int i=2;i*i<=x;++i)
    {
        while(x%i==0)
        {
            x/=i;
            exponential[i]+=v;
        }
    }
    if(x!=1)
        exponential[x]+=v;
}
void catalan(int n)
{
    int t=n<<1;
    for(int i=n+2;i<=t;++i)
        add(i,1);
    for(int i=1;i<=n;++i)
        add(i,-1);
    catalennumber[1]=catalennumber.len=1;
    for(int i=1;i<=t;++i)
    {
        while(exponential[i])
        {
            catalennumber*=i;
            --exponential[i];
        }
    }
    catalennumber.print();
}
```
# 二项式反演
## 形式1
$f(k)=\sum\limits_{i=k}^n \dbinom ik g(i)$

$g(k)=\sum\limits_{i=k}^n (-1)^{i-k}\dbinom ikf(i)$
## 形式2
$f(k)=\sum\limits_{i=m}^{k} \dbinom ki g(i)$

$g(k)=\sum\limits_{i=m}^k (-1)^{k-i}\dbinom kif(i)$
# 斯特林数
## 第一类斯特林数
n个不同元素构成m个圆排列的方案数，记为 $s(n,m)$，或 $\begin{bmatrix}n\\ m\end{bmatrix}$

分为无符号 $s_u(n,m)$ 和有符号 $s_s(n,m)$ ，关系是 $S_s(n,m)=(-1)^{n-m}s_u(n,m)$
### $O(n^2)$求第一类斯特林数
1-n的一个排列，划分为m个圆排列，第n个数，要么放在一个新的圆，要么放在旧的圆

$\begin{bmatrix}n\\ m\end{bmatrix}=\begin{bmatrix}n-1\\ m-1\end{bmatrix}+(n-1)\times\begin{bmatrix}n-1\\ m\end{bmatrix}$

边界情况： $\begin{bmatrix}n\\ n \end{bmatrix}=1(n\ge 0)$ ， $\begin{bmatrix}n\\ 0 \end{bmatrix}=0 (n\ge 1)$
```cpp
const int N=5e3+3;
ll s[N][N];
void cal()
{
    s[0][0]=1;
    for(int i=1;i<N;++i)
    {
        for(int j=1;j<=i;++j)
            s[i][j]=s[i-1][j-1]+(ll)(i-1)*s[i-1][j];
    }
}
```
### 无符号第一类斯特林数性质
1. $s_u(n,1)=(n-1)!$
2. $s_u(n,2)=(n-1)!\sum\limits_{i=1}^{n-1}\frac 1i$
3. $s_u(n,n-1)=\dbinom n2$
4. $s_u(n,n-2)=2\dbinom n3+3\dbinom n4$
5. $\sum\limits_{i=0}^ns_u(n,i)=n!$
## 第二类斯特林数
n个不同元素构成m个互不区分的非空子集的方案数，记为 $S(n,m)$，或 $\begin{Bmatrix}n\\ m\end{Bmatrix}$
### $O(n^2)$求第二类斯特林数
1-n的一个排列，划分为m个互不区分的非空子集，第n个数，要么放在一个新的集合，要么放在旧的集合

$\begin{Bmatrix}n\\ m\end{Bmatrix}=\begin{Bmatrix}n-1\\ m-1\end{Bmatrix}+m\times\begin{Bmatrix}n-1\\ m\end{Bmatrix}$

边界情况： $\begin{Bmatrix}n\\ n \end{Bmatrix}=1(n\ge 0)$ ， $\begin{Bmatrix}n\\ 0 \end{Bmatrix}=0 (n\ge 1)$
```cpp
const int N=5e3+3;
ll S[N][N];
void cal()
{
    S[0][0]=1;
    for(int i=1;i<N;++i)
    {
        for(int j=1;j<=i;++j)
            S[i][j]=S[i-1][j-1]+(ll)j*S[i-1][j];
    }
}
```
### $O(n)$求第二类斯特林数
$\begin{Bmatrix}n\\ m\end{Bmatrix}=\sum\limits_{i=0}^m\frac{(-1)^{m-i}i^n}{i!(m-i)!}$
```cpp
const int N=2e5+3;
ll v[N];
int p[N>>2],n;
void seive()
{
	int cnt=0;
    v[1]=1;//!!
	for(int i=2;i<N;++i)
	{
		if(!v[i])
        {
			p[cnt++]=i;
            v[i]=fast_power(i,n);
        }
		for(int j=0;j<cnt && i*p[j]<N;++j)
		{
			v[i*p[j]]=v[i]*v[p[j]]%mod;
			if(i%p[j]==0)
				break;
		}
	}
}
ll cal(int m)
{
    ll res=0;
    for(int i=0;i<=m;++i)
    {
        if((m-i)&1)
            res=(res-v[i]*inv[i]%mod*inv[m-i]%mod+mod)%mod;
        else
            res=(res+v[i]*inv[i]%mod*inv[m-i]%mod)%mod;
    }
    return res;
}
```
### 第二类斯特林数性质
1. $S(n,1)=1$
2. $S(n,2)=2^{n-1}-1$
3. $S(n,3)=\frac 12(3^{n-1}+1)-2^{n-1}$
4. $S(n,n-1)=\dbinom n2$
5. $S(n,n-2)=\dbinom n3+3\dbinom n4$
6. $S(n,n-3)=\dbinom n4+10\dbinom n5+15\dbinom n6$
7. $\sum\limits_{i=0}^nS(n,i)=B_n$ ，$B_n$ 是贝尔数
8. $\sum\limits_{i=0}^n(-1)^i\dbinom ni(n-i)^n=n!$
9. $n^k=\sum\limits_{i=0}^kS(k,i)(i!)\dbinom ni$
## 上升幂和下降幂
普通幂：$x^n$

上升幂：$x^{\overline n}=\prod\limits_{i=0}^{n-1}(x+i)$

上升幂和普通幂转换：

$$x^{\overline n}=\sum\limits_{i=0}^n\begin{bmatrix}n\\ i\end{bmatrix}x^i$$

$$x^n=\sum\limits_{i=0}^n\begin{Bmatrix}n\\ i\end{Bmatrix}(-1)^{n-i}x^{\overline i}$$

下降幂：$x^{\underline n}=\prod\limits_{i=0}^{n-1}(x-i)$

下降幂和普通幂转换：

$$x^{\underline n}=\sum\limits_{i=0}^n\begin{bmatrix}n\\ i\end{bmatrix}(-1)^{n-i}x^i$$

$$x^n=\sum\limits_{i=0}^n\begin{Bmatrix}n\\ i\end{Bmatrix}x^{\underline i}$$

普通幂转下降幂是常用套路，注意恒等式 $\dbinom nii^{\underline j}=\dbinom{n-j}{i-j}n^{\underline j}$
# 群论
## 群
设 $G$ 是一个集合

$*$ 是 $G$ 上的二元运算，如果 $(G,*)$ 满足下面 4 个条件,则称 $(G,*)$ 为一个群。

1. 封闭性：$\forall a,b∈G$ ,有 $a*b∈G$;

2. 结合律：$\forall a,b,c∈G$，有 $(a*b)*c=a*(b*c)$;

3. 单位元：存在 $e∈G$ ,使得 $\forall a∈G$,都有$a*e=e*a=a$;

4. 逆元：$\forall a∈G,\exists x∈G$,使得 $a*x=x*a=e$,这个时候记 $x$ 为 $a^{-1}$，称为 $a$ 的逆元

群元素的个数有限，称为有限群，且其中元素的个数称为阶，记为 $|G|$

---

## 置换

设 $X$ 为一个有限集，对集合的元素进行任意的排序，那么称排序后的结果 $π$ 是 $X$ 上的一个置换。

//有限集是元素个数有限的集合

设 $X=\{1,2,3,4....n\}$

设 $π$ 是 $X$ 的一个置换
其中 $a_1,a_2,...,a_n$ 是 $X$ 的一个排列

可将 $π$ 记为 $\begin{matrix}1&2&......&n\\a_1&a_2&......&   a_n\end{matrix}$

同一置换用这样的表示法有 $n!$ 种，但其对应的关系不变。

设置换 $π$ 的部分元素的对应关系如下

$π$：$\begin{matrix}a_1&a_2&...&a_k\\a_2&a_3&...&a_1\end{matrix}$

称为 $k$ 阶循环，$k$ 为循环长度。

//不一定连续，不一定从 1 开始

每个置换都可以写成若干个互不相交的循环节的乘积，且表示是唯一的.

> 对着例子理解这句话，一定要理解

### 例子

$π$：$\begin{matrix}1&2&3&4&5&6\\2&4&5&1&3&6\end{matrix}$

可以表示为$(124)(35)(6)$,置换的循环节数是 3,记为 C(π)

# Polya 定理

设 $G=\{π_1,π_2,π_3,...,π_k\}$是 $X=\{a_1,a_2,a_3,...,a_n\}$ 上一个置换群，

//置换的集合即为置换群

用 $m$ 种颜色对 $X$ 中的元素进行涂色，那么不同的涂色方案数为：

$\frac{1}{|G|} * \sum\limits_{i=1}^{k} m^{C(π_i)}$

---

## 例题

黑白两种颜色对下面的 2\*2 方格进行染色,

如果允许方格可以绕中心点旋转, 问有多少种不同的着色方案数?

$\begin{matrix}1&2\\3&4\end{matrix}$

---

方格可以旋转 $0°,90°,180°,270°$.

所以群 $G = \{0°,90°,180°,270°\}$ ,$|G| = 4$

$G$ 中 所有的置换是

$π_1 = (1)(2)(3)(4)$

$π_2 = (1234)$

$π_3 = (14)(23)$

$π_4 = (1432)$

$c(π_1) = 4 , c(π_2) = 1  , c(π_3) = 2 , c(π_4) = 1$

带入 Polya 定理

$ans = \frac{1}{4}*(2^4+2^1+2^2+2^1) = 6$

---

## 原理

当只有旋转的时候(顺时针或逆时针)，

对于一个有 $n$ 个元素的环，可顺时针或逆时针旋转几个位置，

由于至少有 $n$ 个置换，

但是假设我顺时针旋转 $k$ 个位置，他就等同于逆时针转动 $n-k$ 个位置，

假设一个置换为:

$G=\{π_0,π_1,π_2,...,π_{n-1}\}$

这个时候可以证明

逆时针旋转 $k$ 个位置时

$π_k$ 的循环节数为 $gcd(n,k)$

且每个循环的长度为 $L=n/gcd(n,k)$

---

上面那个例题只考虑了旋转的情况

## 翻转

- 当 $n$ 为奇数的时候，只有一种形式，

以顶点 $i$ 与中心的连线为轴的翻转

$π_i=\begin{matrix}...&i-1&i&i+1&...\\...&i+1&i&i-1&...\end{matrix}$

有 $n$ 个循环节数为 $(n+1)/2$ 的置换

- 当 n 为偶数时，有两种形式：

1. 以顶点 $i$ 与中心的连线为轴的翻转

$π_i=\begin{matrix}...&i-1&i&i+1&...\\...&i+1&i&i-1&...\end{matrix}$

有 $n/2$ 个循环节数为 $n/2+1$ 的置换

2. 以顶点 $i$ 和 $i+1$ 的中点与中心的连线为轴翻转

$π_i=\begin{matrix}...&i-1&i&i+1&...\\...&i+2&i+1&i&...\end{matrix}$

有 $n/2$ 个循环节数为 $n/2$ 的置换

> 要特别注意 $0$ 的情况，输出 $0$ 即可。

由于旋转有 $n$ 种置换，翻转也有 $n$ 种置换，所以 $|G|=2n$

```c++
typedef long long ll;
ll fast_power(ll base,ll exponent)
{
    ll result=1;
    while(exponent>0)
    {
        if(exponent&1)
            result=result*base;
        base=base*base;
        exponent>>=1;
    }
    return result;
}
ll polya(ll n,ll m)
{
    if(!n)
        return 0;
    ll sum=0;
    for(ll i=0;i<n;++i)
        sum+=fast_power(m,__gcd(n,i));
    if(n&1)
        sum+=n*fast_power(m,(n+1)/2);
    else
        sum+=n/2*(1ll+m)*fast_power(m,n/2);
    sum/=(2*n);
    return sum;
}
```
# 线性代数
# 矩阵快速幂
## 时间复杂度
$O(t^3*log n)$,$t$ 是矩阵边长，$t^3$ 表示矩阵乘法
## 常见多项式抽象

1. $f(n) = a * f(n-1) + b * f(n-2) +c$

$\begin{pmatrix}a&b&1\\1&0&0\\0&0&1\end{pmatrix}*
\begin{pmatrix}f(n-1)\\f(n-2)\\c\end{pmatrix}=
\begin{pmatrix}f(n)\\f(n-1)\\c\end{pmatrix}$

2. $f(n) = f(n-1) + c^n$

$\begin{pmatrix}1&c\\0&c\end{pmatrix}*
\begin{pmatrix}f(n-1)\\c^{n-1}\end{pmatrix}=
\begin{pmatrix}f(n)\\c^{n}\end{pmatrix}$

3. $f(n)= f(n-1) + n^3$

因为

$n^3$

$= (n - 1 + 1)^3$

$= C(0,3)*(n-1)^3 + C(1,3)*(n-1)^2 + C(2,3)*(n-1)^1 + C(3,3)*(n-1)^0$

所以

$\begin{pmatrix}1&C(0,3)&C(1,3)&C(2,3)&C(3,3)\\
0&C(0,3)&C(1,3)&C(2,3)&C(3,3)\\
0&0&C(0,2)&C(1,2)&C(2,2)\\
0&0&0&C(0,1)&C(1,1)\\
0&0&0&0&C(0,0)\end{pmatrix}*
\begin{pmatrix}f(n-1)\\(n-1)^3\\(n-1)^2\\(n-1)^1\\(n-1)^0\end{pmatrix}=
\begin{pmatrix}f(n)\\n^3\\n^2\\n^1\\n^0\end{pmatrix}$
```c++
const int N = 4;
struct matrix
{
    ll m[N][N];
    void init()//单位矩阵
    {
        memset(m,0,sizeof(m));
        for(int i=0;i<N;++i)
            m[i][i]=1;
    }
    matrix operator*(matrix y)
    {
        matrix c;
        memset(c.m,0,sizeof(c.m));
        //稠密矩阵
        for(int i=0;i<N;++i)
        {
            for(int j=0;j<N;++j)
            {
                for(int k=0;k<N;++k)
                    c.m[i][j] = (c.m[i][j] + m[i][k] * y.m[k][j] % mod) % mod;
            }
        }
        //稀疏矩阵(指矩阵中很多数为0)
        for(int i=0;i<N;++i)
        {
            for(int j=0;j<N;++j)
            {
                if(!m[i][j])
                    continue;
                for(int k=0;k<N;++k)
                    c.m[i][k] = (c.m[i][k] + m[i][j] * y.m[j][k] % mod) % mod;
            }
        }
        return c;
    }
    matrix operator^(ll exponent)
    {
        matrix result;
        result.init();
        for(;exponent;exponent>>=1)
        {
            if(exponent&1)
                result = result*(*this);
            (*this) = (*this)*(*this);
        }
        return result;
    }
};
matrix base{1,1,1,2,
            0,1,1,2,
            0,1,0,0,
            0,1,0,1};
base=base^(n-2);
ll ans=(((base.m[0][0]*2%mod+base.m[0][1])%mod+base.m[0][2])%mod+base.m[0][3])%mod;
```
# 高斯消元
注意处理无解，无穷解情况

-1 无解，0 无穷解，1 唯一解
## 线性方程组
```c++
const int N=1e2+1;
const double eps=1e-6;
double a[N][N],ans[N];
int GaussianElimination(int n)
{
    int i,maxx,j,k,cnt=0;
    double temp;
    for(i=0;i<n;++i)
    {
        maxx=cnt;
        for(j=cnt+1;j<n;++j)
        {
            if(fabs(a[j][i])>fabs(a[maxx][i]))
                maxx=j;
        }
        if(fabs(a[maxx][i])<eps)
            continue;
        if(maxx!=cnt)
            swap(a[maxx],a[cnt]);
        for(j=0;j<n;++j)
        {
            if(j==cnt)
                continue;
            temp=a[j][i]/a[cnt][i];
            for(k=i+1;k<=n;++k)
                a[j][k]-=a[cnt][k]*temp;
        }
        ++cnt;
    }
    if(cnt<n)
    {
        for(;cnt<n;++cnt)
        {
            if(fabs(a[cnt][n])>eps)
                return -1;
        }
        return 0;
    }
    for(i=0;i<n;++i)
        ans[i]=a[i][n]/a[i][i];
    return 1;
}
```
## 矩阵求逆
```cpp
const int N=402,mod=1e9+7;
int a[N][N],ih[N],jh[N];//a,1-index
bool inverseMatrix(int n)
{
    for(int k=1;k<=n;++k)
    {
        for(int i=k;i<=n && !ih[k];++i)
        {
            for(int j=k;j<=n;++j)
            {
                if(!a[i][j])
                    continue;
                ih[k]=i;
                jh[k]=j;
                break;
            }
        }
        if(!ih[k])
            return false;
        for(int j=1;j<=n;++j)
            swap(a[k][j],a[ih[k]][j]);
        for(int i=1;i<=n;++i)
            swap(a[i][k],a[i][jh[k]]);
        if(!a[k][k])
            return false;
        a[k][k]=inv(a[k][k]);
        for(int i=1;i<=n;++i)
        {
            if(i!=k)
                a[k][i]=(ll)a[k][i]*a[k][k]%mod;
        }
        for(int i=1;i<=n;++i)
        {
            if(i==k)
                continue;
            for(int j=1;j<=n;++j)
            {
                if(j!=k)
                    a[i][j]=(a[i][j]+(ll)(mod-a[i][k])*a[k][j])%mod;
            }
        }
        for(int i=1;i<=n;++i)
        {
            if(i!=k)
                a[i][k]=(ll)(mod-a[i][k])*a[k][k]%mod;
        }
    }
    for(int k=n;k;--k)
    {
        for(int j=1;j<=n;++j)
            swap(a[k][j],a[jh[k]][j]);
        for(int i=1;i<=n;++i)
            swap(a[i][k],a[i][ih[k]]);
    }
    return true;
}
```
## 异或方程组
```c++
const int N=1e2+3;
bitset<N> a[N];
bitset<N> ans;
int GaussElimination(int n, int m)
{
    int i,j,cnt=0;
    for(i=0;i<n;++i)
    {
        for(j=cnt;j<m && !a[j][i];++j){}
        if(j==m)
            continue;
        if(j != cnt)
            swap(a[j], a[cnt]);
        for(j=0;j<m;j++)
        {
            if(cnt==j)
                continue;
            if(a[j][i])
                a[j]^=a[cnt];
        }
        ++cnt;
    }
    if(cnt<n)
    {
        for(;cnt<n;++cnt)
        {
            if(a[cnt][n])
                return -1;
        }
        return 0;
    }
    for (i = 0; i < n; i++)
        ans[i] = a[i][n];
    return 1;
}
```
## 行列式
```c++
const int N=1e2+1;
const double eps=1e-6;
double a[N][N];
double GaussianElimination(int n)
{
    int i,maxx,j,k;
    double temp,res=1;
    for(i=0;i<n;++i)
    {
        maxx=i;
        for(j=i+1;j<n;++j)
        {
            if(fabs(a[j][i])>fabs(a[maxx][i]))
                maxx=j;
        }
        if(fabs(a[maxx][i])<eps)
            return 0.0;
        if(maxx!=i)
        {
            swap(a[maxx],a[i]);
            res=-res;
        }
        res*=a[i][i];
        for(j=0;j<n;++j)
        {
            if(j==i)
                continue;
            temp=a[j][i]/a[i][i];
            if(fabs(temp)<eps)
                continue;
            for(k=i;k<=n;++k)
                a[j][k]-=a[i][k]*temp;
        }
    }
    return res;
}
```
# 线性基
1. 第k大异或和
2. 合法值是所有异或值的第几大
3. 是否可以线性表出某个值
4. 线性基合并
5. x和线性基的异或最小值
6. 1 到 n 的路径的最小异或和
7. 所有异或值的和
8. 带删线性基
## 线性表出
一个向量如果可以被其他向量通过运算表示，那么称这个向量可以被线性表出。

例如2维平面上的任意向量，都可以被(0,1),(1,0)这组向量通过矢量合成与放缩表示

在XCPC中，通常是一个数可以被其他数通过异或表示
## 线性相关&线性无关
如果向量组中有一个向量可以被向量组其他向量线性表出，那么称这个向量组线性相关，否则线性无关
## 极大线性无关组
线性相关可以理解为有多余的向量，删完之后，就是极大线性无关组
## 线性基
向量组的极大线性无关组就是线性基，简称基

一个向量组可以对应多个基，因此需要构造出一种合法基
### 性质
1. 原序列里的任意一个数都可以通过线性基中的一些数异或得到
2. 线性基里的任意一些数异或起来都不能得到 0
3. 每个序列的线性基的元素数量唯一，在性质一的前提下，有最少的数

序列里的元素相互异或一下，它的线性基不变

本构造得到的基，有2个性质：

1. 每个元素最高有效位各不相同

2. 如果某一位是一个元素的最高有效位，则其他元素在这一位均为 0
```cpp
typedef unsigned long long ull;
long long fast_power(long long base,long long exponent)
{
    long long result=1;
    for(;exponent>0;exponent>>=1)
    {
        if(exponent&1)
            result=result*base;
        base=base*base;
    }
    return result;
}
struct linearBasis
{
    vector<ull> B;
    int zero,cnt,tot;
    vector<int> rnk;
    void init()
    {
        B.clear();
        zero=tot=0;
    }
    void insert(ull x)
    {
        for (ull &b : B)
            x = min(x, b ^ x);
        for (ull &b : B)
            b = min(b, b ^ x);
        if (x)
            B.push_back(x);
        ++tot;
    }
    int msb(ull x)
    {
        return 63 - __builtin_clzll(x);
    }
    void init2()
    {
        sort(B.begin(),B.end());
        cnt=B.size();
        if(cnt<tot)
            zero=1;
        for(ull &b:B)
            rnk.push_back(msb(b));
    }
    ull kthxorsum(ull k)
    {
        k-=zero;
        ull ans=0;
        for(ull &b:B)
        {
            if(k&1)
                ans^=b;
            k>>=1;
        }
        return ans;
    }
    ull askrank(ull x)
    {
        ull ans=0;
        for (int i = 0; i < cnt; ++i)
        {
            if (x >> rnk[i] & 1)
                ans +=1<<i;
        }
        return ans*fast_power(2,tot-cnt)+1;
    }
    bool check(ull x)
    {
        for (ull &b : B)
            x = min(x, b ^ x);
        return (!x);
    }
    void merge(linearBasis &o)
    {
        for(ull &u:o.B)
            (*this).insert(u);
    }
    ull minXorSumWithX(ull x)
    {
        for (ull &b : B)
            x = min(x, b ^ x);
        return x;
    }
};
```
## 1 到 n 的路径的最小异或和
所有路径异或和，都可以由任意一条 1 到 n 路径的异或和与图中的一些环的异或和来组合得到。

从1先走到一个环，绕环一次，再原路返回，即可得到环的异或和，来路的异或和被抵消了。

A，B是两条1到n的路径，A，B组成环，如果A更优，走B前绕这个环一圈即可得到A的结果，所以是任意一条路径。

dfs搜出部分环，线性基自己可以解决环套环

最小异或和前面介绍过了
```cpp
typedef unsigned long long ull;
struct linearBasis
{
    vector<ull> B;
    void insert(ull x)
    {
        for (ull &b : B)
            x = min(x, b ^ x);
        for (ull &b : B)
            b = min(b, b ^ x);
        if (x)
            B.push_back(x);
    }
    ull minXorSumWithX(ull x)
    {
        for (ull &b : B)
            x = min(x, b ^ x);
        return x;
    }
}lb;
int vis[N],xorsum[N];
void dfs(int u,int sum)
{
    xorsum[u]=sum;
    vis[u]=1;
    for(auto &[v,w]:e[u])
    {
        if(vis[v])
            lb.insert(sum^w^xorsum[v]);
        else
            dfs(v,sum^w);
    }
}
dfs(1,0);
cout<<lb.minXorSumWithX(xorsum[n]);
```
# 多项式
## fft
```cpp
const int MAXN = 1e7 + 10;
const double Pi = acos(-1.0);
struct comp
{
    double x, y;
    comp (double xx = 0, double yy = 0) {x = xx, y = yy;}
    comp operator + (const comp b) const {return comp(x + b.x,y + b.y);}
    comp operator - (const comp b) const {return comp(x - b.x,y - b.y);}
    comp operator * (const comp b) const {return comp(x * b.x - y * b.y,x * b.y + y * b.x);}
} a[MAXN], b[MAXN];
int l, limit, r[MAXN];
int N,M;
void fft(comp *A, int type)
{
    for (int i = 0; i < limit; i++)//求出要迭代的序列
    {
        if (i < r[i])
            swap(A[i], A[r[i]]);
    }
    for (int mid = 1; mid < limit; mid <<= 1)//待合并区间的中点
    {
        comp Wn( cos(Pi / mid) , type * sin(Pi / mid) );//单位根
        for (int R = mid << 1, j = 0; j < limit; j += R)//R是区间的右端点，j表示前已经到哪个位置了
        {
            comp w(1, 0);//幂
            for (int k = 0; k < mid; k++, w = w * Wn)//枚举左半部分
            {
                comp x = A[j + k], y = w * A[j + mid + k];//蝴蝶效应
                A[j + k] = x + y;
                A[j + mid + k] = x - y;
            }
        }
    }
    if(type==-1)
    {
        for (int i = 0; i <= N + M; i++)
            a[i].x=(double)((int)(a[i].x / limit + 0.5));//四舍五入取整
    }
}
void init(int x)//x表示2个多项式相乘最多有几个单项式
{
    limit=1;
    l=-1;
    while (limit < x)
        limit <<= 1, l++;
    for (int i = 0; i < limit; i++)
        r[i] = ( r[i >> 1] >> 1 ) | ( (i & 1) << l );
}
init(N+M+1);
fft(a, 1);
fft(b, 1);
for (int i = 0; i < limit; i++)
    a[i] = a[i] * b[i];
fft(a, -1);
```
### 三次变两次优化
(a+bi)^2=a^2-b^2+2abi
所以把b放在虚部，答案是虚部/2，注意把fft除limit改成虚部

## 分治fft
```cpp
void solve(int l,int r,int logn)
{
    if(logn<=0) return;
    if(l>=n) return;
    int mid=(l+r)>>1,i;
    ll t=inv(r-l);
    solve(l,mid,logn-1); // 计算左区间
    calcrev(logn);
    memset(a+(r-l)/2,0,sizeof(ll)*(r-l)/2); // 拷贝左区间
    memcpy(a,f+l,sizeof(ll)*(r-l)/2); // 填充0
    memcpy(b,g,sizeof(ll)*(r-l)); // 拷贝g
    FFT(a,logn,0),FFT(b,logn,0); // 卷积
    for(i=0;i<r-l;i++) a[i]=a[i]*b[i]%kcz;
    FFT(a,logn,1);
    for(i=0;i<r-l;i++) a[i]=a[i]*t%kcz;
    for(i=(r-l)/2;i<r-l;i++)
        f[l+i]=(f[l+i]+a[i])%kcz; // 把卷积后的右半段的数加到f数组后半段
    solve(mid,r,logn-1); // 计算右区间
}
```

## ntt

```cpp
typedef long long ll;
const int MAXN = 3e6 + 10;
const int P = 998244353;
const int G = 3;
const int Gi = 332748118;//G在模P的逆元
int N, M, limit, l, r[MAXN];
ll a[MAXN], b[MAXN];
ll fastpow(ll a, ll k)
{
	ll base = 1;
	for(;k;k>>=1)
    {
		if(k & 1)
            base = (base * a ) % P;
		a = (a * a) % P;
	}
	return base % P;
}
void NTT(ll *A, int type)
{
	for(int i = 0; i < limit; i++)
    {
		if(i < r[i])
            swap(A[i], A[r[i]]);
    }
	for(int mid = 1; mid < limit; mid <<= 1)
    {
		ll Wn = fastpow( type == 1 ? G : Gi , (P - 1) / (mid << 1));
		for(int j = 0,R=mid<<1; j < limit; j +=R)
        {
			ll w = 1;
			for(int k = 0; k < mid; k++, w = (w * Wn) % P)
            {
				 int x = A[j + k], y = w * A[j + k + mid] % P;
				 A[j + k] = (x + y) % P,
				 A[j + k + mid] = (x - y + P) % P;
			}
		}
	}
    if(type==-1)
    {
        ll inv = fastpow(limit, P - 2);
        for(int i=N+M;i>=0;--i)
            A[i]=A[i]*inv%P;
    }
}
void init(int x)
{
    limit=1;
    l=-1;
    while(limit<x)
        limit<<=1,++l;
    for(int i=0;i<limit;++i)
        r[i]=(r[i>>1]>>1)|((i&1)<<l);
}
init(N+M+1);
NTT(a, 1);
NTT(b, 1);
for(int i = 0; i < limit; i++)
    a[i] = (a[i] * b[i]) % P;
NTT(a, -1);
```
## 拉格朗日插值
### 原版
$n$ 个不同点 $(x_i,y_i)$ 确定唯一 $n-1$ 次多项式 $g$

已知 $n$ 个点值，可以 $O(n^2)$ 预处理，$O(nlog(mod))$ 求出 $g(k)$

```cpp
const int N=2e3+3;
const ll mod=998244353;
struct lagrange
{
    int n;
    ll x[N],y[N],w[N];
    long long inv(long long base)
    {
        long long result=1,exponent=mod-2;
        for(;exponent>0;exponent>>=1)
        {
            if(exponent&1)
                result=result*base%mod;
            base=base*base%mod;
        }
        return result;
    }
    void init()
    {
        n=0;
    }
    void insert(ll xx,ll yy)
    {
        x[++n]=xx;
        y[n]=yy;
        ll s=1;
        for(int i=1;i<n;++i)
        {
            w[i]=w[i]*(x[i]-xx)%mod;
            s=s*(xx-x[i])%mod;
        }
        w[n]=s;
    }
    void init2()
    {
        for(int i=1;i<=n;++i)
            w[i]=y[i]*inv(w[i])%mod;
    }
    ll lag(ll k)
    {
        ll s=1;
        for(int i=1;i<=n;++i)
        {
            if(k==x[i])
                return y[i];
            s=s*(k-x[i])%mod;
        }
        ll ans=0;
        for(int i=1;i<=n;++i)
            ans=(ans+s*inv(k-x[i])%mod*w[i]%mod)%mod;
        return (ans+mod)%mod;
    }
}la;
la.init();
la.insert(x,y);
la.init2();
la.lag(k);
```
### 特化版
当给定点值 $x_i$ 连续，可以 $O(n)$ 预处理，$O(n)$ 求 $g(k)$

$g(n)=\sum\limits_{i=1}^{k}y_i\prod\limits_{j=1,j\ne i}^{k}\frac{n-j}{i-j}$

$g(n)=\sum\limits_{i=1}^{k}y_i\left(\prod\limits_{j=1,j\ne i}^{k}(i-j)\right)^{-1}\prod\limits_{j=1,j\ne i}^{k}(n-j)$

$g(n)=\sum\limits_{i=1}^{k}y_i\left(\prod\limits_{j=1}^{i-1}(i-j)\prod\limits_{j=i+1}^{k}(i-j)\right)^{-1}\prod\limits_{j=1}^{i-1}(n-j)\prod\limits_{j=i+1}^{k}(n-j)$

$g(n)=\sum\limits_{i=1}^{k}y_i\left(\prod\limits_{j=1}^{i-1}j\prod\limits_{j=i-k}^{-1}j\right)^{-1}\prod\limits_{j=1}^{i-1}(n-j)\prod\limits_{j=i+1}^{k}(n-j)$

$pre_i=\prod\limits_{j=1}^i(n-j)，suf_i=\prod\limits_{j=i}^k(n-j)$

$g(n)=\sum\limits_{i=1}^{k}y_i(-1)^{k-i}\left((i-1)!(k-i)!\right)^{-1}pre_{i-1}suf_{i+1}$
```cpp
const int N=1e6+3;
const ll mod=1e9+7;
long long fac[N],inv[N];
long long fast_power(long long base, long long exponent)
{
    long long result = 1;
    for (; exponent > 0; exponent >>= 1)
    {
        if (exponent & 1)
            result = result * base % mod;
        base = base * base % mod;
    }
    return result;
}
void getC()
{
    fac[0]=1;
    for(int i=1;i<N;++i)
        fac[i]=fac[i-1]*i%mod;
    inv[N-1]=fast_power(fac[N-1],mod-2);
    for(int i=N-1;i;--i)
        inv[i-1]=inv[i]*i%mod;
}
struct lagrange
{
    ll y[N],pre[N],suf[N];
    ll lag(ll m,int k)//g(m)，k个点
    {
        if(m<=k)
            return y[m];
        pre[0]=suf[k+1]=1;
        for(int i=1;i<k;++i)
            pre[i]=pre[i-1]*(m-i)%mod;
        for(int i=k;i>1;--i)
            suf[i]=suf[i+1]*(m-i)%mod;
        ll ans=0;
        for(int i=1;i<=k;++i)
            ans=(ans+y[i]*inv[i-1]%mod*inv[k-i]%mod*pre[i-1]%mod*suf[i+1]%mod*((k-i)&1?-1:1))%mod;
        return (ans+mod)%mod;
    }
}la;
la.y[i]=y;
la.lag(m,k);
```
# 高等数学
## 函数
### 有界性
$\forall x,f(x)\le MAX$，$MAX$ 称为上界

$\forall x,f(x)\ge MIN$，$MIN$ 称为下界

$\forall x,|f(x)|<=M$，$M$ 称为界
### 初等函数
1. 幂函数：$y=x^k$
2. 指数函数：$y=a^x$
3. 对数函数：$y=\log_a x$
4. 三角函数：$y=\sin x,\cos x,\tan x=\frac{\sin x}{\cos x},\cot x=\frac 1{\tan x},\sec x=\frac 1{\cos x},\csc x=\frac 1{\sin x}$
5. 反三角函数：$y=\arcsin x$ 等

由以上5种，基本初等函数，经过有限次的四则运算和有限次的函数复合，的函数为初等函数
## 函数的极限存在的充分必要条件
$x$ 从左侧趋于 $x_0$ 记作 $x\rightarrow x_0^-$，$x$ 从右侧趋于 $x_0$ 记作 $x\rightarrow x_0^+$

$\lim\limits_{x\rightarrow x_0^-}f(x)=A=\lim\limits_{x\rightarrow x_0^+}f(x)$
## 无穷小与无穷大
### 无穷小定义
如果函数 $\lim\limits_{x\rightarrow x_0或x\rightarrow \infty}f(x)=0$，那么称函数 $f(x)$ 为当 $x\rightarrow x_0或x\rightarrow \infty$ 时的无穷小
### 无穷大定义
如果函数 $\lim\limits_{x\rightarrow x_0或x\rightarrow \infty}f(x)=\infty$，那么称函数 $f(x)$ 为当 $x\rightarrow x_0或x\rightarrow \infty$ 时的无穷大
### 无穷大和无穷小的联系
在自变量的同一变化过程中，如果 $f(x)$ 为无穷大，那么 $\frac 1{f(x)}$ 为无穷小；

反之，如果 $f(x)$ 为无穷小，且 $f(x)\ne 0$，那么 $\frac 1{f(x)}$ 为无穷大；
## 极限运算法则
1. 有限个无穷小之和是无穷小
2. 有界函数与无穷小的乘积是无穷小
3. 有限个无穷小之积是无穷小
4. 四则运算，即 $\lim f(x)=A,\lim g(x)=B$  
$\lim[f(x)+g(x)]=\lim f(x)+\lim g(x)=A+B$  
$\lim[f(x)-g(x)]=\lim f(x)-\lim g(x)=A-B$  
$\lim[f(x)g(x)]=\lim f(x)\lim g(x)=AB$  
$\lim[\frac{f(x)}{g(x)}]=\frac {\lim f(x)}{\lim g(x)}=\frac AB$，且 $B\ne 0$
5. 4的推论，$c$ 为常数，$\lim[cf(x)]=c\lim f(x)$
6. 4的推论，$n$ 为正整数，$\lim[f(x)]^n=[\lim f(x)]^n$
7. 复合函数的极限运算法则，先求内层函数的极限，再把这个极限代回去求外层函数的极限
## 几个重要极限
1. $\lim\limits_{x\rightarrow 0}\frac {\sin x}{x}=1$
2. $\lim\limits_{x\rightarrow 0}\cos x=1$
3. $\lim\limits_{x\rightarrow\infty}\left(1+\frac 1x \right)^x=e$
## 无穷小的比较
### 常见等价无穷小
1. $\sin x\sim x$
2. $\tan x\sim x$
3. $1-\cos x\sim \frac 12 x^2$
4. $e^x-1\sim x$
5. $\ln(1+x)\sim x$
6. $\sqrt[n]{1+x}-1\sim\frac xn$
## 等价无穷小运算法则
设 $\alpha\sim\tilde\alpha,\beta\sim\tilde\beta$，且 $\lim\frac{\tilde\beta}{\tilde\alpha}$ 存在，则 $\lim\frac{\beta}{\alpha}=\lim\frac{\tilde\beta}{\tilde\alpha}$
## 函数的求导法则
1. 设 $u=u(x),v=v(x)$  
$[u+v]'=u'+v'$  
$[u-v]'=u'-v'$  
$[uv]'=u'v+uv'$  
$[\frac uv]'=\frac{u'v+uv'}{v^2}$，且 $v\ne 0$
2. 反函数的求导法则，即函数 $x=f(y)$，反函数 $y=f^{-1}(x)$  
$[f^{-1}(x)]'=\frac 1{f'(y)}$
3. 复合函数的求导法则，即 $y=f(u),u=g(x)$  
$[f(g(x))]'=f'(u)g'(x)$
## 基本初等函数的导数公式
1. $(x^k)'=kx^{k-1}$
2. $(a^x)'=a^x\ln a$
3. $(\log_a x)'=\frac 1{xln a}$
4. $(\sin x)'=\cos x$
5. $(\cos x)'=-\sin x$
6. $(\tan x)'=\sec^2 x$
7. $(\cot x)'=-\csc^2 x$
8. $(\sec x)'=\sec x\tan x$
9. $(\csc x)'=-\csc x\cot x$
10. $(\arcsin x)'=\frac 1{\sqrt{1-x^2}}$
11. $(\arccos x)'=-\frac 1{\sqrt{1-x^2}}$
12. $(\arctan x)'=\frac 1{1+x^2}$
13. $(arccot~x)'=-\frac 1{1+x^2}$
## 高阶导数
对导数再次求导，即可得更高阶导数
## 洛必达法则
对于 $\frac 00,\frac{\infty}{\infty}$ 型的极限的商，不能用“商的极限等于极限的商”这一法则，因此用洛必达法则，即

$\lim\frac{f(x)}{F(x)}=\lim\frac{f'(x)}{F'(x)}$
## 泰勒公式
用多项式近似表达函数，即

$f(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)$
## 题目

### [2021ICPC网络赛2G](https://pintia.cn/market/item/1442013218528759808)
Given $2n$ integers, $a_1,a_2,…,a_n,b_1,b_2,…,b_n,$ and an integer $t$. You need to calculate:

$\lim\limits_{x→0}\frac{\sum\limits_{i=1}^na_i\times ln(1+b_i\times x)}{x^t}$.
#### Input
The first line consists of two integers $n,t$.

In the following $n$ lines, the $i$-th line consists of two integers $a_i,b_i$.

$1≤n≤100000,−100≤a_i,b_i≤100,0≤t≤5$.
#### Output
Please output the result of this limit.

If the result is $\infty$, please output "infinity" (without quotes). And if the result is an integer, please output this integer directly. Otherwise, the answer must be $\frac ab$, such that $a$ and $b$ are coprime and $b≥2$, please output "$a/b$".
#### Sample Input 1
```
2 2
1 1
1 -1
```
#### Sample Output 1
```
-1
```
#### Sample Input 2
```
2 1
1 1
1 -1
```
#### Sample Output 2
```
0
```
#### Sample Input 3
```
2 3
1 1
1 -1
```
#### Sample Output 3
```
infinity
```
#### Solution
$\lim\limits_{x→0}\frac{\sum\limits_{i=1}^na_i\times ln(1+b_i\times x)}{x^t}$

$\sum\limits_{i=1}^na_i\lim\limits_{x→0}\frac{ln(1+b_i\times x)}{x^t}$

直接对后半部分洛必达会发现洛1次之后就不是 $\frac 00$ 的形式，因此泰勒公式来近似后半部分

$f(x)=ln(1+b_i\times x)$

$f'(x)=\frac{b_i}{1+b_ix}$

$f''(x)=\frac{-b_i^2}{1+2b_ix+b_i^2x^2}$

$f'''(x)=\frac{2b_i^3+2b_i^4x}{1+4b_ix+6b_i^2x^2+4b_i^3x^3+b_i^4x^4}$

$f''''(x)=\frac{-6b_i^4-24b_i^5x-36b_i^6x^2-24b_i^7x^3-6b_i^8x^4}{(1+4b_ix+6b_i^2x^2+4b_i^3x^3+b_i^4x^4)^2}$

$f'''''(x)=...$

$x_0=0$

$f(x)=b_ix-\frac 12b_i^2x^2+\frac{1}{3}b_i^3x^3-\frac 1{4}b_i^4x^4+\frac 15b_i^5x^5+...$

$ans=\sum\limits_{i=1}^na_i\lim\limits_{x\to 0}\frac {f(x)}{x^t}$

$t=0,ans=0$

$t=1,ans=\sum\limits_{i=1}^na_ib_i$

$t=2,ans=\sum\limits_{i=1}^na_i\frac{-b_i^2}{2}$

$t=3,ans=\sum\limits_{i=1}^na_i\frac{b_i^3}{3}$

$t=4,ans=\sum\limits_{i=1}^na_i\frac{-b_i^4}{4}$

$...$

由于只有 $\frac 00$ 形式能一直洛，所以中间结果如果不是 $\frac 00$，那答案为 $\infty$
```cpp
ll g[7];
string solve(int n,int t)
{
    if(t==0)
        return "0";
    ll a,b;
    for(int i=0;i<n;++i)
    {
        cin>>a>>b;
        for(int j=1;j<=t;++j)
        {
            a*=b;
            if(j&1)
                g[j]+=a;
            else
                g[j]-=a;
        }
    }
    for(int i=1;i<t;++i)
    {
        if(g[i])
            return "infinity";
    }
    ll gc=__gcd(g[t],(ll)t);
    string ans=to_string(g[t]/gc);
    if(t!=gc)
        ans+=" "+to_string(t/gc);
    return ans;
}
```
### [2021ICPC昆明C](https://ac.nowcoder.com/acm/contest/32708/C)
There is an empty cup, and a dumb robot is going to fill it with $1$ liter of water.

For every turn, the robot will randomly select a real number $t$ between $0$ and $x$ ($x$ is a given number) and then fill the cup with $t$ liter of water. The robot will repeat it until the cup is full (at least $1$ liter of water has been filled).

You need to answer the expected number of turns the robot should fill.
#### Input
The first line contains an integer $T(T\leq 10000)$, denoting the number of test cases.

In the following $T$ lines, each line contains a real number $x(0.05\leq x\leq 10^9)$, describing a test case.

It is guaranteed that $x$ contains no more than $3$ decimal places.
#### Output
For each test case, output one line with a real number, denoting the expected number of turns.

Any answer with a relative or absolute error less than $10^{-4}$ will be accepted.
#### Sample Input 1
```
2
0.3
1.5
```
#### Sample Output 1
```
7.3332227396
1.9477340411
```
#### Solution
设 $f(x)$ 为每次均匀随机走 $[0,a]$，达到大于等于 $x$ 的期望次数，由全期望公式

$$f(x)=1+\int_{max(0,x-a)}^x\frac{f(t)}adt$$

对两边求导

$$af'(x)=f(x)-f(x-a)$$

#### 定义近似计算
$$a\frac{f(x+\Delta x)-f(x)}{\Delta x}=f(x)-f(x-a)$$

$$f(x+\Delta x)=f(x)+\frac{\Delta x}a(f(x)-f(x-a))$$

$f(0)=1$ 表示无穷小期望为1，那么 $ans=f(1)$

由于是多组数据，原问题步长 $[0,a]$，大于等于1的期望步数，等价于，步长 $[0,1]$，大于等于 $\frac 1a$ 的期望步数，故上式改为

$$f(x+\Delta x)=f(x)+\Delta x(f(x)-f(x-1))$$

$ans=f(\frac 1a)$
```cpp
const int maxn = 1e5;
const double dx = 1.0 / maxn;
double f[maxn * 20 + 100];
void init()
{
    f[0] = 1;
    for(int i=0;i<maxn;++i)
        f[i + 1] = (dx+1) * f[i];
    for (int i = maxn; i < 20 * maxn + 99; i++)
        f[i + 1] = f[i] + dx * (f[i] - f[i - maxn]);
}
double solve(double x)
{
    return f[(int)(maxn / x)];
}
```
#### 推精准式子
转化为步长为 $[0,1]$ 的问题

$$f'(x)=f(x)-f(x-1)$$

对 $x$ 范围分类讨论

---
当 $x\in(0,1],f(x-1)=0$

$f'(x)=f(x)$，满足这个式子，已知的有 $e^x$

所以，$f(x)=Ce^x$

当 $x\to 0^+$,$f(x)\to 1$，所以 $f(x)=e^x$

---
当 $x\in(1,2],f(x-1)=e^{x-1}$

$f'(x)=f(x)-e^{x-1}$，满足这个式子，嗯凑凑出 $-xe^{x-1}$

所以，$f(x)=-xe^{x-1}$

当 $x\to 1^-$,$f(x)\to e$，

由于连续性，$x\to 1^+$,$f(x)\to e$，

和 $f(1^+)=-1e^{1-1}$ 差了 $1+e$

因此补上一些东西使式子成立，而 $Ce^x$ 不影响式子成立

所以，$f(x)=Ce^x-xe^{x-1}=(1+\frac 1e)e^x-xe^{x-1}=e^x-(x-1)e^{x-1}$

---
当 $x\in(2,3],f(x-1)=e^{x-1}-(x-2)e^{x-2}$

$f'(x)=f(x)-(e^{x-1}-(x-2)e^{x-2})$，满足这个式子，嗯凑凑出 $-xe^{x-1}+\frac 12(x-2)^2e^{x-2}$

所以，$f(x)=-xe^{x-1}+\frac 12(x-2)^2e^{x-2}$

当 $x\to 2^-$,$f(x)\to e$，

由于连续性，$x\to 1^+$,$f(x)\to e^2-e$，

和 $f(2^+)=-2e^{2-1}$ 差了 $e^2+e$

因此补上一些东西使式子成立，而 $Ce^x$ 不影响式子成立

所以，$f(x)=Ce^x-xe^{x-1}+\frac 12(x-2)^2e^{x-2}=(1+\frac 1e)e^x-xe^{x-1}+\frac 12(x-2)^2e^{x-2}=e^x-(x-1)e^{x-1}+\frac 12(x-2)^2e^{x-2}$

---
仿照以上方法，发现规律，$x\in(k,k+1]$

$$f(x)=\sum\limits_{i=0}^k\frac{(-1)^i}{i!}(x-i)^ie^{x-i}$$

$ans=f(\frac 1a)$
```cpp
double solve(double x)
{
    x = 1 / x;
    double ans = 0, fac = 1;
    for (int i = 0; i < x; i++)
    {
        if (i & 1)
            ans -= fac * pow(x - i, i) * exp(x - i);
        else
            ans += fac * pow(x - i, i) * exp(x - i);
        fac /= (i + 1);
    }
    return ans;
}
```
# 数学杂
## 线性回归

一堆点 $(x_i,y_i)$ ，求一条直线 $F(x):y=Ax+B$ ，使得 $\sum\limits_{i=1}^n (y_i-F(x_i))^2$ 最小

设 $\overline{x}=\frac{\sum\limits_{i=1}^n x_i}n$ ， $\overline{y}=\frac{\sum\limits_{i=1}^n y_i}n$

$A=\frac{\sum\limits_{i=1}^n x_iy_i-n\overline{x} \overline{y}}{\sum\limits_{i=1}^n x_i^2-n\overline{x}^2}$

$B=\overline{y}-A\overline{x}$

## 自然数幂和
$\sum\limits_{i=1}^n i=n(n+1)/2$

$\sum\limits_{i=1}^n i^2=n(n+1)(2n+1)/6$

$\sum\limits_{i=1}^n i^3=n^2(n+1)^2/4$

$\sum\limits_{i=1}^n i^4=n(n+1)(6n^3+9n^2+n-1)/30$

$\sum\limits_{i=1}^n i^5=n^2(n+1)(2n^3+4n^2+n-1)/12$

## 递推式推导

设 $f_n^p=\sum\limits_{i=1}^n i^{p}$

$(n+1)^p-n^p=C_p^1n^{p-1}+C_p^2n^{p-2}+...+1$

$\sum\limits_{n=1}^m(n+1)^p-n^p=\sum\limits_{n=1}^mC_p^1n^{p-1}+C_p^2n^{p-2}+...+1$

$(m+1)^p-1=C_p^1f_m^{p-1}+C_p^2f_m^{p-2}+...+m$

$f_m^{p-1}=((m+1)^p-1-(C_p^2f_m^{p-2}+...+m))/C_p^1$

$f_m^{p}=((m+1)^{p+1}-1-(C_{p+1}^2f_m^{p-1}+...+m))/(p+1)$
## 求法
### 拉格朗日插值
如果有取模，那么模数必须质数

自然数k次幂和是k+1次函数，求前k+2个点的点值，插就完了
```cpp
const int N=1e6+3;
const ll mod=1e9+7;
long long fac[N],inv[N];
long long fast_power(long long base, long long exponent)
{
    long long result = 1;
    for (; exponent > 0; exponent >>= 1)
    {
        if (exponent & 1)
            result = result * base % mod;
        base = base * base % mod;
    }
    return result;
}
void getC()
{
    fac[0]=1;
    for(int i=1;i<N;++i)
        fac[i]=fac[i-1]*i%mod;
    inv[N-1]=fast_power(fac[N-1],mod-2);
    for(int i=N-1;i;--i)
        inv[i-1]=inv[i]*i%mod;
}
struct lagrange
{
    ll y[N],pre[N],suf[N];
    ll lag(ll m,int k)//g(m)，k个点
    {
        if(m<=k)
            return y[m];
        pre[0]=suf[k+1]=1;
        for(int i=1;i<k;++i)
            pre[i]=pre[i-1]*(m-i)%mod;
        for(int i=k;i>1;--i)
            suf[i]=suf[i+1]*(m-i)%mod;
        ll ans=0;
        for(int i=1;i<=k;++i)
            ans=(ans+y[i]*inv[i-1]%mod*inv[k-i]%mod*pre[i-1]%mod*suf[i+1]%mod*((k-i)&1?-1:1))%mod;
        return (ans+mod)%mod;
    }
}la;
getC();
for(int i=1;i<=k+2;++i)
    la.y[i]=(la.y[i-1]+fast_power(i,k))%mod;
cout<<la.lag(n,k+2);
```
### 第2类斯特林数
不需要逆元

$\sum\limits_{i=1}^ni^k=\sum\limits_{j=0}^{k}S_2(k,j)\frac{(n+1)^{\underline{j+1}}}{j+1}$
```cpp
struct powersum
{
    int k;
    ll s[K][K];
    void init(int kk)
    {
        k=kk;
	    s[0][0]=1;
	    for(int i=1;i<=k;++i)
		    for(ll j=1;j<=i;++j)
			    s[i][j]=s[i-1][j-1]+j*s[i-1][j];
    }
    ll cal(ll n)
    {
        ll res,ans=0;
        for(ll i=0;i<=k;++i)
        {
            res=s[k][i];
            for(ll j=0;j<=i;++j)
            {
                if((n+1-j)%(i+1))
                    res=res*(n+1-j);
                else
                    res=res*((n+1-j)/(i+1));
            }
            ans=ans+res;
        }
        return ans;
    }
};
```
## 调和级数近似公式

n 很大时

$f_n\approx \ln n+0.5772156649+\frac 1{2n}$

```cpp
log(n)+0.5772156649+1.0/(2*n)
```
## 狄利克雷前后缀
$O(n\log\log n)$

原缀已知 $a$，求 $b$

逆缀已知 $b$，求 $a$

答案保存在原数组上
## 狄利克雷前缀
$b_n=\sum\limits_{d|n}a_d$
```cpp
for(int i=1;i<=cnt && primes[i]<=n;++i)
{
    for(int j=1;j*primes[i]<=n;++j)
        a[j*primes[i]]+=a[j];
}
```
## 狄利克雷后缀
$b_d=\sum\limits_{d|n}a_n$
```cpp
for(int i=1;i<=cnt && primes[i]<=n;++i)
{
    for(int j=n/primes[i];j;--j)
        a[j]+=a[j*primes[i]];
}
```
## 逆狄利克雷前缀
$b_n=\sum\limits_{d|n}a_d$
```cpp
for(int i=cnt;i;--i)
{
    for(int j=n/primes[i];j;--j)
        a[j*primes[i]]-=a[j];
}
```
## 逆狄利克雷后缀
$b_d=\sum\limits_{d|n}a_n$
```cpp
for(int i=cnt;i;--i)
{
    for(int j=1;j*primes[i]<=n;++j)
        a[j]-=a[j*primes[i]];
}
```
```cpp
const long long N=1e18+1;
const long long N=1e18+(long double)1;
```
上面这个会丢精度，需要改成下面那个

---
n以内两点互质连边，连到m条边停止，可以两层循环，复杂度是 $O(min(n^2,m) log n)$ ，因为互质的还蛮多的

## Fibonacci数
$gcd(F_n,F_m)=F_{gcd(n,m)}$

$\sum\limits_{i=0}^n F_i=F_{n+2}-1$

模m意义下，循环节长度小于等于6m
## 最大质因子个数和最大因子个数
$n\le$|$10^1$|$10^2$|$10^3$|$10^4$|$10^5$|$10^6$|$10^7$|$10^8$|$10^9$|
---|---|---|---|---|---|---|---|---|---
$max\{w(n)\}$|2|3|4|5|6|7|8|8|9
$max\{d(n)\}$|4|12|32|64|128|240|448|768|1344

$n\le$|$10^{10}$|$10^{11}$|$10^{12}$|$10^{13}$|$10^{14}$|$10^{15}$|$10^{16}$|$10^{17}$|$10^{18}$|
---|---|---|---|---|---|---|---|---|---
$max\{w(n)\}$|10|10|11|12|12|13|13|14|15
$max\{d(n)\}$|2304|4032|6720|10752|17280|26880|41472|64512|103680
