* 树状数组
* 线段树
* 可持久化线段树
* 可持久化权值线段树
* zkw线段树
* 倍增LCA
* 树链剖分
* 并查集
* 莫队
* ST表
# 树状数组
## 单点更新、区间查询
```c++
struct BIT
{
    int n;
    ll sum[N];
    int lowbit(int x)
    {
        return x&(-x);
    }
    void init(int nn)
    {
        n=nn;
        memset(sum,0,sizeof(sum[0])*(n+1));
    }
    void update(int pos,ll val)
    {
        for(;pos<=n;pos+=lowbit(pos))
            sum[pos]+=val;
    }
    ll query(int pos)
    {
        ll res=0;
        for(;pos>0;pos-=lowbit(pos))
            res+=sum[pos];
        return res;
    }
    ll query(int l,int r)
    {
        return query(r)-query(l-1);
    }
}bit;
bit.init(n);
for(int i=1;i<=n;++i)
    bit.update(i,a[i]);
bit.update(pos,val);
bit.query(l,r);
```
## 区间更新、单点查询
A为原数组，D为差分数组

$A[i] = \sum\limits_{j=1}^i D[j]$;

当 $[l,r]$ 值改变了，只有 D[l] 和 D[r+1] 的值发生改变
```c++
struct BIT
{
    int n;
    ll a[N];
    int lowbit(int x)
    {
        return x&(-x);
    }
    void init(int n)
    {
        this->n=n;
        memset(a,0,sizeof(ll)*(n+1));
    }
    void update(int pos,int val)
    {
        for(;pos<=n;pos+=lowbit(pos))
            a[pos]+=val;
    }
    void update(int l,int r,int val)
    {
        update(l,val);
        update(r+1,-val);
    }
    ll query(int pos)
    {
        ll res=0;
        for(;pos>0;pos-=lowbit(pos))
            res+=a[pos];
        return res;
    }
}bit;
bit.init(n);
for(int i=1;i<=n;++i)
    bit.update(i,a[i] - a[i-1]);
bit.update(l,r,k);
bit.query(i);
```
## 区间更新、区间查询
A为原数组，D为差分数组

$\sum\limits_{i=1}^n A[i] = \sum\limits_{i=1}^n \sum\limits_{j=1}^i D[j]$

$=\sum\limits_{i=1}^n (n+1-i)\times D[i]$

$=\left[n\sum\limits_{i=1}^n D[i]\right]-\left[\sum\limits_{i=1}^n (i-1)D[i]\right]$

维护两个树状数组，sum1[i] = D[i]，sum2[i] = D[i]*(i-1);
```c++
struct BIT
{
    int n;
    ll a[N],b[N];
    int lowbit(int x)
    {
        return x&(-x);
    }
    void init(int n)
    {
        this->n=n;
        memset(a,0,sizeof(ll)*(n+1));
        memset(b,0,sizeof(ll)*(n+1));
    }
    void update(int pos,int val)
    {
        int x=pos;
        for(;pos<=n;pos+=lowbit(pos))
        {
            a[pos]+=val;
            b[pos]+=val*(x-1);
        }
    }
    void update(int l,int r,int val)
    {
        update(l,val);
        update(r+1,-val);
    }
    ll query(int pos)
    {
        int x=pos;
        ll res=0;
        for(;pos>0;pos-=lowbit(pos))
            res+=x*a[pos]-b[pos];
        return res;
    }
    ll query(int l,int r)
    {
        return query(r)-query(l-1);
    }
}bit;
bit.init();
for(int i=1;i<=n;++i)
    bit.update(i,a[i] - a[i-1]);
bit.update(l,r,k);
bit.query(l,r);
```
## 二维树状数组
```cpp
struct BIT
{
    int n,m;
    int sum[N][N];
    int lowbit(int x)
    {
        return x & (-x);
    }
    void init(int nn,int mm)
    {
        n=nn;
        m=mm;
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= m; ++j)
                sum[i][j] = 0;
    }
    void update(int x, int y, int val)
    {
        int tmp = y;
        for (; x <= n; x += lowbit(x))
            for (y = tmp; y <= m; y += lowbit(y))
                sum[x][y] += val;
    }
    int query(int x, int y)
    {
        int res = 0, tmp = y;
        for (; x > 0; x -= lowbit(x))
            for (y = tmp; y > 0; y -= lowbit(y))
                res += sum[x][y];
        return res;
    }
    int query(int x1, int y1, int x2, int y2)
    {
        return query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);
    }
} bit;
```
# 线段树
如果混用单点修改和区间修改，单点修改时需要下传标记
## 区间修改，区间查询
```c++
const int N=1e5+3;
struct SegmentTree
{
    int segl[N << 2], segr[N << 2];
    ll st[N << 2], lz[N << 2];
    ll merge1(ll x, ll y) //修改
    {
        return x + y;
    }
    ll merge2(ll x, ll y) //查询
    {
        return x+y;
    }
    void pushup(int id)
    {
        st[id] = merge2(st[id << 1], st[id << 1 | 1]);
    }
    void pushdown(int id)
    {
        if (!lz[id])
            return;
        lz[id << 1] = merge1(lz[id << 1], lz[id]);
        lz[id << 1 | 1] = merge1(lz[id << 1 | 1], lz[id]);
        st[id << 1] = merge1(st[id << 1], lz[id] * (segr[id << 1] - segl[id << 1] + 1));
        st[id << 1 | 1] = merge1(st[id << 1 | 1], lz[id] * (segr[id << 1 | 1] - segl[id << 1 | 1] + 1));
        lz[id] = 0;
    }
    void build(int id, int l, int r)
    {
        segl[id] = l;
        segr[id] = r;
        if (l == r)
        {
            st[id] = a[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(id << 1, l, mid);
        build(id << 1 | 1, mid + 1, r);
        pushup(id);
    }
    void update(int id, int L, int R, ll val)
    {
        if (L <= segl[id] && segr[id] <= R)
        {
            st[id] = merge1(st[id], val * (segr[id] - segl[id] + 1));
            lz[id] = merge1(lz[id], val);
            return;
        }
        int mid = (segl[id] + segr[id]) >> 1;
        pushdown(id);
        if (L <= mid)
            update(id << 1, L, R, val);
        if (R > mid)
            update(id << 1 | 1, L, R, val);
        pushup(id);
    }
    ll query(int id, int L, int R)
    {
        if (L <= segl[id] && segr[id] <= R)
            return st[id];
        int mid = (segl[id] + segr[id]) >> 1;
        pushdown(id);
        ll res = 0;
        if (L <= mid)
            res = merge2(res, query(id << 1, L, R));
        if (R > mid)
            res = merge2(res, query(id << 1 | 1, L, R));
        return res;
    }
    void init(int n)
    {
        memset(lz, 0, sizeof(lz[0]) * (n << 2));
        build(1, 1, n);
    }
} st;
st.init(n);
st.update(1,l,r,val);
st.query(1,l,r);
```
## 单点修改，区间查询
```c++
const int N=1e5+3;
struct SegmentTree
{
    int segL[N<<2],segR[N<<2];
    ll sum[N<<2];
    void pushup(int id)
    {
        sum[id]=sum[id<<1]+sum[id<<1|1];
    }
    void build(int id,int l,int r)
    {
        segL[id]=l;
        segR[id]=r;
        if(l==r)
        {
            sum[id]=a[l];
            return;
        }
        int mid=(l+r)>>1;
        build(id<<1,l,mid);
        build(id<<1|1,mid+1,r);
        pushup(id);
    }
    void update(int id,int pos,ll val)
    {
        if(segL[id]==segR[id])
        {
            sum[id]+=val;
            return;
        }
        if(pos<=((segL[id]+segR[id])>>1))
            update(id<<1,pos,val);
        else
            update(id<<1|1,pos,val);
        pushup(id);
    }
    ll query(int id,int L,int R)
    {
        if(L<=segL[id] && segR[id]<=R)
            return sum[id];
        int mid=(segL[id]+segR[id])>>1;
        ll res=0;
        if(L<=mid)
            res+=query(id<<1,L,R);
        if(R>mid)
            res+=query(id<<1|1,L,R);
        return res;
    }
    void init(int n)
    {
        build(1,1,n);
    }
}st;
st.init(n);
st.update(1,pos,val);
st.query(1,l,r);
```
# 可持久化线段树
```c++
const int N=1e5+3;
struct persistentSegmentTree
{
    int tot,n,rootnum;
    int root[N];
    int lson[N<<5],rson[N<<5];
    ll sum[N<<5],mark[N<<5];
    void build(int l,int r,int id)
    {
        if(l==r)
        {
            sum[id]=a[l];
            mark[id]=0;
            return;
        }
        lson[id]=++tot;
        rson[id]=++tot;
        int mid=(l+r)>>1;
        build(l,mid,lson[id]);
        build(mid+1,r,rson[id]);
        sum[id]=sum[lson[id]]+sum[rson[id]];
    }
    int update(int ul,int ur,ll val,int pre,int l,int r)
    {
        ++tot;
        lson[tot]=lson[pre];
        rson[tot]=rson[pre];
        mark[tot]=mark[pre];
        sum[tot]=sum[pre]+(ll)(min(r,ur)-max(l,ul)+1)*val;
        if(ul<=l && r<=ur)
        {
            mark[tot]+=val;
            return tot;
        }
        int now=tot,mid=(l+r)>>1;
        if(l<=ur && mid>=ul)
            lson[now]=update(ul,ur,val,lson[now],l,mid);
        if(mid<ur && r>=ul)
            rson[now]=update(ul,ur,val,rson[now],mid+1,r);
        return now;
    }
    ll query(int ql,int qr,ll mk,int id,int l,int r)
    {
        if(l>qr || ql>r)
            return 0;
        if(ql<=l && r<=qr)
            return sum[id]+mk*(r-l+1);
        int mid=(l+r)>>1;
        return query(ql,qr,mk+mark[id],lson[id],l,mid)+query(ql,qr,mk+mark[id],rson[id],mid+1,r);
    }
    void update(int l,int r,ll val)//区间修改
    {
        root[rootnum+1]=update(l,r,val,root[rootnum],1,n);
        ++rootnum;
    }
    ll query(int l,int r,int rt)//指定根的区间查询
    {
        return query(l,r,0,root[rt],1,n);
    }
    void init(int n)
    {
        tot=rootnum=0;
        this->n=n;
        root[0]=sum[0]=0;
        build(1,n,0);
    }
}pst;
pst.init(n);
pst.update(l,r,w);
pst.query(l,r,rt);
```
# 可持久化权值线段树
```c++
const int N=1e5+3;
struct persistentWeightSegmentTree
{
    int tot,q;//动态开点
    int root[N];
    int lson[N<<5],rson[N<<5],val[N<<5];
    void init(int n)//原数组a（从1开始），离散数组C
    {
        root[0]=val[0]=lson[0]=rson[0]=0;
        tot=0;
        memcpy(C+1,a+1,sizeof(a[0])*(n));
        sort(C+1,C+n+1);
        q=unique(C+1,C+n+1)-C-1;
        for(int i=1;i<=n;++i)
            root[i]=modify(root[i-1],1,q,lower_bound(C+1,C+q+1,a[i])-C);
    }
    int modify(int pre,int l,int r,int pos)
    {
        ++tot;
        lson[tot]=lson[pre];
        rson[tot]=rson[pre];
        val[tot]=val[pre]+1;
        if(l==r)
            return tot;
        int now=tot,mid=(l+r)>>1;
        if(pos<=mid)
            lson[now]=modify(lson[now],l,mid,pos);
        else
            rson[now]=modify(rson[now],mid+1,r,pos);
        return now;
    }
    int query(int u,int v,int l,int r,int k)//查询区间[u,v]的第k小值的下标
    {
        if(l==r)
            return l;
        int mid=(l+r)>>1,x=val[lson[v]]-val[lson[u]];
        if(x>=k)
            return query(lson[u],lson[v],l,mid,k);
        return query(rson[u],rson[v],mid+1,r,k-x);
    }
    int ask(int l,int r,int k)
    {
        return C[query(root[l-1],root[r],1,q,k)];
    }
}wt;
wt.init(n);
wt.ask(l,r,k);
```
# zkw线段树
```cpp
struct zkwSegmentTree
{
    int sum[N<<2];
    int N;
    void Build(int n)
    {
        N=1;
        while(N<n+2)
            N<<=1;
        for(int i=1;i<=n;++i)
            sum[N+i]=A[i];
        for(int i=N-1;i;--i)
        {
            sum[i]=sum[i<<1]+sum[i<<1|1];
        }
    }
    void Update(int q,int c)
    {
        for(int i=N+q;i;i>>=1)
            sum[i]+=c;
    }
    int Query(int l,int r)
    {
        int ans=0;
        for(int L=N+l-1,R=N+r+1;L^R^1;L>>=1,R>>=1)
        {
            if(~L&1)
                ans+=sum[L+1];
            if(R&1)
                ans+=sum[R-1];
        }
        return ans;
    }
}
```
# 倍增LCA
```cpp
const int N = 5e5 + 3;
const int M = 20;
struct EDGE
{
    int to, nxt;
};
struct LCA
{
    EDGE e[N << 1];
    int fa[N][M], dep[N], head[N], lg[N];
    int tot;
    queue<int> q;
    void init(int n)
    {
        tot = 0;
        for (int i = 1; i < n; ++i)
            lg[i] = lg[i - 1] + (1 << lg[i - 1] == i);
    }
    void AddEdge(int u, int v)
    {
        e[++tot] = {u, head[v]};
        head[v] = tot;
        e[++tot] = {v, head[u]};
        head[u] = tot;
    }
    void bfs(int root)
    {
        q.push(root);
        dep[root] = 1;
        int u, v, DEP;
        while (!q.empty())
        {
            u = q.front();
            q.pop();
            for (int i = head[u]; i; i = e[i].nxt)
            {
                v = e[i].to;
                if (dep[v])
                    continue;
                q.push(v);
                dep[v] = dep[u] + 1;
                fa[v][0] = u;
                DEP = lg[dep[u]];
                for (int j = 1; j <= DEP; ++j)
                {
                    fa[v][j] = fa[fa[v][j - 1]][j - 1];
                }
            }
        }
    }
    int lca(int x, int y)
    {
        if (dep[x] > dep[y])
            swap(x, y);
        for (int i = 0, dif = dep[y] - dep[x]; dif; ++i, dif >>= 1)
        {
            if (dif & 1)
                y = fa[y][i];
        }
        if (x == y)
            return x;
        for (int i = lg[dep[x]]; i >= 0; --i)
        {
            if (fa[x][i] == fa[y][i])
                continue;
            x = fa[x][i];
            y = fa[y][i];
        }
        return fa[x][0];
    }
};
```
```cpp
const int N = 4e4 + 3;
const int M = 20;
struct EDGE
{
    int to, nxt;
    ll w;
};
struct LCA
{
    EDGE e[N << 1];
    int fa[N][M], dep[N], head[N], lg[N];
    ll cost[N][M];
    int tot;
    queue<int> q;
    void init0()
    {
        lg[0] = 0;
        for (int i = 1; i < N; ++i)
            lg[i] = lg[i - 1] + (1 << (lg[i - 1]) == i);
    }
    void init(int n)
    {
        tot = 0;
        memset(head, 0, sizeof(int) * (n + 1));
        memset(dep, 0, sizeof(int) * (n + 1));
    }
    void AddEdge(int u, int v, ll w)
    {
        e[++tot] = {u, head[v], w};
        head[v] = tot;
        e[++tot] = {v, head[u], w};
        head[u] = tot;
    }
    void bfs(int root)
    {
        q.push(root);
        dep[root] = 1;
        int u, v, DEP;
        while (!q.empty())
        {
            u = q.front();
            q.pop();
            for (int i = head[u]; i; i = e[i].nxt)
            {
                v = e[i].to;
                if (dep[v])
                    continue;
                q.push(v);
                dep[v] = dep[u] + 1;
                fa[v][0] = u;
                cost[v][0] = e[i].w;
                DEP = lg[dep[u]];
                for (int j = 1; j <= DEP; ++j)
                {
                    fa[v][j] = fa[fa[v][j - 1]][j - 1];
                    cost[v][j] = cost[fa[v][j - 1]][j - 1] + cost[v][j - 1];
                }
            }
        }
    }
    int lca(int x, int y)
    {
        if (dep[x] > dep[y])
            swap(x, y);
        ll ans = 0;
        for (int i = 0, dif = dep[y] - dep[x]; dif; ++i, dif >>= 1)
        {
            if (dif & 1)
            {
                ans += cost[y][i];
                y = fa[y][i];
            }
        }
        if (x == y)
            return ans;
        for (int i = lg[dep[x]]; i >= 0; --i)
        {
            if (fa[x][i] == fa[y][i])
                continue;
            ans += cost[x][i] + cost[y][i];
            x = fa[x][i];
            y = fa[y][i];
        }
        return ans + cost[x][0] + cost[y][0];
    }
};
```
# 树链剖分
## 点权
```cpp
const int N = 5e4 + 3;
ll W[N], revW[N];
struct edge
{
    int v, nxt;
};
struct SegmentTree
{
    int segL[N << 2], segR[N << 2];
    ll sum[N << 2], lazy[N << 2];
    void pushup(int id)
    {
        sum[id] = sum[id << 1] + sum[id << 1 | 1];
    }
    void pushdown(int id)
    {
        if (!lazy[id])
            return;
        lazy[id << 1] += lazy[id];
        lazy[id << 1 | 1] += lazy[id];
        sum[id << 1] += lazy[id] * (segR[id << 1] - segL[id << 1] + 1);
        sum[id << 1 | 1] += lazy[id] * (segR[id << 1 | 1] - segL[id << 1 | 1] + 1);
        lazy[id] = 0;
    }
    void build(int id, int l, int r)
    {
        segL[id] = l;
        segR[id] = r;
        if (l == r)
        {
            sum[id] = revW[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(id << 1, l, mid);
        build(id << 1 | 1, mid + 1, r);
        pushup(id);
    }
    void update(int id, int L, int R, ll val)
    {
        if (L <= segL[id] && segR[id] <= R)
        {
            sum[id] += val * (segR[id] - segL[id] + 1);
            lazy[id] += val;
            return;
        }
        int mid = (segL[id] + segR[id]) >> 1;
        pushdown(id);
        if (L <= mid)
            update(id << 1, L, R, val);
        if (R > mid)
            update(id << 1 | 1, L, R, val);
        pushup(id);
    }
    ll query(int id, int L, int R)
    {
        if (L <= segL[id] && segR[id] <= R)
            return sum[id];
        int mid = (segL[id] + segR[id]) >> 1;
        pushdown(id);
        ll res = 0;
        if (L <= mid)
            res += query(id << 1, L, R);
        if (R > mid)
            res += query(id << 1 | 1, L, R);
        return res;
    }
    void init(int n)
    {
        memset(lazy, 0, sizeof(lazy[0]) * (n << 2));
        build(1, 1, n);
    }
};
struct heavyPathDecomposition
{
    int edgeTot, n, dfsOrder, head[N];
    edge e[N << 1];
    int son[N], siz[N], dep[N], fa[N];
    int top[N], dfn[N];
    SegmentTree st;
    void init(int nn)
    {
        n = nn;
        memset(head, 0, sizeof(int) * (n + 1));
        memset(son, -1, sizeof(int) * (n + 1));
        edgeTot = 0;
        dfsOrder = 0;
    }
    void init2()
    {
        dep[1] = 1;
        dfs1(1);
        dfs2(1, 1);
        for (int i = 1; i <= n; ++i)
            revW[dfn[i]] = W[i];
        st.init(n);
    }
    void addEdge(int u, int v)
    {
        e[++edgeTot] = {v, head[u]};
        head[u] = edgeTot;
    }
    void dfs1(int u)
    {
        siz[u] = 1;
        int v;
        for (int i = head[u]; i; i = e[i].nxt)
        {
            v = e[i].v;
            if (v == fa[u])
                continue;
            dep[v] = dep[u] + 1;
            fa[v] = u;
            dfs1(v);
            siz[u] += siz[v];
            if (son[u] == -1 || siz[v] > siz[son[u]])
                son[u] = v;
        }
    }
    void dfs2(int u, int Top)
    {
        top[u] = Top;
        dfn[u] = ++dfsOrder;
        if (son[u] == -1)
            return;
        dfs2(son[u], Top);
        for (int i = head[u]; i; i = e[i].nxt)
        {
            if (e[i].v != son[u] && e[i].v != fa[u])
                dfs2(e[i].v, e[i].v);
        }
    }
    ll querySum(int u, int v)
    {
        ll res = 0;
        while (top[u] != top[v])
        {
            if (dep[top[u]] < dep[top[v]])
                swap(u, v);
            res += st.query(1, dfn[top[u]], dfn[u]);
            u = fa[top[u]];
        }
        if (dfn[u] > dfn[v])
            swap(u, v);
        return res + st.query(1, dfn[u], dfn[v]);
    }
    void update(int u, int v, ll x)
    {
        while (top[u] != top[v])
        {
            if (dep[top[u]] < dep[top[v]])
                swap(u, v);
            st.update(1, dfn[top[u]], dfn[u], x);
            u = fa[top[u]];
        }
        if (dfn[u] > dfn[v])
            swap(u, v);
        st.update(1, dfn[u], dfn[v], x);
    }
} hp;
hp.init(n);
hp.addEdge(u,v);
hp.init2();
hp.update(u,v,x);
hp.querySum(u,v);
```
## 边权
```cpp
const int N = 1e5 + 3;
ll revW[N];
struct edge
{
    int v, nxt, id;
    ll w;
};
struct SegmentTree
{
    int segL[N << 2], segR[N << 2];
    ll sum[N << 2];
    void pushup(int id)
    {
        sum[id] = sum[id << 1] + sum[id << 1 | 1];
    }
    void build(int id, int l, int r)
    {
        segL[id] = l;
        segR[id] = r;
        if (l == r)
        {
            sum[id] = revW[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(id << 1, l, mid);
        build(id << 1 | 1, mid + 1, r);
        pushup(id);
    }
    void update(int id, int pos, ll val)
    {
        if (segL[id] == segR[id])
        {
            sum[id] += val;
            return;
        }
        if (pos <= ((segL[id] + segR[id]) >> 1))
            update(id << 1, pos, val);
        else
            update(id << 1 | 1, pos, val);
        pushup(id);
    }
    ll query(int id, int L, int R)
    {
        if (L <= segL[id] && segR[id] <= R)
            return sum[id];
        int mid = (segL[id] + segR[id]) >> 1;
        ll res = 0;
        if (L <= mid)
            res += query(id << 1, L, R);
        if (R > mid)
            res += query(id << 1 | 1, L, R);
        return res;
    }
};
struct heavyPathDecomposition
{
    int edgeTot, n, dfsOrder, head[N];
    edge e[N << 1];
    int son[N], siz[N], dep[N], fa[N];
    int top[N], dfn[N];
    int match[N];
    ll W[N];
    SegmentTree st;
    void init(int nn)
    {
        n = nn;
        memset(head, 0, sizeof(int) * (n + 1));
        memset(son, -1, sizeof(int) * (n + 1));
        edgeTot = 0;
        dfsOrder = -1;
    }
    void init2()
    {
        dep[1] = 1;
        dfs1(1);
        dfs2(1, 1);
        for (int i = 2; i <= n; ++i)
            revW[dfn[i]] = W[i];
        st.build(1, 1, n - 1);
    }
    void addEdge(int u, int v, int id, ll w)
    {
        ++edgeTot;
        e[edgeTot].v = v;
        e[edgeTot].nxt = head[u];
        e[edgeTot].id = id;
        e[edgeTot].w = w;
        head[u] = edgeTot;
    }
    void dfs1(int u)
    {
        siz[u] = 1;
        int v;
        for (int i = head[u]; i; i = e[i].nxt)
        {
            v = e[i].v;
            if (v == fa[u])
                continue;
            dep[v] = dep[u] + 1;
            fa[v] = u;
            match[e[i].id] = v;
            W[v] = e[i].w;
            dfs1(v);
            siz[u] += siz[v];
            if (son[u] == -1 || siz[v] > siz[son[u]])
                son[u] = v;
        }
    }
    void dfs2(int u, int Top)
    {
        top[u] = Top;
        dfn[u] = ++dfsOrder;
        if (son[u] == -1)
            return;
        dfs2(son[u], Top);
        for (int i = head[u]; i; i = e[i].nxt)
        {
            if (e[i].v != son[u] && e[i].v != fa[u])
                dfs2(e[i].v, e[i].v);
        }
    }
    ll querySum(int u, int v)
    {
        ll res = 0;
        while (top[u] != top[v])
        {
            if (dep[top[u]] < dep[top[v]])
                swap(u, v);
            res += st.query(1, dfn[top[u]], dfn[u]);
            u = fa[top[u]];
        }
        if (dfn[u] > dfn[v])
            swap(u, v);
        if (u != v)
            res += st.query(1, dfn[u] + 1, dfn[v]);
        return res;
    }
    void update(int i, ll x)
    {
        st.update(1, dfn[match[i]], x);
    }
} hp;
hp.init(n);
hp.addEdge(u,v,i,w);
hp.init2();
hp.update(i,x);
hp.querySum(u,v);
```
## lca
```cpp
const int N = 5e4 + 3;
struct edge
{
    int v, nxt;
};
struct heavyPathDecomposition
{
    int edgeTot,head[N];
    edge e[N<<1];
    int son[N], siz[N], dep[N], fa[N];
    int top[N];
    void init(int n)
    {
        memset(head, 0, sizeof(int) * (n + 1));
        memset(son, -1, sizeof(int) * (n + 1));
        edgeTot = 0;
    }
    void init2()
    {
        dep[1] = 1;
        dfs1(1);
        dfs2(1,1);
    }
    void addEdge(int u, int v)
    {
        e[++edgeTot] = {v, head[u]};
        head[u] = edgeTot;
    }
    void dfs1(int u)
    {
        siz[u] = 1;
        int v;
        for (int i = head[u]; i; i = e[i].nxt)
        {
            v = e[i].v;
            if (v == fa[u])
                continue;
            dep[v] = dep[u] + 1;
            fa[v] = u;
            dfs1(v);
            siz[u] += siz[v];
            if (son[u] == -1 || siz[v] > siz[son[u]])
                son[u] = v;
        }
    }
    void dfs2(int u, int Top)
    {
        top[u] = Top;
        if (son[u] == -1)
            return;
        dfs2(son[u], Top);
        for (int i = head[u]; i; i = e[i].nxt)
        {
            if (e[i].v != son[u] && e[i].v != fa[u])
                dfs2(e[i].v, e[i].v);
        }
    }
    int lca(int u,int v)
    {
        while(top[u]!=top[v])
        {
            if(dep[top[u]]<dep[top[v]])
                swap(u,v);
            u=fa[top[u]];
        }
        return (dep[u]>dep[v]?v:u);
    }
}hp;
hp.init(n);
hp.addEdge(u,v);
hp.init2();
hp.lca(u,v);
```
# 并查集
```cpp
int fa[MAXN],ran[MAXN];
inline void init(int n)
{
    memset(fa,-1,sizeof(int)*(n+1));
    memset(ran,0,sizeof(int)*(n+1));
}
int find(int x)
{
    return fa[x] == -1 ? x : (fa[x] = find(fa[x]));
}
inline void merge(int i, int j)
{
    int x = find(i), y = find(j);
    if (ran[x] <= ran[y])
        fa[x] = y;
    else
        fa[y] = x;
    if (ran[x] == ran[y] && x != y)
        ran[y]++;
}
```
# 莫队
```cpp
struct query
{
    int l, r, id;
    bool operator<(const query &o) const
    {
        if (l / sq != o.l / sq) 
            return l < o.l;
        if (l / sq & 1)
            return r < o.r;
        return r > o.r;
    }
}Q[MAXQ];
for (int i = 0; i < q; ++i)
{
    cin>>Q[i].l>>Q[i].r;
    Q[i].id = i;
}
sq=sqrt(n);
sort(Q, Q + q);
l=1;
r=0;
for (int i = 0; i < q; ++i)
{
    while (l > Q[i].l)
        add(--l);
    while (r < Q[i].r)
        add(++r);
    while (l < Q[i].l)
        del(l++);
    while (r > Q[i].r)
        del(r--);
    ans[Q[i].id] = res;
}
```
# ST表
```cpp
const int N = 5e4 + 3;
const int M = log2(N) + 1;
struct SparseTable
{
    int st[N][M];
    int merge(int x, int y)
    {
        return min(x, y);
    }
    void init(int n)
    {
        int m=log2(n)+1;
        for (int i = 1; i <= n; ++i)
            st[i][0] = a[i];
        for (int i = 1; i < m; ++i)
        {
            for (int j = 1; j + (1 << i) - 1 <= n; ++j)
                st[j][i] = merge(st[j][i - 1], st[j + (1 << (i - 1))][i - 1]);
        }
    }
    int query(int l, int r)
    {
        int s = __lg(r - l + 1);
        return merge(st[l][s], st[r - (1 << s) + 1][s]);
    }
}st;