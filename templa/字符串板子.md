* 字符串哈希
* Kmp&EXkmp
* manacher
* trie
# 字符串哈希
```cpp
const ull base=131;
const ull mod=1e9+9;
ull has[N],power[N];
void init()
{
    power[0]=1;
    for(int i=1;i<N;++i)
        power[i]=power[i-1]*base%mod;
}
void Hash(string s)
{
    s=" "+s;
    int len=s.length();
    has[0]=0;
    for(int i=1;i<=len;++i)
        has[i]=(has[i-1]*base+s[i]-'a'+1)%mod;
}
ull getSectionHash(int l,int r)
{
    return (has[r]-has[l-1]*power[r-l+1]%mod+mod)%mod;
}
```
## 判断回文串
```cpp
h[r]-h[l-1]*p[r-l+1]==r[n-l+1]-r[n-r]*p[r-l+1]
```
# kmp
```cpp
char txt[N],str[N];//字符串都从1开始
int nxt[N];//P[0]~P[x-1] 这一段字符串，使得前缀等于后缀的最长长度
void getNext()
{
    int i=2,j=0,len=strlen(str+1);
	for(;i<=len;++i)
	{
		while(j && str[i]!=str[j+1])
            j=nxt[j];
		if(str[i] == str[j+1])
            ++j;
		nxt[i] = j; 
	}
}
void KMP()
{
    int i=1,j=0,len1=strlen(txt+1),len2=strlen(str+1);
    for(;i<=len1;++i)
	{
		while(j && txt[i]!=str[j+1])
            j=nxt[j];
		if(txt[i] == str[j+1])
            ++j;
		if(j == len2-1)
		{
			j=nxt[j];
			cout<<i-len2+2<<"\n";
		}
	}
}
```
# EXkmp
```cpp
//EXKMP
#define MAXN 100
char s1[MAXN],s2[MAXN];
int next[MAXN],ex[MAXN];
void Getnext(char *str)
{
    int i=0,j,po,len=strlen(str);
    next[0]=len;
    while(i+1<len && str[i]==str[i+1])
        ++i;
    next[1]=i;
    po=1;
    for(int i=2;i<len;++i)
    {
        if(next[i-po]+i<next[po]+po)
            next[i]=next[i-po];
        else
        {
            j=next[po]+po-i;
            if(j<0)
                j=0;
            while(i+j<len && str[j]==str[i+j])
                ++j;
            next[i]=j;
            po=i;
        }
    }
}
void EXKMP(char *s1,char *s2)
{
    int i=0,j,po,len1=strlen(s1),len2=strlen(s2);
    while(i<len1 && i<len2 && s1[i]==s2[i])
        ++i;
    ex[0]=i;
    po=0;
    for(i=1;i<len1;++i)
    {
        if(next[i-po]+i<ex[po]+po)
            ex[i]=next[i-po];
        else
        {
            j=ex[po]+po-i;
            if(j<0)
                j=0;
            while(i+j<len1 && j<len2 && s1[i+j]==s2[j])
                ++j;
            ex[i]=j;
            po=i;
        }
    }
}
```
# manacher
```cpp
string Mannacher(string s)
{
    //插入"#"
    string t="$#";
    for(int i=0;i<s.size();++i)
    {
        t+=s[i];
        t+="#";
    }
    vector<int> p(t.size(),0);
    //mx表示某个回文串延伸在最右端半径的下标，id表示这个回文子串最中间位置下标
    //resLen表示对应在s中的最大子回文串的半径，resCenter表示最大子回文串的中间位置
    int mx=0,id=0,resLen=0,resCenter=0;
     //建立p数组
    for(int i=1;i<t.size();++i)
    {
        p[i]=mx>i ? min(p[2*id-i],mx-i) : 1;
        //遇到三种特殊的情况，需要利用中心扩展法
        while(t[i+p[i]]==t[i-p[i]])
            ++p[i];
        //半径下标i+p[i]超过边界mx，需要更新
        if(mx<i+p[i])
        {
            mx=i+p[i];
            id=i;
        }
        //更新最大回文子串的信息，半径及中间位置
        if(resLen<p[i])
        {
            resLen=p[i];
            resCenter=i;
        }
    }
    //最长回文子串长度为半径-1，起始位置为中间位置减去半径再除以2
    return s.substr((resCenter-resLen)/2,resLen-1);
}
```
# trie
```c++
const int STR=26;
struct TRIE
{
    int trie[N][STR],tot;
    bool exist[N];
    void init()
    {
        for(;tot>=0;--tot)
        {
            exist[tot]=0;
            for(int j=0;j<STR;++j)
                trie[tot][j]=0;
        }
        tot=0;
    }
    void insert(char *str)
    {
        int root = 0,id;
        for (char s:str)
        {
            id= s - 'a';
            if(!trie[root][id])
                trie[root][id] = ++tot;
            root = trie[root][id];
        }
        exist[root] = 1;
    }
    bool find(char *str)
    {
        int root = 0,id;
        for (char s:str)
        {
            id= s - 'a';
            if(!trie[root][id])
                return 0;
            root = trie[root][id];
        }
        return exist[root];
    }
};
```
```c++
const int STR=2;
struct TRIE
{
    int trie[N][STR],tot;
    bool exist[N];
    void init()
    {
        for(;tot>=0;--tot)
        {
            exist[tot]=0;
            for(int j=0;j<STR;++j)
                trie[tot][j]=0;
        }
        tot=0;
    }
    void insert(ll x)
    {
        int root = 0,id;
        for(int i=30;i>=0;--i)
        {
            id= (x>>i)&1;
            if(!trie[root][id])
                trie[root][id] = ++tot;
            root = trie[root][id];
        }
        exist[root] = 1;
    }
};
```