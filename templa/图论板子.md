- 最小生成树
- 网络流
- 最短路
- 拓扑排序
- 杂

# 拓扑排序

```cpp
struct topuSort
{
    queue<int> q;
    int in[N];
    vector<int> edge[N];
    int n;
    void init(int nn)
    {
        n=nn;
        memset(in,0,sizeof(int)*(n+1));
        for(int i=1;i<=n;++i)
            e[i].clear();
        while(!q.empty())
            q.pop();
    }
    void addEdge(int u,int v)
    {
        e[u].push_back(v);
    }
    bool run()
    {
        for(int i=1;i<=n;++i)
        {
            if(!in[i])
                q.push(i);
        }
        int u,cnt=0;
        while(!q.empty())
        {
            u=q.front();
            q.pop();
            ++cnt;
            for(int v:e[u])
            {
                if(--in[v]==0)
                    q.push(v);
            }
        }
        return cnt==n;
    }
}
```

# 网络流 DINIC

```c++
const int N=2e2+5;
const int M=1e6+3;
const ll INF=1e18;
struct Edge
{
    int v,nxt;
    ll cap;
};
struct Dinic
{
    int n,s,t,tot;
    int head[N],dep[N];
    Edge e[M];
    queue<int> q;
    void init(int nn,int ss,int tt)
    {
        n=nn;
        s=ss;
        t=tt;
        memset(head,0,sizeof(int)*(n+1));
        head[s]=head[t]=0;
        tot=1;
    }
    void addEdge(int x,int y,ll cap)
    {
        e[++tot]={y,head[x],cap};
        head[x]=tot;
        e[++tot]={x,head[y],0};
        head[y]=tot;
    }
    bool level()
    {
        memset(dep,0,sizeof(int)*(n+1));
        dep[t]=0;
        dep[s]=1;
        int u,v;
        q.push(s);
        while(!q.empty())
        {
            u=q.front();
            q.pop();
            for(int i=head[u];i;i=e[i].nxt)
            {
                v=e[i].v;
                if(e[i].cap && !dep[v])
                {
                    dep[v]=dep[u]+1;
                    q.push(v);
                }
            }
        }
        return dep[t];
    }
    ll findpath(int u,ll in)
    {
        if(u==t)
            return in;
        ll out=0,res;
        int v;
        for(int i=head[u];i && in;i=e[i].nxt)
        {
            v=e[i].v;
            if(e[i].cap && dep[v]==dep[u]+1)
            {
                res=findpath(v,min(in,e[i].cap));
                e[i].cap-=res;
                e[i^1].cap+=res;
                out+=res;
                in-=res;
            }
        }
        if(!out)
            dep[u]=0;
        return out;
    }
    ll dinic()
    {
        ll res=0;
        while(level())
            res+=findpath(s,INF);
        return res;
    }
}di;
di.init(n,s,t);
di.addEdge(u,v,w);
di.dinic();
```

# 最短路

```c++
struct floyd
{
    int n;
    ll dis[N][N];
    void init(int m)
    {
        n=m;
        for(int i=0;i<=n;++i)
        {
            for(int j=0;j<=n;++j)
                dis[i][j]=0;
        }
    }
    void flo()
    {
        for(int k = 1; k <= n; ++k)
        {
            for(int i = 1; i <= n; ++i)
            {
                for(int j = 1; j <= n; ++j)
                {
                    if(dis[i][j] > dis[i][k] + dis[k][j])
                        dis[i][j] = dis[i][k] + dis[k][j];
                }
            }
        }
    }
};
struct edge
{
    int v;
    ll w;
    bool operator<(const edge b)const
    {
        return w<b.w;
    }
};
struct dijkstra
{
    int n;
    ll dis[N];
    int vis[N];
    priority_queue<edge,vector<edge>,greater<edge> > q;
    vector<edge> e[M];
    void add_edge(int u,int v,ll w)
    {
        e[u].push_back({v,w});
    }
    int dij(int begin,int end)
    {
        memset(vis,0,sizeof(int)*(n+1));
        memset(dis,0x3f,sizeof(dis[0])*(n+1));
        dis[begin]=0;
        while(!q.empty())
            q.pop();
        q.push({begin,0});
        int u,v;
        while(!q.empty())
        {
            u=q.top().w;
            q.pop();
            if(vis[u])
                continue;
            vis[u]=1;
            for(edge ed:e[u])
            {
                v=ed.v;
                if(dis[v]>dis[u]+ed.w)
                {
                    dis[v]=dis[u]+ed.w;
                    q.push({v,dis[v]});
                }
            }
        }
        return dis[end];
    }
    void init(int n)
    {
        for(int i=0;i<=n;++i)
            e[i].clear();
    }
};
struct edge
{
    int u,v;
    ll w;
};
struct bellmanFord
{
    int n,tot;
    ll dis[N];
    edge e[M];
    void init(int nn,int begin)
    {
        n=nn;
        tot=0;
        for(int i=0;i<=n;++i)
            dis[i]=INF;
        dis[begin]=0;
    }
    void add_edge(int u,int v,ll w)
    {
        e[++tot]={u,v,w};
    }
    bool bf()
    {
        int f=1;
        for(int i=0;i<n-1 && f;++i)
        {
            f=0;
            for(int j=1;j<=tot;++j)
            {
                if(dis[e[j].v]>dis[e[j].u]+e[j].w)
                {
                    dis[e[j].v]=dis[e[j].u]+e[j].w;
                    f=1;
                }
            }
        }
        if(!f)
            return false;
        for(int i=1;i<=tot;++i)
        {
            if(dis[e[i].v]>dis[e[i].u]+e[i].w)
                return true;
        }
        return false;
    }
};
```

# 最小生成树

稠密图用 prim,稀疏图用 kruskal

但是大部分时候 kru 就行（

## 时间复杂度

kruskal：$O(ELogE + ELogV)$

prim：$O(V^2)$

## kru

```cpp
const int N = 2e5 + 3;
const int M = 2e6 + 3;
struct Edge
{
    int u, v, w;
    bool operator<(const Edge f) const
    {
        return w < f.w;
    }
};
struct kruskal
{
    Edge e[M];
    int f[N];
    int tot, n;
    int find(int x)
    {
        return f[x] == -1 ? x : (f[x] = find(f[x]));
    }
    void init(int nn)
    {
        n = nn;
        memset(f, -1, sizeof(int) * (n + 1));
        tot = 0;
    }
    void addEdge(int u, int v, int w)
    {
        e[tot++] = {u, v, w};
    }
    int kru
    {
        sort(e, e + tot);
        int u, v, cnt = 0, cost = 0;
        for (int i = 0; i < tot; ++i)
        {
            u = find(e[i].u);
            v = find(e[i].v);
            if (u == v)
                continue;
            cost += e[i].w;
            f[u] = v;
            if (++cnt == n - 1)
                return cost;
        }
        return -1;
    }
};
```

# 图论杂

## 图上三元环计数

首先要对所有的无向边进行定向，

对于任何一条边，从度数大的点连向度数小的点，如果度数相同，从编号小的点连向编号大的点

此时这张图是一个有向无环图

之后枚举每一个点 u，然后将 u 的所有相邻的点都标记上“被 u 访问了”，

然后再枚举 u 的相邻的点 v，然后再枚举 v 的相邻的点 w，

如果 w 存在“被 u 访问了”的标记，那么(u,v,w)就是一个三元环了

### 时间复杂度

$O(m\sqrt m)$

## 无根树种类数

任意选取图中某个点为根，均可将无根树转化成为有根树。

$n$ 个点，组成的无根树有 $n^{n-2}$ 种
