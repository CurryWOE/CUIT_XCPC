- 线性代数
  - 矩阵快速幂
  - 高斯消元
  - 线性基
- 多项式
  - 生成函数
  - FFT&NTT&MTT
  - 拉格朗日插值
- 高数
- 杂
# 线性代数
向量各分量元素值为 $[0,p-1]$ 的整数，一个已经确定的，秩为 $j$ 的 $n$ 维向量组，能线性组合成的两两不同的向量，有 $p^j$ 个
# 矩阵快速幂
```c++
const int N = 4;
struct matrix
{
    ll m[N][N];
    void init()//单位矩阵
    {
        memset(m,0,sizeof(m));
        for(int i=0;i<N;++i)
            m[i][i]=1;
    }
    matrix operator*(matrix y)
    {
        matrix c;
        memset(c.m,0,sizeof(c.m));
        //稠密矩阵
        for(int i=0;i<N;++i)
            for(int j=0;j<N;++j)
                for(int k=0;k<N;++k)
                    c.m[i][j] = (c.m[i][j] + m[i][k] * y.m[k][j] % mod) % mod;
        //稀疏矩阵(指矩阵中很多数为0)
        for(int i=0;i<N;++i)
            for(int j=0;j<N;++j)
                if(m[i][j])
                    for(int k=0;k<N;++k)
                        c.m[i][k] = (c.m[i][k] + m[i][j] * y.m[j][k] % mod) % mod;
        return c;
    }
    matrix operator^(ll exponent)
    {
        matrix result;
        result.init();
        for(;exponent;exponent>>=1)
        {
            if(exponent&1)
                result = result*(*this);
            (*this) = (*this)*(*this);
        }
        return result;
    }
};
matrix base{1,1,1,2,
            0,1,1,2,
            0,1,0,0,
            0,1,0,1};
base=base^(n-2);
ll ans=(((base.m[0][0]*2%mod+base.m[0][1])%mod+base.m[0][2])%mod+base.m[0][3])%mod;
```
# 高斯消元
注意处理无解，无穷解情况

-1 无解，0 无穷解，1 唯一解
## 线性方程组
```c++
const int N=1e2+1;
const double eps=1e-6;
double a[N][N],ans[N];
int GaussianElimination(int n)
{
    int cnt=0;
    for(int i=0;i<n;++i)
    {
        int maxx=cnt;
        for(int j=cnt+1;j<n;++j)
            if(fabs(a[j][i])>fabs(a[maxx][i]))
                maxx=j;
        if(fabs(a[maxx][i])<eps)
            continue;
        if(maxx!=cnt)
            swap(a[maxx],a[cnt]);
        for(int j=0;j<n;++j)
        {
            if(j==cnt)
                continue;
            double temp=a[j][i]/a[cnt][i];
            for(int k=i+1;k<=n;++k)
                a[j][k]-=a[cnt][k]*temp;
        }
        ++cnt;
    }
    if(cnt<n)
    {
        for(;cnt<n;++cnt)
            if(fabs(a[cnt][n])>eps)
                return -1;
        return 0;
    }
    for(int i=0;i<n;++i)
        ans[i]=a[i][n]/a[i][i];
    return 1;
}
```
## 矩阵求逆
```cpp
const int N=402,mod=1e9+7;
int a[N][N],ih[N],jh[N];//a,1-index
bool inverseMatrix(int n)
{
    for(int k=1;k<=n;++k)
    {
        for(int i=k;i<=n && !ih[k];++i)
        {
            for(int j=k;j<=n;++j)
            if(a[i][j])
            {
                ih[k]=i;
                jh[k]=j;
                break;
            }
        }
        if(!ih[k])
            return false;
        for(int j=1;j<=n;++j)
            swap(a[k][j],a[ih[k]][j]);
        for(int i=1;i<=n;++i)
            swap(a[i][k],a[i][jh[k]]);
        if(!a[k][k])
            return false;
        a[k][k]=inv(a[k][k]);
        for(int i=1;i<=n;++i)
            if(i!=k)
                a[k][i]=(ll)a[k][i]*a[k][k]%mod;
        for(int i=1;i<=n;++i)
        if(i!=k)
            for(int j=1;j<=n;++j)
                if(j!=k)
                    a[i][j]=(a[i][j]+(ll)(mod-a[i][k])*a[k][j])%mod;
        for(int i=1;i<=n;++i)
            if(i!=k)
                a[i][k]=(ll)(mod-a[i][k])*a[k][k]%mod;
    }
    for(int k=n;k;--k)
    {
        for(int j=1;j<=n;++j)
            swap(a[k][j],a[jh[k]][j]);
        for(int i=1;i<=n;++i)
            swap(a[i][k],a[i][ih[k]]);
    }
    return true;
}
```
## 异或方程组
```c++
const int N = 1e3 + 3;
bitset<N> a[N << 1],ans;
int GaussElimination(int n, int m)
{
    int cnt = 0;
    for (int i = 0; i < n; ++i)
    {
        int cur = cnt;
        for (; cur < m && !a[cur].test(i); ++cur);
        if (cur == m)
            continue;
        if (cur != cnt)
            swap(a[cur], a[cnt]);
        for (int j = 0; j < m; j++)
            if (cnt != j && a[j].test(i))
                a[j] ^= a[cnt];
        ++cnt;
    }
    if (cnt < n)
    {
        for (int i=cnt; i < n; ++i)
            if (a[i][n])
                return -1;
        return fp(2,n-cnt);
    }
    for (int i = 0; i < n; i++)
        ans[i] = a[i].test(n);
    return 1;
}
```
## 浮点数行列式
```c++
const int N=1e2+1;
const double eps=1e-6;
double a[N][N];
double detA(int n)
{
    double res=1;
    for(int i=0;i<n;++i)
    {
        int maxx=i;
        for(int j=i+1;j<n;++j)
            if(fabs(a[j][i])>fabs(a[maxx][i]))
                maxx=j;
        if(fabs(a[maxx][i])<eps)
            return 0.0;
        if(maxx!=i)
        {
            swap(a[maxx],a[i]);
            res=-res;
        }
        res*=a[i][i];
        for(int j=0;j<n;++j)
        {
            if(j==i)
                continue;
            double temp=a[j][i]/a[i][i];
            if(fabs(temp)<eps)
                continue;
            for(int k=i;k<=n;++k)
                a[j][k]-=a[i][k]*temp;
        }
    }
    return res;
}
```
## 模数行列式
```cpp
ll detA(int n)
{
    ll ans = 1;
    int flag = 1;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            a[i][j] = (a[i][j] + mod) % mod;
    for (int i = 1; i <= n; ++i)
    {
        for (int j = i + 1; j <= n; ++j)
            while (a[j][i])
            {
                ll t = a[i][i] / a[j][i];
                for (int k = i; k <= n; ++k)
                    a[i][k] = (a[i][k] + mod - t * a[j][k] % mod) % mod;
                for (int k = i; k <= n; ++k)
                    swap(a[i][k], a[j][k]);
                flag ^= 1;
            }
        ans = ans * a[i][i] % mod;
        if (!ans)
            return 0;
    }
    if (!flag)
        ans = mod - ans;
    return ans;
}
```
# 线性基
1. 第k大异或和
2. 合法值是所有异或值的第几大
3. 是否可以线性表出某个值
4. 线性基合并
5. x和线性基的异或最小值
6. 1 到 n 的路径的最小异或和
7. 所有异或值的和
8. 带删线性基
## 线性表出
一个向量如果可以被其他向量通过运算表示，那么称这个向量可以被线性表出。

例如2维平面上的任意向量，都可以被(0,1),(1,0)这组向量通过矢量合成与放缩表示

在XCPC中，通常是一个数可以被其他数通过异或表示
## 线性相关&线性无关
如果向量组中有一个向量可以被向量组其他向量线性表出，那么称这个向量组线性相关，否则线性无关
## 极大线性无关组
线性相关可以理解为有多余的向量，删完之后，就是极大线性无关组
## 线性基
向量组的极大线性无关组就是线性基，简称基

一个向量组可以对应多个基，因此需要构造出一种合法基
### 性质
1. 原序列里的任意一个数都可以通过线性基中的一些数异或得到
2. 线性基里的任意一些数异或起来都不能得到 0
3. 每个序列的线性基的元素数量唯一，在性质一的前提下，有最少的数

序列里的元素相互异或一下，它的线性基不变

本构造得到的基，有2个性质：

1. 每个元素最高有效位各不相同

2. 如果某一位是一个元素的最高有效位，则其他元素在这一位均为 0
```cpp
struct linearBasis
{
    vector<ull> B;
    int zero,cnt,tot;
    vector<int> rnk;
    void init()
    {
        B.clear();
        zero=tot=0;
    }
    void insert(ull x)
    {
        for (ull &b : B)
            x = min(x, b ^ x);
        for (ull &b : B)
            b = min(b, b ^ x);
        if (x)
            B.push_back(x);
        ++tot;
    }
    int msb(ull x){return 63 - __builtin_clzll(x);}
    void init2()
    {
        sort(B.begin(),B.end());
        cnt=B.size();
        if(cnt<tot)
            zero=1;
        for(ull &b:B)
            rnk.push_back(msb(b));
    }
    ull kthxorsum(ull k)
    {
        k-=zero;
        ull ans=0;
        for(ull &b:B)
        {
            if(k&1)
                ans^=b;
            k>>=1;
        }
        return ans;
    }
    ull askrank(ull x)
    {
        ull ans=0;
        for (int i = 0; i < cnt; ++i)
            if (x >> rnk[i] & 1)
                ans +=1<<i;
        return ans*fast_power(2,tot-cnt)+1;
    }
    bool check(ull x)
    {
        for (ull &b : B)
            x = min(x, b ^ x);
        return (!x);
    }
    void merge(linearBasis &o)
    {
        for(ull &u:o.B)
            (*this).insert(u);
    }
    ull minXorSumWithX(ull x)
    {
        for (ull &b : B)
            x = min(x, b ^ x);
        return x;
    }
};
```
## 1 到 n 的路径的最小异或和
所有路径异或和，都可以由任意一条 1 到 n 路径的异或和与图中的一些环的异或和来组合得到。

从1先走到一个环，绕环一次，再原路返回，即可得到环的异或和，来路的异或和被抵消了。

A，B是两条1到n的路径，A，B组成环，如果A更优，走B前绕这个环一圈即可得到A的结果，所以是任意一条路径。

dfs搜出部分环，线性基自己可以解决环套环

最小异或和前面介绍过了
```cpp
typedef unsigned long long ull;
struct linearBasis
{
    vector<ull> B;
    void insert(ull x)
    {
        for (ull &b : B)
            x = min(x, b ^ x);
        for (ull &b : B)
            b = min(b, b ^ x);
        if (x)
            B.push_back(x);
    }
    ull minXorSumWithX(ull x)
    {
        for (ull &b : B)
            x = min(x, b ^ x);
        return x;
    }
}lb;
int vis[N],xorsum[N];
void dfs(int u,int sum)
{
    xorsum[u]=sum;
    vis[u]=1;
    for(auto &[v,w]:e[u])
        if(vis[v])
            lb.insert(sum^w^xorsum[v]);
        else
            dfs(v,sum^w);
}
dfs(1,0);
cout<<lb.minXorSumWithX(xorsum[n]);
```
# 多项式
# 生成函数
用一个函数来表示一个序列 $a_0,a_1,...,a_n$ ，假设是 $G(x)=\sum\limits_{i=0}^na_ix^i$，那么系数就表示了序列

由于只关心系数，自变量 $x$ 具体取值不重要，所以称这种函数为形式幂级数

$G(x)$ 是一个多项式。多项式有加减乘除，求逆，ln，exp等运算。下面用多项式乘法解决一些问题
## 普通生成函数
有三种物品，分别有3,2,3个，问拿出4个进行组合的方案数是多少

显然有背包做法，但是这里使用生成函数做

对每个物品构造一个多项式，$a_i$ 表示选了 $i$ 个物品的方案数

$G_1(x)=\sum\limits_{i=1}^3x^i$

$G_2(x)=\sum\limits_{i=1}^2x^i$

$G_3(x)=\sum\limits_{i=1}^3x^i$

先说结论：答案为 $G_1(x)*G_2(x)*G_3(x)$ 的第 4 项的系数(0-indexed)

考虑两个多项式相乘如何得到各个系数的，$a_k=\sum\limits_{i=0}^kf_ig_{k-i}$

这个过程实际上就是枚举第一种物品选了多少个，所以背包的过程就是模拟多项式乘法

形如 $G(x)=\sum\limits_{i=0}^na_ix^i$ 的多项式，称为普通生成函数
## 指数生成函数
普通生成函数解决组合问题，指数生成函数解决排列问题

有三种物品，分别有3,2,3个，问拿出4个进行排列的方案数是多少

背包可以做，但是这里使用生成函数做

先得到所有组合，再对每种组合计算多重集排列数，最后全部加起来

形如 $G(x)=\sum\limits_{i=0}^na_i\frac{x^i}{i!}$ 的多项式，称为指数生成函数

构造出 $G_1(x)=\sum\limits_{i=0}^3\frac{x^i}{i!}$

$G_2(x)=\sum\limits_{i=0}^2\frac{x^i}{i!}$

$G_3(x)=\sum\limits_{i=0}^3\frac{x^i}{i!}$

$G_1(x)*G_2(x)*G_3(x)=1+3x+\frac 92x^2+\frac {14}3x^3+\frac{35}{12}x^4+\frac{17}{12}x^5+\frac{35}{72}x^6+\frac{1}{9}x^7+\frac{1}{71}x^8$

先说结论：答案为 $\frac{35}{12}*(4!)=70$

$4!$ 就是4种不同物品排列数，$G(x)$ 的 $\frac{1}{i!}$ 相当于多重集排列数的分母
## 普通生成函数的推广
$\frac{1}{1-x}=\sum\limits_{i=0}^{\infty}x^i,x\in(-1,1)$
### 证明(必看，推式子要用)
$S=\sum\limits_{i=0}^{\infty}x^i$

$xS=\sum\limits_{i=1}^{\infty}x^i$

$S-xS=1$

$S=\frac{1}{1-x}$

---
因为是形式幂级数，所以函数定义域不为空即可，然后可以用上面这个代换式来得到序列

也可以通过递推公式得到通项公式，做法和证明类似

$\frac{1}{1-x}\rightarrow 1,1,1,...$

x替换成-x，$\frac{1}{1+x}\rightarrow 1,-1,1,-1,...$

x替换成2x，$\frac{1}{1-2x}\rightarrow 1,2,4,8,...$

x替换成 $x^2$，$\frac{1}{1-x^2}=1+x^2+x^4+...\rightarrow 1,0,1,0,1...$

分子乘2，$\frac{1}{1-x}\rightarrow 2,2,2,...$

分子乘 $x^3$，$\frac{1}{1-x}=x^3+x^4+x^5+...\rightarrow 0,0,0,1,1,1,...$

求导，$\frac{1}{(1-x)^2}=1+2x+3x^2+...\rightarrow 1,2,3,4,5,...$

对于任意多项式 $P(x),Q(x)$，生成函数 $\frac{P(x)}{Q(x)}$ 的展开式。先求出 $Q(x)=0$ 的根，把分母表示为 $\prod(1-p_ix)^{d_i}$ 的形式，然后把多余常系数乘到分子上

当对分母进行因式分解但有重根时，每有一个重根就要多一个分式

比如 $F(x)=\frac{1}{(1-x)(1-2x)^2}=\frac{c_1}{1-x}+\frac{c_2}{1-2x}+\frac{c_3}{(1-2x)^2}$

题目通常是先用代换式相乘，然后再展开为多项式求系数
## 广义二项式定理
$(x+y)^{\alpha}=\sum\limits_{i=0}^{\infty}\frac{\alpha^{\underline i}}{i!}x^{\alpha-i}y^i$
## 例题
一种物品最多选n个，就是普通生成函数只有前n+1项

一种物品必须选k的倍数个，也就是普通生成函数只有k的倍数项
## 指数生成函数的推广
$e^x=\sum\limits_{i=0}^{\infty}\frac{x^i}{i!}$
## 总结(快速查表)
$\sum\limits_{i=0}^nx^{ki}=\frac{1-x^{kn+k}}{1-x^k}$

$\sum\limits_{i=0}^n\dbinom nip^ix^i=(1+px)^n$

$\sum\limits_{i=0}^{\infty}x^{ki}=\frac 1{1-x^k}$

$\sum\limits_{i=0}^{\infty}p^ix^i=\frac 1{1-px}$

$\frac{1}{(1-x)^{n+1}}=\sum\limits_{i=0}^{\infty}\dbinom{n+i}{i}x^i$

$e^{px}=\sum\limits_{i=0}^{\infty}p^i\frac{x^i}{i!}$

$\ln{(1+x)}=\sum\limits_{i=1}^{\infty}(-1)^{i-1}\frac{x^i}{i}$

$-\ln{(1-x)}=\sum\limits_{i=1}^{\infty}\frac{x^i}{i}$

$\sin x=\sum\limits_{i=0}^{\infty}(-1)^i\frac{x^{2i+1}}{(2i+1)!}$

$\cos x=\sum\limits_{i=0}^{\infty}(-1)^i\frac{x^{2i}}{(2i)!}$

$\arcsin x=\sum\limits_{i=0}^{\infty}\frac{(2i)!}{4^i(i!)(2i+1)}x^{2i+1}$
## 指数生成函数中的多项式exp的组合意义
$exp\ G(x)$ 表示有标号元素划分为任意个无标号非空子集的总方案数

如果 $exp\ ⁡G(x)$ 好求，但是 $G(x)$不好求，我们可以对 $exp\ ⁡G(x)$做多项式 $\ln$，来求得 $G(x)$

如果 $G(x)$ 好求，但是 $exp\ ⁡G(x)$ 不好求，我们可以对 $G(x)$ 做多项式 $\exp$，来求得 $exp⁡\ G(x)$
# FFT&NTT&MTT
```cpp
// #define mod998244353
// #define ntt_prime_mod
// #define prime_mod
// #define arbitrary_mod
#define none_mod
// #define use_mtt
// #define dynamic_mod
const int LIM = 1 << 21;
// 2 val define:
// use_mtt/no define(fft)
// 2 modulus define(dynamic/static):
// dynamic_mod/no define(static_mod)
// 5 modulus define(feature):
// 1.mod998244353(ntt)
// 2.ntt_prime_mod(ntt)
// 3.prime_mod(mtt/fft)
// 4.arbitrary_mod(mtt/fft)
// 5,none_mod(mtt/fft)
namespace poly
{
    const int SZL = LIM | 5;
    using T = int;
    using cT = const T;
#ifdef mod998244353
    const int mod = 998244353;
#elif defined(dynamic_mod)
    T mod;
#elif !defined(none_mod)
    const T mod = ::mod;
#endif
#ifdef dynamic_mod
    using ull = unsigned long long;
    using u128 = __uint128_t;
    struct FastMod
    {
        ull b, m;
        FastMod(ull b = 2) : b(b), m(ull((u128(1) << 64) / b)) {}
        inline ull R(ull x)
        {
            ull q = ull(u128(m) * x >> 64), r = x - q * b;
            return r >= b ? r - b : r;
        }
    } M;
    inline T mul(cT x, cT y) { return M.R(1ull * x * y); }
    inline void Mul(T &x, cT y) { x = M.R(1ull * x * y); }
#elif !defined(none_mod)
    inline T mul(cT x, cT y)
    {
        return 1ll * x * y % mod;
    }
    inline void Mul(T &x, cT y) { x = 1ll * x * y % mod; }
#endif
#ifndef none_mod
    inline T inc(cT x, cT y)
    {
        return x + y < mod ? x + y : x + y - mod;
    }
    inline T dec(cT x, cT y) { return x >= y ? x - y : x - y + mod; }
    inline void Inc(T &x, cT y) { ((x += y) <= mod) && (x -= mod); }
    inline void Dec(T &x, cT y) { ((x -= y) < 0) && (x += mod); }
    inline T pow(T x, T y)
    {
        T res = 1;
        for (; y; y >>= 1, Mul(x, x))
            (y & 1) && (Mul(res, x), 1);
        return res;
    }
    inline T Inv(cT x) { return pow(x, mod - 2); }
#endif
#ifdef mod998244353
    const int G = 3, iG = 332748118;
#elif defined(ntt_prime_mod)
    T G, iG;
#endif
    inline void Minit(
#ifdef dynamic_mod
        T MOD
#endif
    )
    {
#ifdef dynamic_mod
        mod = MOD;
        M = FastMod(mod);
#endif
#ifdef ntt_prime_mod
        static T fc[105] = {0}, cnt = 0;
        cT phi = mod - 1;
        for (T i = 2, x = phi; 1ll * i * i <= x; ++i)
            if (!(x % i))
            {
                fc[++cnt] = x;
                for (; x % i == 0; x /= i)
                    ;
            }
        for (G = 2;; ++G)
        {
            if (pow(G, phi) ^ 1)
                continue;
            bool fl = 1;
            for (int i = 1; i <= cnt && fl; ++i)
                fl &= (pow(G, phi / fc[i]) ^ 1);
            if (fl)
                break;
        }
        iG = Inv(G);
#endif
    }
#if defined(ntt_prime_mod) || defined(mod998244353)
    T pool[SZL << 3], *cur = pool;
    T _pl[SZL << 1], *igp[25];
    using Z = T;
    inline void init(const int N)
    {
        T *cr = _pl;
        for (int i = 1, ct = 0; i < N; i <<= 1, ++ct)
        {
            igp[ct] = cr;
            cr += i;
            igp[ct][0] = 1;
            if (i > 1)
                igp[ct][1] = pow(iG, (mod - 1) / (i << 1));
            for (int j = 2; j < i; ++j)
                Mul(igp[ct][j] = igp[ct][j - 1], igp[ct][1]);
        }
    }
    inline void NTT(T *f, const int N)
    {
        if (N == 1)
            return;
        for (int i = N >> 1, ct = __builtin_ctz(i); i >= 2; i >>= 2, ct -= 2)
        {
            const int o = i >> 1;
            for (int j = 0; j < N; j += (i << 1))
            {
                T *f0 = f + j, *f1 = f0 + o, *f2 = f1 + o, *f3 = f2 + o;
                const int *w0 = igp[ct], *w1 = w0 + o, *w2 = igp[ct - 1];
                for (int k = 0; k < o; ++k)
                {
                    cT A = inc(*f0, *f2), B = mul(*w0++, dec(*f0, *f2));
                    cT C = inc(*f1, *f3), D = mul(*w1++, dec(*f1, *f3));
                    *f0++ = inc(A, C);
                    *f2++ = inc(B, D);
                    *f1++ = mul(*w2, dec(A, C));
                    *f3++ = mul(*w2, dec(B, D));
                    ++w2;
                }
            }
        }
        if (!(__builtin_ctz(N >> 1) & 1))
        {
            for (int j = 0; j < N; j += 2)
            {
                T &f0 = f[j], &f1 = f[j + 1];
                cT A = inc(f0, f1), B = dec(f0, f1);
                f0 = A;
                f1 = B;
            }
        }
    }
    inline void INTT(T *f, const int N)
    {
        if (N == 1)
            return;
        for (int i = 1, ct = 0; i << 1 < N; i <<= 2, ct += 2)
        {
            for (int j = 0; j < N; j += (i << 2))
            {
                T *f0 = f + j, *f1 = f0 + i, *f2 = f1 + i, *f3 = f2 + i;
                const int *w0 = igp[ct], *w1 = igp[ct + 1], *w2 = w1 + i;
                for (int k = 0; k < i; ++k)
                {
                    cT v0 = mul(*w0, *f1), v1 = mul(*w0, *f3);
                    ++w0;
                    cT A = inc(*f0, v0), B = dec(*f0, v0);
                    cT C = mul(*w1++, inc(*f2, v1)), D = mul(*w2++, dec(*f2, v1));
                    *f0++ = inc(A, C);
                    *f1++ = inc(B, D);
                    *f2++ = dec(A, C);
                    *f3++ = dec(B, D);
                }
            }
        }
        if (!(__builtin_ctz(N >> 1) & 1))
        {
            const int *w = igp[__builtin_ctz(N >> 1)];
            for (int j = 0; j < N >> 1; ++j)
            {
                T &f0 = f[j], &f1 = f[j + (N >> 1)];
                cT A = f0, B = mul(*w++, f1);
                f0 = inc(A, B);
                f1 = dec(A, B);
            }
        }
        std::reverse(f + 1, f + N);
        cT iN = Inv(N);
        for (int i = 0; i < N; ++i)
            Mul(f[i], iN);
    }
    inline void Gconv(cT *const f, const int n, cT *const g, const int m, T *h)
    {
        int N = 1;
        const int Len = n + m - 1;
        for (; N < Len; N <<= 1)
            ;
        init(N);
        T *A, *B;
        A = cur;
        cur += N;
        B = cur;
        cur += N;
        for (int i = 0; i < N; ++i)
            A[i] = B[i] = 0;
        for (int i = 0; i < n; ++i)
            A[i] = f[i];
        for (int i = 0; i < m; ++i)
            B[i] = g[i];
        NTT(A, N);
        NTT(B, N);
        for (int i = 0; i < N; ++i)
            Mul(A[i], B[i]);
        INTT(A, N);
        for (int i = 0; i < Len; ++i)
            h[i] = A[i];
        cur -= N;
        cur -= N;
    }
#else
    using db = double;
    using cdb = const db;
    struct cpl
    {
        db x, y;
        cpl() = default;
        cpl(cdb X, cdb Y) : x(X), y(Y) {}
        inline cpl operator+(const cpl &rhs) const { return cpl(x + rhs.x, y + rhs.y); }
        inline cpl operator-(const cpl &rhs) const { return cpl(x - rhs.x, y - rhs.y); }
        inline cpl operator*(const cpl &rhs) const { return cpl(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x); }
        inline cpl operator*=(const cpl &rhs) { return *this = *this * rhs; }
    };
    using Z = cpl;
    using cZ = const Z;
    Z _pl[SZL << 1], *igp[25];
    constexpr db pi = acos(-1);
    Z pool[SZL << 3], *cur = pool;
    inline void init(const int N)
    {
        Z *cr = _pl;
        for (int i = 1, ct = 0; i < N; i <<= 1, ++ct)
        {
            igp[ct] = cr;
            cr += i;
            igp[ct][0] = cpl(1, 0);
            for (int j = 1; j < i; ++j)
                igp[ct][j] = cpl(cos(pi * j / i), -sin(pi * j / i));
        }
    }
    inline void DFT(Z *f, const int N)
    {
        if (N == 1)
            return;
        for (int i = N >> 1, ct = __builtin_ctz(i); i >= 2; i >>= 2, ct -= 2)
        {
            const int o = i >> 1;
            for (int j = 0; j < N; j += (i << 1))
            {
                Z *f0 = f + j, *f1 = f0 + o, *f2 = f1 + o, *f3 = f2 + o;
                cZ *w0 = igp[ct], *w1 = w0 + o, *w2 = igp[ct - 1];
                for (int k = 0; k < o; ++k)
                {
                    cZ A = *f0 + *f2, B = *w0++ * (*f0 - *f2), C = *f1 + *f3, D = *w1++ * (*f1 - *f3);
                    *f0++ = A + C;
                    *f2++ = B + D;
                    *f1++ = *w2 * (A - C);
                    *f3++ = *w2 * (B - D);
                    ++w2;
                }
            }
        }
        if (!(__builtin_ctz(N >> 1) & 1))
        {
            for (int j = 0; j < N; j += 2)
            {
                Z &f0 = f[j], &f1 = f[j + 1];
                cZ A = f0 + f1, B = f0 - f1;
                f0 = A;
                f1 = B;
            }
        }
    }
    inline void IDFT(Z *f, const int N)
    {
        if (N == 1)
            return;
        for (int i = 1, ct = 0; i << 1 < N; i <<= 2, ct += 2)
        {
            for (int j = 0; j < N; j += (i << 2))
            {
                Z *f0 = f + j, *f1 = f0 + i, *f2 = f1 + i, *f3 = f2 + i;
                cZ *w0 = igp[ct], *w1 = igp[ct + 1], *w2 = w1 + i;
                for (int k = 0; k < i; ++k)
                {
                    cZ v0 = *w0 * *f1, v1 = *w0 * *f3;
                    ++w0;
                    cZ A = *f0 + v0, B = *f0 - v0, C = *w1++ * (*f2 + v1), D = *w2++ * (*f2 - v1);
                    *f0++ = A + C;
                    *f1++ = B + D;
                    *f2++ = A - C;
                    *f3++ = B - D;
                }
            }
        }
        if (!(__builtin_ctz(N >> 1) & 1))
        {
            cZ *w = igp[__builtin_ctz(N >> 1)];
            for (int j = 0; j < N >> 1; ++j)
            {
                Z &f0 = f[j], &f1 = f[j + (N >> 1)];
                cZ A = f0, B = *w++ * f1;
                f0 = A + B;
                f1 = A - B;
            }
        }
        std::reverse(f + 1, f + N);
        for (int i = 0; i < N; ++i)
            f[i].x /= N, f[i].y /= N;
    }
#ifdef use_mtt
    const int Bl = 65535, lgB = 16, lgB2 = 32;
    inline T _to_range(cdb x)
    {
        return ((ll)(x + 0.5))
#ifndef none_mod
               % mod
#endif
            ;
    }
    inline void Gconv(cT *const f, const int n, cT *const g, const int m, T *h)
    {
        int N = 1;
        const int Len = n + m - 1;
        for (; N < Len; N <<= 1)
            ;
        init(N);
        Z *A, *B, *T;
        A = cur;
        cur += N;
        B = cur;
        cur += N;
        T = cur;
        cur += N;
        for (int i = 0; i < N; ++i)
            A[i] = B[i] = T[i] = cpl(0, 0);
        for (int i = 0; i < n; ++i)
            A[i].x = f[i] & Bl, B[i].x = f[i] >> lgB;
        for (int i = 0; i < m; ++i)
            T[i] = cpl(g[i] & Bl, g[i] >> lgB);
        DFT(A, N);
        DFT(B, N);
        DFT(T, N);
        for (int i = 0; i < N; ++i)
            A[i] *= T[i], B[i] *= T[i];
        IDFT(A, N);
        IDFT(B, N);
        for (int i = 0; i < Len; ++i)
            h[i] = (_to_range(A[i].x) + (1ll * (_to_range(A[i].y) + _to_range(B[i].x)) << lgB) + (1ll * _to_range(B[i].y) << lgB2))
#ifndef none_mod
                   % mod
#endif
                ;
        cur -= N;
        cur -= N;
        cur -= N;
    }
#else
    inline void Gconv(cT *const f, const int n, cT *const g, const int m, T *h)
    {
        int N = 1;
        const int Len = n + m - 1;
        for (; N < Len; N <<= 1)
            ;
        init(N);
        Z *A;
        A = cur;
        cur += N;
        for (int i = 0; i < N; ++i)
            A[i] = cpl(0, 0);
        for (int i = 0; i < n; ++i)
            A[i].x = f[i];
        for (int i = 0; i < m; ++i)
            A[i].y = g[i];
        DFT(A, N);
        for (int i = 0; i < N; ++i)
            A[i] *= A[i];
        IDFT(A, N);
        cur -= N;
#ifdef none_mod
        for (int i = 0; i < Len; ++i)
            h[i] = (A[i].y + 0.5) / 2;
#elif defined(dynamic_mod)
        for (int i = 0; i < Len; ++i)
            h[i] = M.R((A[i].y + 0.5) / 2ull);
#else
        for (int i = 0; i < Len; ++i)
            h[i] = ((A[i].y + 0.5) / 2) % mod;
#endif
    }
#endif
#endif
}
```
## 常见原根
r * 2^k + 1 (mod)	r	k (模数大小规模)	原根  
7681	15	9	17  
65537	1	16	3  
998244353	119	23	3  
1004535809	479	21	3  
75161927681	35	31	3  
206158430209	3	36	22  
180143985094819841	5	55	6  
1945555039024054273	27	56	5  
4179340454199820289	29	57	3  
## 拉格朗日插值
### 原版
$n$ 个不同点 $(x_i,y_i)$ 确定唯一 $n-1$ 次多项式 $g$

已知 $n$ 个点值，可以 $O(n^2)$ 预处理，$O(nlog(mod))$ 求出 $g(k)$

```cpp
const int N=2e3+3;
const ll mod=998244353;
struct lagrange
{
    int n;
    ll x[N],y[N],w[N];
    void init()
    {
        n=0;
    }
    void insert(ll xx,ll yy)
    {
        x[++n]=xx;
        y[n]=yy;
        ll s=1;
        for(int i=1;i<n;++i)
        {
            w[i]=w[i]*(x[i]-xx)%mod;
            s=s*(xx-x[i])%mod;
        }
        w[n]=s;
    }
    void init2()
    {
        for(int i=1;i<=n;++i)
            w[i]=y[i]*inv(w[i])%mod;
    }
    ll lag(ll k)
    {
        ll s=1;
        for(int i=1;i<=n;++i)
        {
            if(k==x[i])
                return y[i];
            s=s*(k-x[i])%mod;
        }
        ll ans=0;
        for(int i=1;i<=n;++i)
            ans=(ans+s*inv(k-x[i])%mod*w[i]%mod)%mod;
        return (ans+mod)%mod;
    }
}la;
la.init();
la.insert(x,y);
la.init2();
la.lag(k);
```
### 特化版
当给定点值 $x_i$ 连续，可以 $O(n)$ 预处理，$O(n)$ 求 $g(k)$

$g(n)=\sum\limits_{i=1}^{k}y_i\prod\limits_{j=1,j\ne i}^{k}\frac{n-j}{i-j}$

$g(n)=\sum\limits_{i=1}^{k}y_i\left(\prod\limits_{j=1,j\ne i}^{k}(i-j)\right)^{-1}\prod\limits_{j=1,j\ne i}^{k}(n-j)$

$g(n)=\sum\limits_{i=1}^{k}y_i\left(\prod\limits_{j=1}^{i-1}(i-j)\prod\limits_{j=i+1}^{k}(i-j)\right)^{-1}\prod\limits_{j=1}^{i-1}(n-j)\prod\limits_{j=i+1}^{k}(n-j)$

$g(n)=\sum\limits_{i=1}^{k}y_i\left(\prod\limits_{j=1}^{i-1}j\prod\limits_{j=i-k}^{-1}j\right)^{-1}\prod\limits_{j=1}^{i-1}(n-j)\prod\limits_{j=i+1}^{k}(n-j)$

$pre_i=\prod\limits_{j=1}^i(n-j)，suf_i=\prod\limits_{j=i}^k(n-j)$

$g(n)=\sum\limits_{i=1}^{k}y_i(-1)^{k-i}\left((i-1)!(k-i)!\right)^{-1}pre_{i-1}suf_{i+1}$
```cpp
long long fac[N],inv[N];
void getC()
{
    fac[0]=1;
    for(int i=1;i<N;++i)
        fac[i]=fac[i-1]*i%mod;
    inv[N-1]=fast_power(fac[N-1],mod-2);
    for(int i=N-1;i;--i)
        inv[i-1]=inv[i]*i%mod;
}
struct lagrange
{
    ll y[N],pre[N],suf[N];
    ll lag(ll m,int k)//g(m)，k个点
    {
        if(m<=k)
            return y[m];
        pre[0]=suf[k+1]=1;
        for(int i=1;i<k;++i)
            pre[i]=pre[i-1]*(m-i)%mod;
        for(int i=k;i>1;--i)
            suf[i]=suf[i+1]*(m-i)%mod;
        ll ans=0;
        for(int i=1;i<=k;++i)
            ans=(ans+y[i]*inv[i-1]%mod*inv[k-i]%mod*pre[i-1]%mod*suf[i+1]%mod*((k-i)&1?-1:1))%mod;
        return (ans+mod)%mod;
    }
}la;
la.y[i]=y;
la.lag(m,k);
```
# 高等数学
## 函数
### 有界性
$\forall x,f(x)\le MAX$，$MAX$ 称为上界

$\forall x,f(x)\ge MIN$，$MIN$ 称为下界

$\forall x,|f(x)|<=M$，$M$ 称为界
### 初等函数
1. 幂函数：$y=x^k$
2. 指数函数：$y=a^x$
3. 对数函数：$y=\log_a x$
4. 三角函数：$y=\sin x,\cos x,\tan x=\frac{\sin x}{\cos x},\cot x=\frac 1{\tan x},\sec x=\frac 1{\cos x},\csc x=\frac 1{\sin x}$
5. 反三角函数：$y=\arcsin x$ 等

由以上5种，基本初等函数，经过有限次的四则运算和有限次的函数复合，的函数为初等函数
## 函数的极限存在的充分必要条件
$x$ 从左侧趋于 $x_0$ 记作 $x\rightarrow x_0^-$，$x$ 从右侧趋于 $x_0$ 记作 $x\rightarrow x_0^+$

$\lim\limits_{x\rightarrow x_0^-}f(x)=A=\lim\limits_{x\rightarrow x_0^+}f(x)$
## 无穷小与无穷大
### 无穷小定义
如果函数 $\lim\limits_{x\rightarrow x_0或x\rightarrow \infty}f(x)=0$，那么称函数 $f(x)$ 为当 $x\rightarrow x_0或x\rightarrow \infty$ 时的无穷小
### 无穷大定义
如果函数 $\lim\limits_{x\rightarrow x_0或x\rightarrow \infty}f(x)=\infty$，那么称函数 $f(x)$ 为当 $x\rightarrow x_0或x\rightarrow \infty$ 时的无穷大
### 无穷大和无穷小的联系
在自变量的同一变化过程中，如果 $f(x)$ 为无穷大，那么 $\frac 1{f(x)}$ 为无穷小；

反之，如果 $f(x)$ 为无穷小，且 $f(x)\ne 0$，那么 $\frac 1{f(x)}$ 为无穷大；
## 极限运算法则
1. 有限个无穷小之和是无穷小
2. 有界函数与无穷小的乘积是无穷小
3. 有限个无穷小之积是无穷小
4. 四则运算，即 $\lim f(x)=A,\lim g(x)=B$  
$\lim[f(x)+g(x)]=\lim f(x)+\lim g(x)=A+B$  
$\lim[f(x)-g(x)]=\lim f(x)-\lim g(x)=A-B$  
$\lim[f(x)g(x)]=\lim f(x)\lim g(x)=AB$  
$\lim[\frac{f(x)}{g(x)}]=\frac {\lim f(x)}{\lim g(x)}=\frac AB$，且 $B\ne 0$
5. 4的推论，$c$ 为常数，$\lim[cf(x)]=c\lim f(x)$
6. 4的推论，$n$ 为正整数，$\lim[f(x)]^n=[\lim f(x)]^n$
7. 复合函数的极限运算法则，先求内层函数的极限，再把这个极限代回去求外层函数的极限
## 几个重要极限
1. $\lim\limits_{x\rightarrow 0}\frac {\sin x}{x}=1$
2. $\lim\limits_{x\rightarrow 0}\cos x=1$
3. $\lim\limits_{x\rightarrow\infty}\left(1+\frac 1x \right)^x=e$
## 无穷小的比较
### 常见等价无穷小
1. $\sin x\sim x$
2. $\tan x\sim x$
3. $1-\cos x\sim \frac 12 x^2$
4. $e^x-1\sim x$
5. $\ln(1+x)\sim x$
6. $\sqrt[n]{1+x}-1\sim\frac xn$
### 等价无穷小运算法则
设 $\alpha\sim\tilde\alpha,\beta\sim\tilde\beta$，且 $\lim\frac{\tilde\beta}{\tilde\alpha}$ 存在，则 $\lim\frac{\beta}{\alpha}=\lim\frac{\tilde\beta}{\tilde\alpha}$
## 函数的求导法则
1. 设 $u=u(x),v=v(x)$  
$[u+v]'=u'+v'$  
$[u-v]'=u'-v'$  
$[uv]'=u'v+uv'$  
$[\frac uv]'=\frac{u'v+uv'}{v^2}$，且 $v\ne 0$
2. 反函数的求导法则，即函数 $x=f(y)$，反函数 $y=f^{-1}(x)$  
$[f^{-1}(x)]'=\frac 1{f'(y)}$
3. 复合函数的求导法则，即 $y=f(u),u=g(x)$  
$[f(g(x))]'=f'(u)g'(x)$
## 基本初等函数的导数公式
1. $(x^k)'=kx^{k-1}$
2. $(a^x)'=a^x\ln a$
3. $(\log_a x)'=\frac 1{xln a}$
4. $(\sin x)'=\cos x$
5. $(\cos x)'=-\sin x$
6. $(\tan x)'=\sec^2 x$
7. $(\cot x)'=-\csc^2 x$
8. $(\sec x)'=\sec x\tan x$
9. $(\csc x)'=-\csc x\cot x$
10. $(\arcsin x)'=\frac 1{\sqrt{1-x^2}}$
11. $(\arccos x)'=-\frac 1{\sqrt{1-x^2}}$
12. $(\arctan x)'=\frac 1{1+x^2}$
13. $(arccot~x)'=-\frac 1{1+x^2}$
## 高阶导数
对导数再次求导，即可得更高阶导数
## 洛必达法则
对于 $\frac 00,\frac{\infty}{\infty}$ 型的极限的商，不能用“商的极限等于极限的商”这一法则，因此用洛必达法则，即

$\lim\frac{f(x)}{F(x)}=\lim\frac{f'(x)}{F'(x)}$
## 泰勒公式
用多项式近似表达函数，即

$f(x)=f(x_0)+f'(x_0)(x-x_0)+\frac{f''(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)$
## 题目

## [2021ICPC网络赛2G](https://pintia.cn/market/item/1442013218528759808)
Given $2n$ integers, $a_1,a_2,…,a_n,b_1,b_2,…,b_n,$ and an integer $t$. You need to calculate:

$\lim\limits_{x→0}\frac{\sum\limits_{i=1}^na_i\times ln(1+b_i\times x)}{x^t}$.
### Input
The first line consists of two integers $n,t$.

In the following $n$ lines, the $i$-th line consists of two integers $a_i,b_i$.

$1≤n≤100000,−100≤a_i,b_i≤100,0≤t≤5$.
### Output
Please output the result of this limit.

If the result is $\infty$, please output "infinity" (without quotes). And if the result is an integer, please output this integer directly. Otherwise, the answer must be $\frac ab$, such that $a$ and $b$ are coprime and $b≥2$, please output "$a/b$".
### Sample Input 1
```
2 2
1 1
1 -1
```
### Sample Output 1
```
-1
```
### Sample Input 2
```
2 1
1 1
1 -1
```
### Sample Output 2
```
0
```
### Sample Input 3
```
2 3
1 1
1 -1
```
### Sample Output 3
```
infinity
```
### Solution
$\lim\limits_{x→0}\frac{\sum\limits_{i=1}^na_i\times ln(1+b_i\times x)}{x^t}$

$\sum\limits_{i=1}^na_i\lim\limits_{x→0}\frac{ln(1+b_i\times x)}{x^t}$

直接对后半部分洛必达会发现洛1次之后就不是 $\frac 00$ 的形式，因此泰勒公式来近似后半部分

$f(x)=ln(1+b_i\times x)$

$f'(x)=\frac{b_i}{1+b_ix}$

$f''(x)=\frac{-b_i^2}{1+2b_ix+b_i^2x^2}$

$f'''(x)=\frac{2b_i^3+2b_i^4x}{1+4b_ix+6b_i^2x^2+4b_i^3x^3+b_i^4x^4}$

$f''''(x)=\frac{-6b_i^4-24b_i^5x-36b_i^6x^2-24b_i^7x^3-6b_i^8x^4}{(1+4b_ix+6b_i^2x^2+4b_i^3x^3+b_i^4x^4)^2}$

$f'''''(x)=...$

$x_0=0$

$f(x)=b_ix-\frac 12b_i^2x^2+\frac{1}{3}b_i^3x^3-\frac 1{4}b_i^4x^4+\frac 15b_i^5x^5+...$

$ans=\sum\limits_{i=1}^na_i\lim\limits_{x\to 0}\frac {f(x)}{x^t}$

$t=0,ans=0$

$t=1,ans=\sum\limits_{i=1}^na_ib_i$

$t=2,ans=\sum\limits_{i=1}^na_i\frac{-b_i^2}{2}$

$t=3,ans=\sum\limits_{i=1}^na_i\frac{b_i^3}{3}$

$t=4,ans=\sum\limits_{i=1}^na_i\frac{-b_i^4}{4}$

$...$

由于只有 $\frac 00$ 形式能一直洛，所以中间结果如果不是 $\frac 00$，那答案为 $\infty$
```cpp
ll g[7];
string solve(int n,int t)
{
    if(t==0)
        return "0";
    ll a,b;
    for(int i=0;i<n;++i)
    {
        cin>>a>>b;
        for(int j=1;j<=t;++j)
        {
            a*=b;
            g[j]+=((j&1)?a:-a);
        }
    }
    for(int i=1;i<t;++i)
        if(g[i])
            return "infinity";
    ll gc=__gcd(g[t],(ll)t);
    string ans=to_string(g[t]/gc);
    if(t!=gc)
        ans+=" "+to_string(t/gc);
    return ans;
}
```
## [2021ICPC昆明C](https://ac.nowcoder.com/acm/contest/32708/C)
There is an empty cup, and a dumb robot is going to fill it with $1$ liter of water.

For every turn, the robot will randomly select a real number $t$ between $0$ and $x$ ($x$ is a given number) and then fill the cup with $t$ liter of water. The robot will repeat it until the cup is full (at least $1$ liter of water has been filled).

You need to answer the expected number of turns the robot should fill.
### Input
The first line contains an integer $T(T\leq 10000)$, denoting the number of test cases.

In the following $T$ lines, each line contains a real number $x(0.05\leq x\leq 10^9)$, describing a test case.

It is guaranteed that $x$ contains no more than $3$ decimal places.
### Output
For each test case, output one line with a real number, denoting the expected number of turns.

Any answer with a relative or absolute error less than $10^{-4}$ will be accepted.
### Sample Input 1
```
2
0.3
1.5
```
### Sample Output 1
```
7.3332227396
1.9477340411
```
### Solution
设 $E(x)$ 为每次均匀随机走 $[0,a]$，达到大于等于 $x$ 的期望次数，由全期望公式

$$E(X)=\int_{-\infty}^{+\infty}xf(x)dx$$

由于是均匀分布，所以 $f(x)=\frac 1a$

抽到一个数t，因为希望刚刚好达到x，所以应该从E(x-t)转移过来，因此积分上下限改为x和max(0,x-a)

$$E(x)=1+\int_{max(0,x-a)}^x\frac{E(t)}adt$$

对两边求导

$$aE'(x)=E(x)-E(x-a)$$

### 定义近似计算
$$a\frac{f(x+\Delta x)-f(x)}{\Delta x}=f(x)-f(x-a)$$

$$f(x+\Delta x)=f(x)+\frac{\Delta x}a(f(x)-f(x-a))$$

$f(0)=1$ 表示无穷小期望为1，那么 $ans=f(1)$

由于是多组数据，原问题步长 $[0,a]$，大于等于1的期望步数，等价于，步长 $[0,1]$，大于等于 $\frac 1a$ 的期望步数，故上式改为

$$f(x+\Delta x)=f(x)+\Delta x(f(x)-f(x-1))$$

$ans=f(\frac 1a)$
```cpp
const int maxn = 1e5;
const double dx = 1.0 / maxn;
double f[maxn * 20 + 100];
void init()
{
    f[0] = 1;
    for(int i=0;i<maxn;++i)
        f[i + 1] = (dx+1) * f[i];
    for (int i = maxn; i < 20 * maxn + 99; i++)
        f[i + 1] = f[i] + dx * (f[i] - f[i - maxn]);
}
double solve(double x){return f[(int)(maxn / x)];}
```
### 推精准式子
转化为步长为 $[0,1]$ 的问题

$$f'(x)=f(x)-f(x-1)$$

对 $x$ 范围分类讨论

---
当 $x\in(0,1],f(x-1)=0$

$f'(x)=f(x)$，满足这个式子，已知的有 $e^x$

所以，$f(x)=Ce^x$

当 $x\to 0^+$,$f(x)\to 1$，所以 $f(x)=e^x$

---
当 $x\in(1,2],f(x-1)=e^{x-1}$

$f'(x)=f(x)-e^{x-1}$，满足这个式子，嗯凑凑出 $-xe^{x-1}$

所以，$f(x)=-xe^{x-1}$

当 $x\to 1^-$,$f(x)\to e$，

由于连续性，$x\to 1^+$,$f(x)\to e$，

和 $f(1^+)=-1e^{1-1}$ 差了 $1+e$

因此补上一些东西使式子成立，而 $Ce^x$ 不影响式子成立

所以，$f(x)=Ce^x-xe^{x-1}=(1+\frac 1e)e^x-xe^{x-1}=e^x-(x-1)e^{x-1}$

---
当 $x\in(2,3],f(x-1)=e^{x-1}-(x-2)e^{x-2}$

$f'(x)=f(x)-(e^{x-1}-(x-2)e^{x-2})$，满足这个式子，嗯凑凑出 $-xe^{x-1}+\frac 12(x-2)^2e^{x-2}$

所以，$f(x)=-xe^{x-1}+\frac 12(x-2)^2e^{x-2}$

当 $x\to 2^-$,$f(x)\to e$，

由于连续性，$x\to 1^+$,$f(x)\to e^2-e$，

和 $f(2^+)=-2e^{2-1}$ 差了 $e^2+e$

因此补上一些东西使式子成立，而 $Ce^x$ 不影响式子成立

所以，$f(x)=Ce^x-xe^{x-1}+\frac 12(x-2)^2e^{x-2}=(1+\frac 1e)e^x-xe^{x-1}+\frac 12(x-2)^2e^{x-2}=e^x-(x-1)e^{x-1}+\frac 12(x-2)^2e^{x-2}$

---
仿照以上方法，发现规律，$x\in(k,k+1]$

$$f(x)=\sum\limits_{i=0}^k\frac{(-1)^i}{i!}(x-i)^ie^{x-i}$$

$ans=f(\frac 1a)$
```cpp
double solve(double x)
{
    x = 1 / x;
    double ans = 0, fac = 1;
    for (int i = 0; i < x; i++)
    {
        ans+=((i&1)?-1:1)*fac * pow(x - i, i) * exp(x - i);
        fac /= (i + 1);
    }
    return ans;
}
```
## [2022ICPC沈阳A](https://codeforces.com/gym/104160/problem/A)
Both Alice and Bob have a set of real numbers, and both sets are the union of some disjoint closed
intervals. They will independently pick a real number uniformly at random from their own set, and you
need to calculate the expected absolute difference between the two real numbers.

More formally, given a set of real numbers $S=\cup
[l,r]$ , picking a real number $x$ from the set $S$ uniformly
at random means that $P(x \in [l1, r1]) = P(x \in [l2, r2])$ holds for any two intervals $[l1, r1], [l2, r2]  \subseteq S$ with the same length, i.e., $r1 − l1 = r2 − l2$.
### Input
The first line contains two integers $n$ and $m (1 ≤ n, m ≤ 10^5)$, the number of intervals that form Alice’s
set and Bob’s set respectively.

Each of the following $n + m$ lines contains two integers $l$ and $r (−10^9 ≤ l ≤ r ≤ 10^9)$, describing a closed interval $[l, r]$. The first $n$ intervals form Alice’s set and the next $m$ intervals form Bob’s set. Note that an interval $[l, r]$ with $l = r$ is a degenerate interval that contains a single real number.

It is guaranteed that the intervals that form someone’s set are pairwise disjoint.
### Output
Output a single real number, indicating the expected absolute difference of the two real numbers picked
by Alice and Bob separately.

Your answer is acceptable if its absolute or relative error does not exceed $10^{−9}$. Formally speaking, suppose
that your output is $a$ and the jury’s answer is $b$, your output is accepted if and only if $\frac{|a−b|}{
max(1,|b|)} ≤ 10^{−9}$.
### Sample Input 1
```
1 1
0 1
0 1
```
### Sample Output 1
```
0.333333333333333
```
### Sample Input 2
```
1 1
0 1
1 1
```
### Sample Output 2
```
0.5
```
### Note
In the first sample case, both Alice and Bob can pick any real number from $[0, 1]$, and the expected
absolute difference is $\int_0^1\int_0^1 |x − y| dx dy =\frac 13$.

In the second sample case, Alice can pick any real number from $[0, 1]$ while Bob can only pick 1, and
therefore the expected absolute difference is $\int_0^1 |x − 1| dx =\frac 12$.
### Solution
先复习一下二重积分，以样例1为例

$\begin{aligned}\int_0^1\int_0^1 |x − y| dx dy &=\int_0^1\int_0^x (x − y) dx dy+\int_0^1\int_x^1 (y − x) dx dy\\&=\int_0^1[xy-\frac 12y^2]_0^x dx+\int_0^1[\frac 12y^2-xy]_x^1 dx\\&=\int_0^1(\frac 12x^2) dx+\int_0^1(\frac 12-x+\frac 12x^2) dx\\&=[\frac 16x^3]_0^1+[\frac 12x-\frac 12x^2+\frac 16x^3]_0^1\\&=\frac 16+\frac 12-\frac 12+\frac 16\\&=\frac 13\end{aligned}$

当两个积分区间不相交：

$\int_{l_1}^{r_1}\int_{l_2}^{r_2}|x-y|dxdy,l_1<r_1<l_2<r_2$

$\begin{aligned}\int_{l_1}^{r_1}\int_{l_2}^{r_2}|x-y|dxdy&=\int_{l_1}^{r_1}[\frac 12y^2-xy]_{l_2}^{r_2}dx\\&=\int_{l_1}^{r_1}[\frac 12(r_2^2-l_2^2)-x(r_2-l_2)]dx\\&=[\frac 12(r_2^2-l_2^2)x-\frac 12x^2(r_2-l_2)]_{l_1}^{r_1}\\&=\frac 12(r_2^2-l_2^2)(r_1-l_1)-\frac 12(r_1^2-l_1^2)(r_2-l_2)\\&=\frac 12(r_2-l_2)(r_1-l_1)(r_2+l_2-r_1-l_1)\end{aligned}$

当两个积分区间相交，可以拆分成重叠的区间和不相交的区间，这样可以复用上面结论

重叠：

$\begin{aligned}\int_l^r\int_l^r |x − y| dx dy &=\int_l^r\int_l^x (x − y) dx dy+\int_l^r\int_x^r (y − x) dx dy\\&=\int_l^r[xy-\frac 12y^2]_l^x dx+\int_l^r[\frac 12y^2-xy]_x^r dx\\&=\int_l^r[\frac 12x^2-lx+\frac 12l^2] dx+\int_l^r[\frac 12r^2-rx+\frac 12x^2]dx\\&=[\frac 16x^3-\frac 12lx^2+\frac 12l^2x]_l^r+[\frac 12r^2x-\frac 12rx^2+\frac 16x^3]_l^r\\&=\frac 13(r^3-l^3)-lr(r-l)\end{aligned}$

当一个区间退化成点，而集合里的其他区间没退化成点，那这个区间不会被选到，因为连续性变量选到一个值的概率为0(其实是无穷小)

而集合里的所有区间退化成点，那么当作离散型变量考虑

因此可以写出离散型对离散型，连续型对连续型，离散型对连续型三种情况的代码

>因为重叠部分的计算有3次方，而值域1e9，三次方之后就是1e27，long long 会溢出，因此需要__int128_t  
>下面代码离散型对离散型用前缀和优化为 $O(n\log m)$，离散型对连续性用前缀和优化为 $O(m\log n)$，连续性对连续型为 $O(nm)$  
>对于连续型对连续型，先考虑正确性，再从正确性的基础上考虑优化
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long double ld;
const int N = 1e5 + 5;
array<ld, 2> a[N], b[N];
ld pre[N],squarePre[N];
int n, m;
ld cal1(ld l1, ld r1, ld l2, ld r2)
{
    ld t1 = l1 + r1, t2 = l2 + r2;
    if (t1 < t2)
        return (ld)((r1 - l1) * (r2 - l2) * (t2 - t1)) / 2.0L;
    return (ld)((r1 - l1) * (r2 - l2) * (t1 - t2)) / 2.0L;
}
ld cal2(ld l, ld r)
{
    return (ld)(r * r * r - l * l * l) / 3.0L - l * r * (r - l);
}
ld discreteWithdiscrete()
{
    pre[0] = 0;
    for (int i = 1; i <= m; ++i)
        pre[i] = pre[i - 1] + b[i][0];
    ld ans = 0;
    for (int i = 1; i <= n; ++i)
    {
        int pos = upper_bound(b + 1, b + m + 1, a[i]) - b;
        ans += (ld)(pos - 1) * a[i][0] - pre[pos - 1];
        ans += pre[m] - pre[pos - 1] - (m - pos + 1) * a[i][0];
    }
    return ans;
}
ld discreteWithcontinuous()
{
    pre[0]=0;
    for(int i=1;i<=n;++i)
        pre[i]=pre[i-1]+a[i][0];
    squarePre[0]=0;
    for(int i=1;i<=n;++i)
        squarePre[i]=squarePre[i-1]+a[i][0]*a[i][0];
    ld ans = 0;
    for(int i=1;i<=m;++i)
    if(b[i][0]!=b[i][1])
    {
        ld l=b[i][0],r=b[i][1];
        int pos1=lower_bound(a+1,a+n+1,b[i])-a-1;
        int pos2=upper_bound(a+1,a+n+1,array<ld,2>{r,0})-a-1;
        ans+=((r*r-l*l)/2.0L)*(ld)pos1-pre[pos1]*(r-l);
        ans+=(pre[n]-pre[pos2])*(r-l)-((r*r-l*l)/2.0L)*(ld)(n-pos2);
        ans+=((l*l+r*r)/2.0L)*(ld)(pos2-pos1)-(pre[pos2]-pre[pos1])*(l+r)+(squarePre[pos2]-squarePre[pos1]);
    }
    return ans;
}
ld continuousWithcontinuous()
{
    ld ans = 0;
    for (int i = 1; i <= n; ++i)
    if (a[i][0] != a[i][1])
    {
        for (int j = 1; j <= m; ++j)
        if (b[j][0] != b[j][1])
        {
            ld l = max(a[i][0], b[j][0]), r = min(a[i][1], b[j][1]);
            if (l >= r)
                ans += cal1(a[i][0], a[i][1], b[j][0], b[j][1]);
            else
            {
                ans += cal2(l, r);
                if (a[i][1] > b[j][1])
                    ans += cal1(b[j][1], a[i][1], b[j][0], b[j][1]);
                else if (b[j][1] > a[i][1])
                    ans += cal1(a[i][1], b[j][1], a[i][0], a[i][1]);
                if (a[i][0] > b[j][0])
                    ans += cal1(b[j][0], a[i][0], a[i][0], r);
                else if (b[j][0] > a[i][0])
                    ans += cal1(a[i][0], b[j][0], b[j][0], r);
            }
        }
    }
    return ans;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    ld sum1 = 0, sum2 = 0;
    for (int i = 1; i <= n; ++i)
    {
        int l, r;
        cin >> l >> r;
        a[i] = {l, r};
        sum1 += r - l;
    }
    for (int i = 1; i <= m; ++i)
    {
        int l, r;
        cin >> l >> r;
        b[i] = {l, r};
        sum2 += r - l;
    }
    sort(a + 1, a + n + 1);
    sort(b + 1, b + m + 1);
    cout << fixed << setprecision(12);
    if (sum1 == 0 && sum2 == 0)
        cout << discreteWithdiscrete() / (ld)n / (ld)m;
    else if (sum1 && sum2)
        cout << continuousWithcontinuous() / (ld)sum1 / (ld)sum2;
    else
    {
        if (sum1)
        {
            swap(a, b);
            swap(n, m);
            swap(sum1, sum2);
        }
        cout << discreteWithcontinuous() / (ld)n / (ld)sum2;
    }
    return 0;
}
```
设Alice的集合为A，Bob的集合为B，可以证明：AB中各取一个区间作为一对，满足区间相交，总对数是 $O(n)$ 级别的

首先AB各自内的区间不相交，所以A一个内区间和B内多个区间相交，B内区间一定是连续的

如果 $A_i$ 和 $B_j,B_{j+1},B_{j+2},...,B_{j+k}$ 相交，那么只有 $B_j,B_{j+k}$ 这两个区间可能会与 A 的其他区间相交

那么使对数最多的构造类似于 $A:(1,3),(4,7),(8,11)...\ B:(2,5),(6,9),(10,13)...$

而这样的构造，对数是 $O(n)$ 级别，因此可以双指针优化

此外，为了避免精度丢失，前面用int128存，最后除掉分母
```cpp
#include <iostream>
#include <array>
#include <algorithm>
#include <iomanip>
using namespace std;
typedef __int128_t ll;
typedef long double ld;
const int N = 1e5 + 5;
array<ll, 2> a[N], b[N];
ll pre[N], squarePre[N];
ll cal1(ll l1, ll r1, ll l2, ll r2)
{
    ll t1 = l1 + r1, t2 = l2 + r2;
    if (t1 > t2)
        swap(t1,t2);
    return ((r1 - l1) * (r2 - l2) * (t2 - t1))*3ll;
}
ll discreteWithdiscrete(int n, int m)
{
    pre[0] = 0;
    for (int i = 1; i <= m; ++i)
        pre[i] = pre[i - 1] + b[i][0];
    ll ans = 0;
    for (int i = 1; i <= n; ++i)
    {
        int pos = upper_bound(b + 1, b + m + 1, a[i]) - b;
        ans += (ll)(pos - 1) * a[i][0] - pre[pos - 1];
        ans += pre[m] - pre[pos - 1] - (ll)(m - pos + 1) * a[i][0];
    }
    return ans;
}
ld discreteWithcontinuous(int n, int m)
{
    pre[0] = 0;
    for (int i = 1; i <= n; ++i)
        pre[i] = pre[i - 1] + a[i][0];
    squarePre[0] = 0;
    for (int i = 1; i <= n; ++i)
        squarePre[i] = squarePre[i - 1] + a[i][0] * a[i][0];
    ll ans = 0;
    for (int i = 1; i <= m; ++i)
    {
        ll l = b[i][0], r = b[i][1];
        int pos1 = lower_bound(a + 1, a + n + 1, array<ll, 2>{l, l}) - a - 1;
        int pos2 = upper_bound(a + 1, a + n + 1, array<ll, 2>{r, r}) - a - 1;
        ans += (r * r - l * l) * (ll)pos1 - pre[pos1] * (r - l)*2ll;
        ans += (pre[n] - pre[pos2]) * (r - l)*2ll - (r * r - l * l) * (ll)(n - pos2);
        ans += (l * l + r * r) * (ll)(pos2 - pos1) - (pre[pos2] - pre[pos1]) * (l + r)*2ll + (squarePre[pos2] - squarePre[pos1])*2ll;
    }
    return (ld)ans/2.0L;
}
ld continuousWithcontinuous(int n, int m)
{
    pre[0] = 0;
    for (int i = 1; i <= m; ++i)
        pre[i] = pre[i - 1] + b[i][1] - b[i][0];
    squarePre[0] = 0;
    for (int i = 1; i <= m; ++i)
        squarePre[i] = squarePre[i - 1] + b[i][1] * b[i][1] - b[i][0] * b[i][0];
    __int128_t ans = 0,ans2=0;
    for (int i = 1, j = 1; i <= n; ++i, j -= (j > 1))
    {
        __int128_t l = a[i][0], r = a[i][1];
        while (j <= m && b[j][1] <= l)
            ++j;
        ans += pre[j - 1] * (r * r - l * l) - squarePre[j - 1] * (r - l);
        for (; j <= m && b[j][0] < r; ++j)
        {
            ll L = max(l, b[j][0]), R = min(r, b[j][1]);
            ans2 += (R * R * R- L* L * L)*2ll - L * R * (R- L)*6ll;
            if (r > b[j][1])
                ans2 += cal1(b[j][1], r, b[j][0], b[j][1]);
            else if (b[j][1] > r)
                ans2 += cal1(r, b[j][1], l, r);
            if (l > b[j][0])
                ans2 += cal1(b[j][0], l, l, R);
            else if (b[j][0] > l)
                ans2 += cal1(l, b[j][0], b[j][0], R);
        }
        if (j > m)
            continue;
        ans += (squarePre[m] - squarePre[j - 1]) * (r - l) - (pre[m] - pre[j - 1]) * (r * r - l * l);
    }
    return (ld)((ld)ans/2.0L+(ld)ans2/6ll);
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    int n, m;
    cin >> n >> m;
    ll sum1 = 0, sum2 = 0;
    for (int i = 1; i <= n; ++i)
    {
        int l, r;
        cin >> l >> r;
        a[i] = {(ll)l, (ll)r};
        sum1 += r - l;
    }
    for (int i = 1; i <= m; ++i)
    {
        int l, r;
        cin >> l >> r;
        b[i] = {(ll)l, (ll)r};
        sum2 += r - l;
    }
    sort(a + 1, a + n + 1);
    sort(b + 1, b + m + 1);
    if(sum1)
    {
        int j = 0;
        for (int i = 1; i <= n; ++i)
        {
            if (a[i][0] == a[i][1])
                continue;
            a[++j] = a[i];
        }
        n = j;
    }
    if(sum2)
    {
        int j = 0;
        for (int i = 1; i <= m; ++i)
        {
            if (b[i][0] == b[i][1])
                continue;
            b[++j] = b[i];
        }
        m = j;
    }
    cout << fixed << setprecision(12);
    if (sum1 == 0 && sum2 == 0)
        cout << (ld)discreteWithdiscrete(n, m) / (ld)n / (ld)m;
    else if (sum1 && sum2)
        cout << (ld)continuousWithcontinuous(n, m)/(ld)sum1/(ld)sum2;
    else
    {
        if (sum1)
        {
            swap(a, b);
            swap(n, m);
            swap(sum1, sum2);
        }
        cout << (ld)discreteWithcontinuous(n, m) / (ld)n / (ld)sum2;
    }
    return 0;
}
```
# 数学杂
## 一维
已知 $a_i$ ，求 $x$ 使得 $\sum\limits_{i=1}^n|a_i-x|$ 最小

若 $n$ 是奇数，则 $x$ 是 $a_i$ 中位数，否则 $x$ 是 $a_i$ 中位数之间都可以（包含两个中位数）
## 二维
一堆点 $(x_i,y_i)$ ，求一条直线 $F(x):y=Ax+B$ ，使得 $\sum\limits_{i=1}^n (y_i-F(x_i))^2$ 最小

设 $\overline{x}=\frac{\sum\limits_{i=1}^n x_i}n$ ， $\overline{y}=\frac{\sum\limits_{i=1}^n y_i}n$

$A=\frac{\sum\limits_{i=1}^n x_iy_i-n\overline{x} \overline{y}}{\sum\limits_{i=1}^n x_i^2-n\overline{x}^2}$

$B=\overline{y}-A\overline{x}$

## 自然数幂和
$\sum\limits_{i=1}^n i=n(n+1)/2$

$\sum\limits_{i=1}^n i^2=n(n+1)(2n+1)/6$

$\sum\limits_{i=1}^n i^3=n^2(n+1)^2/4$

$\sum\limits_{i=1}^n i^4=n(n+1)(6n^3+9n^2+n-1)/30$

$\sum\limits_{i=1}^n i^5=n^2(n+1)(2n^3+4n^2+n-1)/12$

## 递推式推导

设 $f_n^p=\sum\limits_{i=1}^n i^{p}$

$(n+1)^p-n^p=C_p^1n^{p-1}+C_p^2n^{p-2}+...+1$

$\sum\limits_{n=1}^m(n+1)^p-n^p=\sum\limits_{n=1}^mC_p^1n^{p-1}+C_p^2n^{p-2}+...+1$

$(m+1)^p-1=C_p^1f_m^{p-1}+C_p^2f_m^{p-2}+...+m$

$f_m^{p-1}=((m+1)^p-1-(C_p^2f_m^{p-2}+...+m))/C_p^1$

$f_m^{p}=((m+1)^{p+1}-1-(C_{p+1}^2f_m^{p-1}+...+m))/(p+1)$
## 求法
### 拉格朗日插值
如果有取模，那么模数必须质数

自然数k次幂和是k+1次函数，求前k+2个点的点值，插就完了
```cpp
long long fac[N],inv[N];
void getC()
{
    fac[0]=1;
    for(int i=1;i<N;++i)
        fac[i]=fac[i-1]*i%mod;
    inv[N-1]=fast_power(fac[N-1],mod-2);
    for(int i=N-1;i;--i)
        inv[i-1]=inv[i]*i%mod;
}
struct lagrange
{
    ll y[N],pre[N],suf[N];
    ll lag(ll m,int k)//g(m)，k个点
    {
        if(m<=k)
            return y[m];
        pre[0]=suf[k+1]=1;
        for(int i=1;i<k;++i)
            pre[i]=pre[i-1]*(m-i)%mod;
        for(int i=k;i>1;--i)
            suf[i]=suf[i+1]*(m-i)%mod;
        ll ans=0;
        for(int i=1;i<=k;++i)
            ans=(ans+y[i]*inv[i-1]%mod*inv[k-i]%mod*pre[i-1]%mod*suf[i+1]%mod*((k-i)&1?-1:1))%mod;
        return (ans+mod)%mod;
    }
}la;
getC();
for(int i=1;i<=k+2;++i)
    la.y[i]=(la.y[i-1]+fast_power(i,k))%mod;
cout<<la.lag(n,k+2);
```
### 第2类斯特林数
$\sum\limits_{i=1}^ni^k=\sum\limits_{j=0}^{k}S_2(k,j)\frac{(n+1)^{\underline{j+1}}}{j+1}$
```cpp
struct powersum
{
    int k;
    ll s[K][K];
    void init(int kk)
    {
        k=kk;
	    s[0][0]=1;
	    for(int i=1;i<=k;++i)
		    for(ll j=1;j<=i;++j)
			    s[i][j]=s[i-1][j-1]+j*s[i-1][j];
    }
    ll cal(ll n)
    {
        ll res,ans=0;
        for(ll i=0;i<=k;++i)
        {
            res=s[k][i];
            for(ll j=0;j<=i;++j)
                if((n+1-j)%(i+1))
                    res=res*(n+1-j);
                else
                    res=res*((n+1-j)/(i+1));
            ans=ans+res;
        }
        return ans;
    }
};
```
## 调和级数近似公式

n 很大时

$f_n\approx \ln n+0.5772156649+\frac 1{2n}$

```cpp
log(n)+0.5772156649+1.0/(2*n)
```
## 狄利克雷前后缀
$O(n\log\log n)$

原缀已知 $a$，求 $b$

逆缀已知 $b$，求 $a$

答案保存在原数组上
## 狄利克雷前缀
$b_n=\sum\limits_{d|n}a_d$
```cpp
for(int i=1;i<=cnt && primes[i]<=n;++i)
    for(int j=1;j*primes[i]<=n;++j)
        a[j*primes[i]]+=a[j];
```
## 狄利克雷后缀
$b_d=\sum\limits_{d|n}a_n$
```cpp
for(int i=1;i<=cnt && primes[i]<=n;++i)
    for(int j=n/primes[i];j;--j)
        a[j]+=a[j*primes[i]];
```
## 逆狄利克雷前缀
$b_n=\sum\limits_{d|n}a_d$
```cpp
for(int i=cnt;i;--i)
    for(int j=n/primes[i];j;--j)
        a[j*primes[i]]-=a[j];
```
## 逆狄利克雷后缀
$b_d=\sum\limits_{d|n}a_n$
```cpp
for(int i=cnt;i;--i)
    for(int j=1;j*primes[i]<=n;++j)
        a[j]-=a[j*primes[i]];
```
```cpp
const long long N=1e18+1;
const long long N=1e18+(long double)1;
```
上面这个会丢精度，需要改成下面那个

---
n以内两点互质连边，连到m条边停止，可以两层循环，复杂度是 $O(min(n^2,m) log n)$ ，因为互质的还蛮多的

## Fibonacci数
$gcd(F_n,F_m)=F_{gcd(n,m)}$

$\sum\limits_{i=0}^n F_i=F_{n+2}-1$

模m意义下，循环节长度小于等于6m
## 最大质因子个数和最大因子个数
$n\le$|$10^1$|$10^2$|$10^3$|$10^4$|$10^5$|$10^6$|$10^7$|$10^8$|$10^9$|
---|---|---|---|---|---|---|---|---|---
$max\{w(n)\}$|2|3|4|5|6|7|8|8|9
$max\{d(n)\}$|4|12|32|64|128|240|448|768|1344

$n\le$|$10^{10}$|$10^{11}$|$10^{12}$|$10^{13}$|$10^{14}$|$10^{15}$|$10^{16}$|$10^{17}$|$10^{18}$|
---|---|---|---|---|---|---|---|---|---
$max\{w(n)\}$|10|10|11|12|12|13|13|14|15
$max\{d(n)\}$|2304|4032|6720|10752|17280|26880|41472|64512|103680
