#! https://zhuanlan.zhihu.com/p/557859810
# 埃拉托斯特尼筛(简称埃氏筛)
$O(n\ln\ln\ n)$

下面提供了两个版本的代码，easy版本代码更短，但是在1e8-2e8区间内性能就不如线性筛了，另一个版本优化了偶数，在1e9-2e9区间内性能不如线性筛
```c++
const int N=1e7+1,M=664579+1;
bitset<N> v;
int p[M],primeCount=0;
void EratosthenesSieve_Easy()
{
	for(int i=2;i*i<N;++i)
        if(!v[i])
            for(int j=i*i;j<N;j+=i)
                v[j]=1;
    for(int i=2;i<N;++i)
        if(!v[i])
            p[++primeCount]=i;
}
void EratosthenesSieve()
{
	for(int i=4;i<N;i+=2)
        v[i]=1;
	for(int i=3;i*i<N;i+=2)
        if(!v[i])
            for(int j=i*i;j<N;j+=i*2)
                v[j]=1;
    for(int i=2;i<N;++i)
        if(!v[i])
            p[++primeCount]=i;
}
```
下表展示了各个数量级，埃氏筛和线性筛的性能，从1毫秒附近开始，到线性筛性能反超结束

| Size    | Eratosthenes sieve (s) | Linear sieve (s) |
|---------|------------------------|------------------|
| 2e5     | 0.000569953            | 0.0011846       |
| 4e5     | 0.00112594             | 0.00246947       |
| 1e6     | 0.00276512             | 0.00581585       |
| 1e7     | 0.0285691              | 0.0553143        |
| 1e8     | 0.392324               | 0.585051         |
| 1e9     | 5.43637                | 6.24542          |
| 2e9     | 13.9267                | 13.3351          |

因此在常见题目中，埃式筛是性能最快的，线性筛的作用是求积性函数
# 线性筛(又名欧拉筛)
$O(n)$

保证每个数只被它最小质因子筛到
```c++
const int N=1e7+1,M=664579;
bitset<N> v;
int p[M],primeCount=0;
void EulerSieve()
{
	for(int i=2;i<N;++i)
	{
		if(!v[i])
			p[primeCount++]=i;
		for(int j=0;j<primeCount && i*p[j]<N;++j)
		{
			v[i*p[j]]=1;
			if(i%p[j]==0)
				break;
		}
	}
}
```

# 常见积性函数及筛法

## 欧拉函数φ

$\phi(n)=$ 1~n,和n互质的数的个数

与素数互质的数有 $n-1$ 个

```c++
const int N=1e7+1,M=664579;
bitset<N> v;
int p[M],phi[N],primeCount=0;
void EulerSieve()
{
    phi[1]=1;
    for(int i=2;i<N;++i)
    {
        if(!v[i])
        {
            p[primeCount++]=i;
            phi[i]=i-1;
        }
        for(int j=0;j < primeCount && p[j]*i < N;++j)
        {
            v[i*p[j]]=1;
            if(i%p[j]==0)
            {
                phi[i*p[j]]=phi[i]*p[j];
                break;
            }
			phi[i*p[j]]=phi[i]*(p[j]-1);
        }
    }
}
```

## 莫比乌斯函数μ

有质因子次数大于等于2，函数为0

否则，函数=(-1)^k,k为不同质因子个数

```c++
const int N=1e7+1,M=664579+1;
bitset<N> v;
int p[M],mu[N],primeCount=0;
void EulerSieve()
{
	mu[1]=1;
	for(int i=2;i<N;++i)
	{
		if(!v[i])
		{
			p[primeCount++]=i;
			mu[i]=-1;
		}
		for(int j=0;j < primeCount && i*p[j] < N;++j)
		{
			v[i*p[j]]=1;
			if(!(i%p[j]))
				break;
			mu[i*p[j]]=-mu[i];
		}
	}
}
```

## 约数个数

```c++
//dn:divisor number,mpdn:minimum prime divisor number
const int N=1e7+1,M=664579+1;
bitset<N> v;
int p[M],dn[N],mpdn[N],primeCount=0;
void EulerSieve()
{
	dn[1]=1;
	for(int i=2;i<N;++i)
    {
        if(!v[i])
		{
			p[primeCount++]=i;
			dn[i]=2;
			mpdn[i]=1;
		}
        for(int j=0;j < primeCount && i*p[j] < N;++j)
        {
            v[i*p[j]]=1;
            if(i%p[j]==0)
            {
				mpdn[i*p[j]] = mpdn[i]+1;
                dn[i*p[j]]=dn[i]/(mpdn[i]+1)*(mpdn[i]+2);
                break;
            }
			dn[i*p[j]]=dn[i]*dn[p[j]];
			mpdn[i*p[j]]=1;
			//p[j]是i*p[j]的最小素因子 
        }
    }
}
```

## 约数和
```c++
//sd:sum of divisor,smpd:sum of minimum prime divisor polynomial
//sd约数和，smpd最小质因子的那个多项式（也可以理解为由最小质因子组成的数的约数和吧） 
const int N=1e7+1,M=664579+1;
bitset<N> v;
int p[M],sd[N],smpd[N],primeCount=0;
void EulerSieve()
{
    sd[1]=1;
    for(int i=2;i<N;++i)
    {
        if(!v[i])
		{
			p[primeCount++]=i;
			sd[i]=i+1;
			smpd[i]=i+1;
		}
        for(int j=0;j<primeCount && i*p[j]<N;++j)
        {
            v[i*p[j]]=1;
            if(i%p[j]==0)
            {
				smpd[i*p[j]]=smpd[i]*p[j]+1;
                sd[i*p[j]]=sd[i]/smpd[i]*smpd[i*p[j]];
                break;
            }
			sd[i*p[j]]=sd[i]*sd[p[j]];
			smpd[i*p[j]]=p[j]+1;
        }
    }
}
```