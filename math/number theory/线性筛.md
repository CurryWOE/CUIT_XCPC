#! https://zhuanlan.zhihu.com/p/557859810
## 代码细节整体说明
bitset在时间空间上都优于int数组，bool数组

全局变量默认赋值为0，所以不用初始化

v[i]为0表示i是素数，为1表示i不是素数

# 埃氏筛
## 时间复杂度
$O(nlnln\ n)$ 

## 代码细节
$i*i$ 开始是为了减少重复筛，但用埃氏计算贡献时则从 $i$ 开始

```c++
const int N=1e7+3;
bitset<N> v;
void seive()
{
	for(int i=2;i<N;++i)
	{
		if(v[i])
			continue;
		for(int j=i*i;j<N;j+=i)
			v[j]=true;
	}
}
```

>part1
# 线性筛
（又名欧拉筛）
## 时间复杂度
$O(n)$
## 代码细节
p存放素数，当N较大时，可以右移两位优化空间

cnt是素数个数

if(i%p[j]==0) break;

保证每个数只被它最小质因子筛到

```c++
const int N=1e7+3;
bitset<N> v;
int p[N>>2];
void seive()
{
	int cnt=0;
	for(int i=2;i<N;++i)
	{
		if(!v[i])
			p[cnt++]=i;
		for(int j=0;j<cnt && i*p[j]<N;++j)
		{
			v[i*p[j]]=true;
			if(i%p[j]==0)
				break;
		}
	}
}
```
>part 2
# 常见积性函数及筛法

## 欧拉函数φ

$\phi(n)=$ 1~n,和n互质的数的个数

与素数互质的数有 $n-1$ 个

```c++
const int N=1e7+3; 
bitset<N> v;
int p[N>>2],phi[N];
void seive()
{
	int cnt=0;
    phi[1]=1;
    for(int i=2;i<N;++i)
    {
        if(!v[i])
        {
            p[cnt++]=i;
            phi[i]=i-1;
        }
        for(int j=0;j < cnt && p[j]*i < N;++j)
        {
            v[i*p[j]]=1;
            if(i%p[j]==0)
            {
                phi[i*p[j]]=phi[i]*p[j];
                break;
            }
			phi[i*p[j]]=phi[i]*(p[j]-1);
        }
    }
}
```

## 莫比乌斯函数μ

有质因子次数大于等于2，函数为0

否则，函数=(-1)^k,k为不同质因子个数

```c++
const int N=1e7+3;
bitset<N> v;
int p[N>>2],mu[N];
void seive()
{
	int cnt=0;
	mu[1]=1;
	for(int i=2;i<N;++i)
	{
		if(!v[i])
		{
			p[cnt++]=i;
			mu[i]=-1;
		}
		for(int j=0;j < cnt && i*p[j] < N;++j)
		{
			v[i*p[j]]=1;
			if(!(i%p[j]))
				break;
			mu[i*p[j]]=-mu[i];
		}
	}
}
```

part 3

## 约数个数

```c++
//dn:divisor number,mpdn:minimum prime divisor number
const int N=1e7+3;
bitset<N> v;
int p[N>>2],dn[N],mpdn[N];
void seive()
{
	int cnt=0;
	for(int i=2;i<N;++i)
    {
        if(!v[i])
		{
			p[cnt++]=i;
			dn[i]=2;
			mpdn[i]=1;
		}
        for(int j=0;j < cnt && i*p[j] < N;++j)
        {
            v[i*p[j]]=1;
            if(i%p[j]==0)
            {
				mpdn[i*p[j]] = mpdn[i]+1;
                dn[i*p[j]]=dn[i]/(mpdn[i]+1)*(mpdn[i]+2);
                break;
            }
			dn[i*p[j]]=dn[i]*dn[p[j]];
			mpdn[i*p[j]]=1;
			//p[j]是i*p[j]的最小素因子 
        }
    }
}
```

## 约数和
```c++
//sd:sum of divisor,smpd:sum of minimum prime divisor polynomial
//sd约数和，smpd最小质因子的那个多项式（也可以理解为由最小质因子组成的数的约数和吧） 
const int N=1e7+3;
bitset<N> v;
int p[N>>2],sd[N],smpd[N];
void seive()
{
	int cnt=0;
    sd[1]=1;
    for(int i=2;i<N;++i)
    {
        if(!v[i])
		{
			p[cnt++]=i;
			sd[i]=i+1;
			smpd[i]=i+1;
		}
        for(int j=0;j<cnt && i*p[j]<N;++j)
        {
            v[i*p[j]]=1;
            if(i%p[j]==0)
            {
				smpd[i*p[j]]=smpd[i]*p[j]+1;
                sd[i*p[j]]=sd[i]/smpd[i]*smpd[i*p[j]];
                break;
            }
			sd[i*p[j]]=sd[i]*sd[p[j]];
			smpd[i*p[j]]=p[j]+1;
        }
    }
}
```