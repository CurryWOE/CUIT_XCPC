# 博弈论导读
* 两名选手，交替进行预先规定好的操作
* 在任何情况下，合法操作只取决于情况本身，与选手无关
* 游戏失败的最终判定往往是选手无法进行合法操作了

>下文中，必胜必败指的都是先手

常见结论和SG函数打表
## Bash博弈
一堆n个物品，可取出1~m个，最后取光者胜

同余定理：n=k∗(m+1)+r，先者拿走r个，那么后者无论拿走1~m个，先者只要使数目和为m+1的倍数，那么必胜。反之后手可以复制操作，必败
## Fibonacci Nim博弈
一堆n个物品，先取者第一次可以去任意多个，但是不能取完，以后每次取的石子数不能超过上次取子数的2倍。取完者胜。

n不是斐波那契数，必胜
## Whthoff博弈
两堆各若干物品，从任意一堆中至少取出一个或者从两堆中取出同样多的物品，规定每次至少取一个，至多不限，最后取光者胜。

这里的必输局势：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。

从这些必输局势可以发现，每组的第一个是前面没有出现的最小正整数

ak=[k∗(1+5–√)/2], bk=ak+k, k=0,1,2,3...。

所以，先求出差值，差值*黄金分割比 != 最小值的话必胜
```cpp
double r = (sqrt(5) + 1) / 2;
int d = abs(a - b) * r;
return (d != min(a, b));
```
>如果a,b的值非常大的话，需要高精度来计算这个double类型的r。
## Nimm博弈
有n堆物品，两人轮流取，每次取某堆中不少于1个，最后取完者胜

所有的堆数量，异或和不为0，必胜

一般性博弈问题，通过SG函数转换为Nimm博弈
## SG函数
首先给出一种ICG博弈游戏模型，给定一个有向无环图和一个起始顶点上的一枚棋子，两名选手交替的将这枚棋子沿着有向边进行移动，无法移动者判负。

将ICG问题进行转化：任何一个ICG都可以通过把每个局面看作一个顶点，对每个局面和它的子局面连一条有向边来抽象这个“有向图游戏”。

SG函数（Sprague-Grundy）：对于一个给定的有向无环图，定义关于这个图的每个顶点的SG函数如下：

$$ sg(x)=mex\{sg(y) | y是x的后继\} $$

```cpp
int mex(auto v) // v可以是vector、set等容器 
{
    unordered_set<int> S;
    for (auto e : v)
        S.insert(e);
    for (int i = 0;; ++i)
        if (S.find(i) == S.end())
            return i;
}
```
### SG函数的求法
1. 找出必败态
2. 找出当前所有状态的前驱结点
3. 根据定义计算结点SG值
4. 重复上述步骤，直到所有点的SG函数值被计算过
## SG定理
游戏的SG函数值就是它的所有子游戏的SG函数值的异或。