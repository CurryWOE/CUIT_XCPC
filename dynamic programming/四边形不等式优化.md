# 四边形不等式优化
问题形如 $f(i)=\min\limits_{j=1}^i w(j,i)$

使得目标函数取得最值的最小可行解 j 记为最小最优决策点(Minimal Optimal Decision Point)，简记为  opt(i)

这类问题具体有4种形式(DP状态1维2种，2维2种)，需要判断 $w$ 是否满足2种不等式关系，并根据 $w$ 的3种计算性质，从5种优化方法选择1种
## $w$ 的不等式关系
### 四边形不等式
$$\forall l_1\le l_2 \le r_1 \le r_2,\ w(l_1,r_1)+w(l_2,r_2)\le w(l_1,r_2)+w(l_2,r_1)$$
### 区间包含单调性
$$\forall l_1\le l_2 \le r_1 \le r_2,\ w(l_2,r_1)\le w(l_1,r_2)$$
## $w$ 的计算性质
1. 直接 $O(1)$ 计算
2. $w(j,i)$ 可以从 $w(j\pm 1,i)$ 或 $w(j,i\pm 1)$ 去 $O(1)$ 计算(类似莫队)
3. $w(j,i)$ 的计算依赖于 $\{f(k):k<j\}$

>下文的 $f_2,f_4$ 满足 $w$ 的计算性质3
## $f$ 的具体形式
### $f_1(i)=\min\limits_{j=1}^iw(j,i)$
暴力复杂度为 $O(n^2)$。若 $w$ 满足四边形不等式，则 $f_1$ 满足下列决策单调性

$$\forall l<r, opt(l)\le opt(r)$$
### $f_2(i)=\min\limits_{j=1}^if(j-1)+w(j,i)$
此问题通常表述为区间拆分为多个子区间

暴力复杂度为 $O(n^2)$。若 $w$ 满足四边形不等式，则 $f_2$ 满足下列决策单调性

$$\forall l<r, opt(l)\le opt(r)$$
### $f_3(k,i)=\min\limits_{j=1}^if(k-1,j-1)+w(j,i)$
此问题通常表述为区间拆分为多个子区间，且指定拆分为m个子区间

暴力复杂度为 $O(mn^2)$。若 $w$ 满足四边形不等式，则 $f_3$ 满足下列决策单调性

$$\forall k,i, opt(k-1,i)\le opt(k,i)\le opt(k,i+1)$$
### $f_4(l,r)=\min\limits_{mid=l}^{r-1}f(l,mid)+f(mid+1,r)+w(l,r)$
此问题通常表述为n个长度为1的区间两两合并，直到得到区间[1,n]

暴力复杂度为 $O(n^3)$。若 $w$ 满足四边形不等式和区间包含单调性，则 $f_4$ 满足下列决策单调性

$$\forall l+1<r, opt(l,r-1)\le opt(l,r)\le opt(l+1,r)$$
## 优化方法
### 分治
可以解决下列条件都满足的问题：

1. 问题形式如 $f_1,f_3$
2. $w$ 满足四边形不等式
3. $w$ 的计算性质为1或2的情况

思想如下：

暴力求 f(mid) 和 opt(mid)，然后递归求左右两个子区间，由于只会递归 $\log n$ 次，所以 $f_1$ 复杂度 $O(nlog n)$ ，$f_3$ 复杂度 $O(mnlog n)$
```cpp
void solve(int ql, int qr, int optl, int optr)
{
    int mid = (ql + qr) >> 1, best;
    ans[mid] = INF;
    for (int i = optl; i <= min(mid,optr); ++i)
    {
        ll val = XXX;//i为决策点，w(i,mid)
        if (val < ans[mid])
        {
            ans[mid] = val;
            best = i;
        }
    }
    if(ql<mid)
        solve(ql, mid - 1, optl, best);
    if(qr>mid)
        solve(mid + 1, qr, best, optr);
}
```
### 二分+双端队列
可以解决下列条件都满足的问题：

1. 问题形式如 $f_1,f_2,f_3$
2. $w$ 满足四边形不等式
3. $w$ 的计算性质为1的情况，不能解决为2的情况

思想如下：

决策单调性换个说法，一个点如果是最优决策点，那么它覆盖的 i 是一个区间。若以 i 为横坐标，opt(i) 为纵坐标，这是一个非递减的分段函数

双端队列存储三元组(j,L,R)表示从L到R的最优决策点，已考虑过的决策点中，是j

新的决策点对于之前的决策点有2种情况，

1. L到R都完全更优，那么旧决策点直接出队
2. L到R的后半部分更优，那么二分找分界线，再修改旧决策点的R

如果有旧决策点出队或修改，则新决策点入队

```cpp
void solve(int n)
{
    struct MinimalOptimalDecisionPoint
    {
        int p, L, R;
    }q[N];//用数组实现双端队列会比std::deque快22%
    int head=0,tail=0;
    q[tail++]={0,1,n};//第一个数值0可以改成任意值，循环中会修改的
    auto calc = [](int j, int i){};//j为决策点，w(j,i)
    for (int i = 1; i <= n; ++i)
    {
        while(head<tail && q[head].R<i)
            ++head;
        q[head].L = i;
        ans[i] = calc(q[head].p, i);
        int pos = n + 1;
        while(head<tail && calc(i, q[tail-1].L) < calc(q[tail-1].p, q[tail-1].L))
        {
            pos=q[tail-1].L;
            --tail;
        }
        if (head<tail)
        {
            int l=q[tail-1].L,r=q[tail-1].R;
            while (l <= r)
            {
                int mid = (l + r) >> 1;
                if (calc(i, mid) < calc(q[tail-1].p, mid))
                {
                    pos = mid;
                    r=mid-1;
                }
                else
                    l = mid+1;
            }
            q[tail-1].R=pos-1;
        }
        if (pos <= n)
            q[tail++]={i,pos,n};
    }
}
```

>对于同时能使用分治或二分+双端队列的问题，分治快4%
### $f_3$ 的另一种做法(无名方法)
根据单调性，复杂度做到 $O(n(n+m))$

下面为gemini给出的代码，待测试
```cpp
void solve()
{
    for (int i = 0; i <= n; ++i)
        for (int j = 0; j <= m; ++j)
            ans[j][i] = INF;
    ans[0][0] = 0;
    // 注意：为了使用 opt[j+1][i]，j 的循环方向或 opt 的初始化需要小心
    // 在本题性质下，我们顺着段数 j 循环，顺着位置 i 循环
    for (int j = 1; j <= m; ++j)
    {
        // 为了让 opt[j+1][i] 在计算 g[j][i] 时有界，
        // 我们通常将 opt[j][n+1] 初始化为 n，或者从后往前算 i
        // 但最稳妥的 Knuth 优化写法是利用 j-1 层和 i-1 位置
        opt[j][n + 1] = n;
        for (int i = n; i >= 1; --i)
        { // 位置从后往前，保证 opt[j][i+1] 已知
            // 范围限制：opt(j-1, i) <= opt(j, i) <= opt(j, i+1)
            int R = (i == n) ? n : opt[j][i + 1]; 
            for (int k = opt[j - 1][i]; k <= R; ++k)
            {
                // 状态转移：前 k-1 个元素分 j-1 段 + [k, i] 作为第 j 段
                int cur = ans[j - 1][k - 1] + w(k, i);
                if (cur < g[j][i])
                {
                    ans[j][i] = cur;
                    opt[j][i] = k;
                }
            }
        }
    }
}
```