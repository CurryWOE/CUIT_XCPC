# 四边形不等式优化
问题形如 $f(i)=\min\limits_{j=1}^i w(j,i)$

使得目标函数取得最值的最小可行解 j 记为最小最优决策点(Minimal Optimal Decision Point)，简记为  opt(i)

这类问题具体有4种形式(DP状态1维2种，2维2种)，需要判断 $w$ 是否满足2种不等式关系，并根据 $w$ 的3种计算性质，从5种优化方法选择1种
## $w$ 的不等式关系
### 四边形不等式
$$\forall l_1\le l_2 \le r_1 \le r_2,\ w(l_1,r_1)+w(l_2,r_2)\le w(l_1,r_2)+w(l_2,r_1)$$
### 区间包含单调性
$$\forall l_1\le l_2 \le r_1 \le r_2,\ w(l_2,r_1)\le w(l_1,r_2)$$
## $w$ 的计算性质
1. 直接 $O(1)$ 计算
2. $w(j,i)$ 可以从 $w(j\pm 1,i)$ 或 $w(j,i\pm 1)$ 去 $O(1)$ 计算(类似莫队)
3. $w(j,i)$ 的计算依赖于 $\{f(k):k<j\}$

>下文的 $f_2,f_4$ 满足 $w$ 的计算性质3
## $f$ 的具体形式
### $f_1(i)=\min\limits_{j=1}^iw(j,i)$
暴力复杂度为 $O(n^2)$。若 $w$ 满足四边形不等式，则 $f_1$ 满足下列决策单调性

$$\forall l<r, opt(l)\le opt(r)$$
### $f_2(i)=\min\limits_{j=1}^if(j-1)+w(j,i)$
此问题通常表述为区间拆分为多个子区间

暴力复杂度为 $O(n^2)$。若 $w$ 满足四边形不等式，则 $f_2$ 满足下列决策单调性

$$\forall l<r, opt(l)\le opt(r)$$
### $f_3(k,i)=\min\limits_{j=1}^if(k-1,j-1)+w(j,i)$
此问题通常表述为区间拆分为多个子区间，且指定拆分为m个子区间

暴力复杂度为 $O(mn^2)$。若 $w$ 满足四边形不等式，则 $f_3$ 满足下列决策单调性

$$\forall k,i, opt(k-1,i)\le opt(k,i)\le opt(k,i+1)$$
### $f_4(l,r)=\min\limits_{mid=l}^{r-1}f(l,mid)+f(mid+1,r)+w(l,r)$
此问题通常表述为n个长度为1的区间两两合并，直到得到区间[1,n]

暴力复杂度为 $O(n^3)$。若 $w$ 满足四边形不等式和区间包含单调性，则 $f_4$ 满足下列决策单调性

$$\forall l+1<r, opt(l,r-1)\le opt(l,r)\le opt(l+1,r)$$
## 优化方法
### 分治
可以解决下列条件都满足的问题：

1. 问题形式如 $f_1,f_3$
2. $w$ 满足四边形不等式
3. $w$ 的计算性质为1或2的情况

思想如下：

暴力求 f(mid) 和 opt(mid)，然后递归求左右两个子区间，由于只会递归 $\log n$ 次，所以 $f_1$ 复杂度 $O(nlog n)$ ，$f_3$ 复杂度 $O(mnlog n)$
```cpp
void solve(int ql, int qr, int optl, int optr)
{
    int mid = (ql + qr) >> 1, best;
    ans[mid] = INF;
    for (int i = optl; i <= min(mid,optr); ++i)
    {
        ll val = XXX;//w(i,mid)
        if (val < ans[mid])
            ans[mid] = val, best = i;
    }
    if(ql<mid)
        solve(ql, mid - 1, optl, best);
    if(qr>mid)
        solve(mid + 1, qr, best, optr);
}
```
### 二分+双端队列
可以解决下列条件都满足的问题：

1. 问题形式如 $f_1,f_2,f_3$
2. $w$ 满足四边形不等式
3. $w$ 的计算性质为1的情况，不能解决为2的情况

思想如下：

决策单调性换个说法，一个点如果是最优决策点，那么它覆盖的 i 是一个区间。若以 i 为横坐标，opt(i) 为纵坐标，这是一个非递减的分段函数

双端队列存储三元组(j,L,R)表示从L到R的最优决策点，已考虑过的决策点中，是j

新的决策点对于之前的决策点有2种情况，

1. L到R都完全更优，那么旧决策点直接出队
2. L到R都完全更劣，那么退出循环
3. L到R的后半部分更优，那么二分找分界线，再修改旧决策点的R，再退出循环

如果有旧决策点出队或修改，则新决策点入队

下面为gemini给出的代码，待测试
```cpp
// 决策点三元组：决策点 p 负责解决区间 [L, R] 内的问题
struct Node
{
    int p, L, R;
};
// 计算以 j 为决策点时，i 位置的状态值w(j, i)
long long calc(int j, int i) {}
void solve_dp(int n)
{
    deque<Node> q;
    q.push_back({0, 1, n});//0或任意数值都行，循环中会修改
    for (int i = 1; i <= n; ++i)
    {
        while (!q.empty() && q.front().R < i)
            q.pop_front();
        q.front().L = i;//[1,i-1]的最优决策点都已经确定了，防止后续二分到错误的左边界
        ans[i] = calc(q.front().p, i);//q.front().p就是i的最优决策点
        int pos = n + 1;
        while (!q.empty())
        {
            int l=q.back().L,r=q.back().R,k=q.back().p;
            if (calc(i, l) < calc(k, l))
            {
                pos = l;
                q.pop_back();
            }
            else if (calc(i, n) >= calc(k, n))
                break;
            else
            {
                while (l <= r)
                {
                    int mid = (l + r) >> 1;
                    if (calc(i, mid) < calc(k, mid))
                    {
                        pos = mid;
                        r = mid - 1;
                    }
                    else
                        l = mid + 1;
                }
                q.back().R = pos - 1;
                break;
            }
        }
        if (pos <= n)
            q.push_back({i, pos, n});
    }
}
```
### $f_3$ 的另一种做法(无名方法)
根据单调性，复杂度做到 $O(n(n+m))$

下面为gemini给出的代码，待测试
```cpp
void solve()
{
    for (int i = 0; i <= n; ++i)
        for (int j = 0; j <= m; ++j)
            ans[j][i] = INF;
    ans[0][0] = 0;
    // 注意：为了使用 opt[j+1][i]，j 的循环方向或 opt 的初始化需要小心
    // 在本题性质下，我们顺着段数 j 循环，顺着位置 i 循环
    for (int j = 1; j <= m; ++j)
    {
        // 为了让 opt[j+1][i] 在计算 g[j][i] 时有界，
        // 我们通常将 opt[j][n+1] 初始化为 n，或者从后往前算 i
        // 但最稳妥的 Knuth 优化写法是利用 j-1 层和 i-1 位置
        opt[j][n + 1] = n;
        for (int i = n; i >= 1; --i)
        { // 位置从后往前，保证 opt[j][i+1] 已知
            // 范围限制：opt(j-1, i) <= opt(j, i) <= opt(j, i+1)
            int R = (i == n) ? n : opt[j][i + 1]; 
            for (int k = opt[j - 1][i]; k <= R; ++k)
            {
                // 状态转移：前 k-1 个元素分 j-1 段 + [k, i] 作为第 j 段
                int cur = ans[j - 1][k - 1] + w(k, i);
                if (cur < g[j][i])
                {
                    ans[j][i] = cur;
                    opt[j][i] = k;
                }
            }
        }
    }
}
```