# 四边形不等式优化
问题形如 $f(i)=\min\limits_{j=1}^i w(j,i)$

使得目标函数取得最值的最小可行解 j 记为最小最优决策点(Minimal Optimal Decision Point)，简记为  opt(i)

这类问题具体有4种形式(DP状态1维2种，2维2种)，需要判断 $w$ 是否满足2种不等式关系，并根据 $w$ 的3种计算性质，从5种优化方法选择1种
## $w$ 的不等式关系
### 四边形不等式
$$\forall l_1\le l_2 \le r_1 \le r_2,\ w(l_1,r_1)+w(l_2,r_2)\le w(l_1,r_2)+w(l_2,r_1)$$
### 区间包含单调性
$$\forall l_1\le l_2 \le r_1 \le r_2,\ w(l_2,r_1)\le w(l_1,r_2)$$
## $w$ 的计算性质
1. 直接 $O(1)$ 计算
2. $w(j,i)$ 可以从 $w(j\pm 1,i)$ 或 $w(j,i\pm 1)$ 去 $O(1)$ 计算(类似莫队)
3. $w(j,i)$ 的计算依赖于 $\{f(k):k<j\}$

>下文的 $f_2,f_4$ 满足 $w$ 的计算性质3
## $f$ 的具体形式
### $f_1(i)=\min\limits_{j=1}^iw(j,i)$
暴力复杂度为 $O(n^2)$。若 $w$ 满足四边形不等式，则 $f_1$ 满足下列决策单调性

$$\forall l<r, opt(l)\le opt(r)$$
### $f_2(i)=\min\limits_{j=1}^if(j-1)+w(j,i)$
此问题通常表述为区间拆分为多个子区间

暴力复杂度为 $O(n^2)$。若 $w$ 满足四边形不等式，则 $f_2$ 满足下列决策单调性

$$\forall l<r, opt(l)\le opt(r)$$
### $f_3(k,i)=\min\limits_{j=1}^if(k-1,j-1)+w(j,i)$
此问题通常表述为区间拆分为多个子区间，且指定拆分为m个子区间

暴力复杂度为 $O(mn^2)$。若 $w$ 满足四边形不等式，则 $f_3$ 满足下列决策单调性

$$\forall k,i, opt(k-1,i)\le opt(k,i)\le opt(k,i+1)$$
### $f_4(l,r)=\min\limits_{mid=l}^{r-1}f(l,mid)+f(mid+1,r)+w(l,r)$
此问题通常表述为n个长度为1的区间两两合并，直到得到区间[1,n]

暴力复杂度为 $O(n^3)$。若 $w$ 满足四边形不等式和区间包含单调性，则 $f_4$ 满足下列决策单调性

$$\forall l+1<r, opt(l,r-1)\le opt(l,r)\le opt(l+1,r)$$
## 优化方法
### 分治
可以解决下列条件都满足的问题：

1. 问题形式如 $f_1,f_3$
2. $w$ 满足四边形不等式
3. $w$ 的计算性质为1或2的情况

思想如下：

暴力求 f(mid) 和 opt(mid)，然后递归求左右两个子区间，由于只会递归 $\log n$ 次，所以 $f_1$ 复杂度 $O(nlog n)$ ，$f_3$ 复杂度 $O(mnlog n)$
```cpp
void solve(int ql, int qr, int optl, int optr)
{
    int mid = (ql + qr) >> 1, best;
    ans[mid] = INF;
    for (int i = optl; i <= min(mid,optr); ++i)
    {
        int val = w(i,mid);
        if (val < ans[mid])
        {
            ans[mid] = val;
            best = i;
        }
    }
    if(ql<mid)
        solve(ql, mid - 1, optl, best);
    if(qr>mid)
        solve(mid + 1, qr, best, optr);
}
```
### 二分+双端队列
可以解决下列条件都满足的问题：

1. 问题形式如 $f_1,f_2,f_3$
2. $w$ 满足四边形不等式
3. $w$ 的计算性质为1的情况，不能解决为2的情况

思想如下：

决策单调性换个说法，一个点如果是最优决策点，那么它覆盖的 i 是一个区间。若以 i 为横坐标，opt(i) 为纵坐标，这是一个非递减的分段函数

双端队列存储三元组(j,L,R)表示从L到R的最优决策点，已考虑过的决策点中，是j

新的决策点对于之前的决策点有2种情况，

1. L到R都完全更优，那么旧决策点直接出队
2. L到R的后半部分更优，那么二分找分界线，再修改旧决策点的R

如果有旧决策点出队或修改，则新决策点入队
```cpp
void solve(int n)
{
    struct MinimalOptimalDecisionPoint
    {
        int p, L, R;
    }q[N];//用数组实现双端队列会比std::deque快22%
    int head=0,tail=0;
    q[tail++]={0,1,n};//第一个数值0可以改成任意值，循环中会修改的
    for (int i = 1; i <= n; ++i)
    {
        while(head<tail && q[head].R<i)
            ++head;
        q[head].L = i;
        ans[i] = w(q[head].p, i);
        int pos = n + 1;
        while(head<tail && w(i, q[tail-1].L) < w(q[tail-1].p, q[tail-1].L))
        {
            pos=q[tail-1].L;
            --tail;
        }
        if (head<tail)
        {
            int l=q[tail-1].L,r=q[tail-1].R;
            while (l <= r)
            {
                int mid = (l + r) >> 1;
                if (w(i, mid) < w(q[tail-1].p, mid))
                {
                    pos = mid;
                    r=mid-1;
                }
                else
                    l = mid+1;
            }
            q[tail-1].R=pos-1;
        }
        if (pos <= n)
            q[tail++]={i,pos,n};
    }
}
```
对于同时能使用分治或二分+双端队列的问题，分治快4%
### Knuth 优化
可以解决下列条件都满足的问题：

1. 问题形式如 $f_3$
2. $w$ 满足四边形不等式
3. $w$ 的计算性质为1的情况，不能解决为2的情况

直接根据单调性，复杂度做到 $O(n(n+m))$

对于同时能使用分治或二分+双端队列或此做法的问题，此做法比分治快26%，比二分+双端队列快29%
```cpp
int ans[2][N],opt[2][N];
void solve(int n,int m)
{
    memset(ans,0x3f,sizeof(ans));
    ans[0][0]=0;
    //设置为n，方便决策点边界处理
    opt[0][n+1]=opt[1][n+1]=n;
    for (int j = 1, t=1; j <= m; ++j, t^=1)
        for (int i = n; i >= 1; --i)// 位置从后往前，保证 opt[j][i+1] 已知
            for (int k = opt[t^1][i]; k <= min(i,opt[t][i + 1]); ++k)
            {
                int cur = ans[t^1][k] + w(k+1, i);
                if (cur < ans[t][i])
                {
                    ans[t][i] = cur;
                    opt[t][i] = k;
                }
            }
}
```