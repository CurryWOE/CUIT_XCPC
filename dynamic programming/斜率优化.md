# 凸包优化
考虑DP转移形如 $ans_i=\min\limits_{j<i}f'(j)+f''(i)+f'''(i,j)$

其中 $f'(j)$ 表示只与 j 有关的信息，$f''(i)$ 表示只与 i 有关的信息，$f'''(i,j)$ 表示同时与 i,j 有关的信息

令 $b=ans_i-f''(i),y=f'(j),kx=f'''(i,j)$

根据具体题目将 f'''(i,j) 转换为 $f'''(i,j)=f''''(i)f'''''(j)$

令 $k=-f''''(i),x=f'''''(j)$

重写转移方程 $b_i=\min\limits_{j<i}y_j-k_ix_j$

把 $(x_j,y_j)$ 视为二维平面上的点，考虑一条过 $(x_j,y_j)$ 直线 

其他数都是已知，只有 $ans_i$ 未知，当 $b_i$ 最小时 $ans_i$ 也取得最小，所以从小到大考虑 $b_i$ 的合法性

当逐渐增大 $b_i$，直线逐渐上移，直线第一次穿过某个点 $(x_j,y_j)$ ，该点一定在全部点的下凸壳
# 斜率优化
斜率优化基于凸包优化，如果确定最优决策点在凸包上，最优决策点(是 $x_j$ 不是 $j$ )单调性和 $k_i$ 单调性一致（结合函数图像理解）

---
DP转移如果是max，最优转移点在上凸壳，最优决策点(是 $x_j$ 不是 $j$ )单调性和 $k_i$ 单调性相反
```cpp
namespace ConvexHullTrickAndSlopeTrick //凸包优化+斜率优化
{
    using T = ll; //此处可根据题目需要改为double, longlong, 以及自定义的分数类
    // X(j)单调性; 1表示单增，0表示单减
    constexpr bool dx = 0;
    // 求解的时max还是min; 1表示max(上凸壳)，0表示min(下凸壳)
    constexpr bool dm = 0;
    T dp[N];
    struct P { T x, y; } Q[N];
    int best=1,tail=1;
    // Y(j) = K(i)X(j) + B(i), B(i) = dp[i] + A(i)
    T K(int i){ return /*----*/;}
    T X(int j){ return /*----*/;}
    T Y(int j){ return /*----*/;}
    T A(int i){ return /*----*/;}
    T calResult(int l,int r)
    {
        return Q[l].y-K(r)*Q[l].x;
    }
    bool checkBack(P &p)
    { // 队尾点和新加入点的向量跟原本凸包旋转方向相反，则是上/下凸点
        #define cross(p1, p2, p3) ((__int128_t)(p2.x - p1.x) * (__int128_t)(p3.y - p1.y) - (__int128_t)(p3.x - p1.x) * (__int128_t)(p2.y - p1.y)) // 向量p1p2与p2p3的叉积
        if constexpr((dm?!dx:dx)) // 凸壳旋转的方向，1表示逆时针，0表示顺时针
            return cross(Q[tail-1], Q[tail], p) <= 0;
        else // 顺时针
            return cross(Q[tail-1], Q[tail], p) >= 0;
    }
    T run(int n)
    {
        dp[1]=/*----*/;
        Q[1]=P{X(1),Y(1)};
        for (int i = 2; i <= n; i++)
        {
            T res=calResult(best,i);
            for(T tmp;best<tail;++best)
            {
                tmp=calResult(best+1,i);
                bool better;
                if constexpr(dm)
                    better = (tmp >= res);
                else
                    better = (tmp <= res);
                if(better)
                    res=tmp;
                else
                    break;
            }
            dp[i] = res-A(i);
            P p(X(i), Y(i));
            while (best<tail && checkBack(p))
                --tail;
            Q[++tail]=p;
        }
        return dp[n];
    }
}
```