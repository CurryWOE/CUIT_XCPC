/*
组合数学->群论
概念的东西太多，对解题貌似没用
这里介绍会用到的概念
设G是一个集合
//集合在高中讲过吧
*是G上的二元运算，如果(G,*)满足下面的条件：
//!是一元运算符，'+','-','*','/'等等是二元运算符
//就是对两个元素运算的符号
//这里*拿来当符号用，不是乘法符号
封闭性：对于任何a,b∈G,有a*b∈G;
//在集合中的任意两个元素进行运算，结果还在集合内
结合律：对任何a,b,c∈G有(a*b)*c=a*(b*c);
//和加法结合律，乘法结合律类似
单位元：存在e∈G,使得对所有的a∈G,都有a*e=e*a=a;
//不懂的话后面有例子解释
逆元：对于每个元素a∈G,存在x∈G,使得a*x=x*a=e,这个时候记x为a^(-1)，称为a的逆元，那么则称(G,*)为一个群。
//不懂的话后面有例子解释
例：G={0,1,2,3,......,n-1}那么它在mod n加法下是一个群
//mod n，所以结果肯定还在集合内
//加法结合律
//单位元是0，a+0=0+a=a
//逆元是相反数,a+(-a)=(-a)+a=0
群元素的个数有限，称为有限群，且其中元素的个数称为阶，记为|G|
----------------------------------------------------------------
置换：设X为一个有限集，对集合的元素进行任意的排序，那么称排序后的结果π是X上的一个置换。
//有限集是元素个数有限的集合
//看不懂的话，下面有例子解释
例：设X={1,2,3,4....n},
设π是X的一个置换，满足π：1->a1,2->a2,......n->an,
//-> 表示对应
其中a1,a2...an是X的一个排列，则称π是X上的一个置换。

可将π记为   1     2   ......   n    
           a1   a2   ......   an    

同一置换用这样的表示法有n!种，但其对应的关系不变。
//!表示阶乘
例子：
{1,2,3}的所有置换是
{1,2,3},{1,3,2},{2,1,3},{2,3,1},{3,1,2},{3,2,1}
//就是重排列，懂吧
假设循环π是这样一个置换，满足π：a1->a2,a2->a3,......ak->a1,
但是对于其他元素保持不变，即：ai->ai,(k<i)

可将π记为   a1   a2   ......   ak    a(k+1) a(k+2) ......
           a2   a3   ......   a1    a(k+1) a(k+2) ......

称为k阶循环，K为循环长度。
//不一定连续，不一定从1开始
每个置换都可以写成若干个互不相交的循环的乘积，且表示是唯一的.

如A   1   2  3   4  5  6
  B   2   4  5   1  3  6
//A1->B1->A2->B2->A4->B4 为(124)
//A表示上面一行，B表示下面一行
//后面的数字是第几列
//从A行某一列开始，到B行相应的列，B行这个列的数字作为坐标到A列，如此往复，直到出现循环
则可以表示为(124)(35)(6),置换的循环节数是上面的循环个数，
就是成对括号数，即为3.
------------------------------------------------------------
Polya定理：
设G={π1，π2，π3........πn}
是X={a1，a2，a3.......an}上一个置换群，
//所有置换的集合即为置换群
用m种颜色对X中的元素进行涂色，
那么不同的涂色方案数为：
1/|G| * (m^C(π1)+m^C(π2)+m^C(π3)+...+m^C(πk)). 
其中C(πk)为置换πk的循环节的个数。
--------------------------------------------------
最简单例题：
黑白两种颜色对下面的方格进行染色 , 
如果允许方格可以绕中心点旋转, 问有多少种不同的着色方案数?
-------------
|  1  |  2  |
-------------
|  3  |  4  |
-------------
---------------------------------------------------
方格可以旋转 0°,90°,180°,270°.
所以群G = {0°,90°,180°,270°} ,G的阶|G| = 4
G 中 所有的置换是
π1 = (1)(2)(3)(4),
12
34

12
34
π2 = (1234),
12
34

31
42
π3 = (14)(23),
12
34

43
21
π4 = (1432),
12
34

24
13
c(1) = 4 , c(2) = 1  , c(3) = 2 , c( 4) = 1
带入 Polya定理
ans = 1/4*(2^4+2^1+2^2+2^1) = 6
-------------------------------------------
一个重要结论，证明略
当只有旋转的时候(顺时针或逆时针)，
对于一个有n个元素的环，可顺时针或逆时针旋转几个位置，
由于至少有n个置换，
但是假设我顺时针旋转k个位置，他就等同于逆时针转动n-k个位置，
假设一个置换为:G={π0，π1，π2，π3，π4，...，πn-1}，
这个时候可以证明
逆时针旋转k个位置时πk的循环节的个数为Gcd(n,k)
且每个循环的长度为L=n/gcd(n,i)。
------------------------------------------
Burnside引理只能解决旋转的情况，考虑翻转就得用polya定理
这里介绍如何计算翻转的情况
//这里文字描述有些过于抽象，得画图来理解
当n为奇数的时候，
这个时候只有一种形式，
假设经过某个顶点i与中心的连线为轴的翻转πi，共有n个，
置换πi的形式如下，i保持不变：

πi：i->i,i+1->i-1,i+2->i-2,......,i+n-1->(i-(n-1)+n)%n。

这个时候由对称性知，加上顶点i共有
n个循环节数为(n+1)/2的循环群

当n为偶数时，有两种形式：

(1)、经过某个顶点与中心的连线为轴的翻转，有n/2个，
这个时候和第一种为奇数的时候一样。

(2)、以顶点i和i+1的中点与中心的连线为轴翻转，共有n/2个：

πi:i->i+1,i-1->i+2,......,(i-j+n)%n->(i+j+1)%n。

这个时候共有
n/2个循环节数(n+2)/2的循环群,
n/2个循环节数n/2的循环群。
要特别注意0的情况，输出0即可。
且由于对于输入不同的num均有2*num中置换，所以结果应该是/(2*num)。
---------------------------------------------------------
例题：
poj 1286 考虑旋转和翻转
poj 2409 考虑旋转和翻转
poj 2154 
*/
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
typedef long long ll;
ll gcd(ll a,ll b)
{
    return b?gcd(b,a%b):a;
}
ll fast_power(ll base,ll exponent)
{
    ll result=1;
    while(exponent>0)
    {
        if(exponent&1)
            result=result*base;
        base=base*base;
        exponent>>=1;
    }
    return result;
}
int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);
    ll m,t,sum;
    //颜色种数m，环长度t
    m=3ll;
    while(1)
    {
        cin>>t;
        if(t==-1)
            break;
        if(t==0)
        {
            cout<<0<<"\n";
            continue;
        }
        sum=0;
        for(ll i=0;i<t;++i)
            sum+=fast_power(m,gcd(t,i));
        if(t%2)
            sum+=t*fast_power(m,(t+1)/2);
        else
            sum+=t/2*(1ll+m)*fast_power(m,t/2);
        sum/=(2*t);
        cout<<sum<<"\n";
    }
    return 0;
}