#! https://zhuanlan.zhihu.com/p/562836709
# 二分\&三分
# 二分
求单调函数的零点

若该点小于0，则答案在右侧，反之在左侧

对于整数和实数的边界处理不一样

实数需要根据数据控制二分次数，同时兼顾精度和时间复杂度，通常来讲卡在超时之前最好（

check返回true表示可行解
```cpp
//整数
while(l<=r)
{
    mid=(l+r)/2;
    if(check(mid))
    {
        l=mid+1;
        ans=mid;
    }
    else
        r=mid-1;
}
```
```cpp
//实数
int times=100;
while(times--)
{
    mid=(l+r)/2;
    if(check(mid))
        l=mid;
    else
        r=mid;
}
cout<< l << " "<<check(l);
```
# 三分
求先单调增再单调减的函数的最大值，或先单调减再单调增的函数的最小值

下列代码以求最大值为例，最小值仅需把大于小于号调转
## 整数三分
```cpp
while(l<=r)
{
    mid=(l+r)/2;
    if(check(mid)<check(mid+1))
    {
        l=mid+1;
        ans=mid+1;
    }
    else
    {
        r=mid-1;
        ans=mid;
    }
}
```
## 实数三分
有两种写法，一种是mid和mid+epsilon去比较，这样一次迭代可以缩小一半区间，性能最优

但是如果mid较大，因为IEEE754浮点数不能正确计算大数和小数的和，所以mid和mid+epsilon实际上是相等的，就会导致结果错误

或者 mid != mid+epsilon，但是check函数的精度有限，导致check(mid)==check(mid+epsilon)，也会导致结果错误

因此有时需要第二种写法，取两个三等分点去比较，每轮迭代缩小区间只有三分之一，但是保证了正确性

```cpp
for(int times=100;times--)
{
    mid=(l+r)/2;
    if(check(mid)<check(mid+eps))
        l=mid;
    else
        r=mid;
}
for(int times=100;times--;)
{
    lmid=l+(r-l)/3,rmid=r-(r-l)/3;
    if(check(lmid)<check(rmid))
        l=lmid;
    else
        r=rmid;
}
cout<< l << " "<<check(l);
```
对于二元函数，如果固定一元，另一元都是单峰函数，可以三分套三分，当然，可以进一步推广到更多元函数