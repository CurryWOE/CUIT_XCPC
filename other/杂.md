# 合法括号序列(Regular Bracket Sequence)
一个括号序列是RBS，全部前缀和大于等于0，互为充要条件
# 序列变成非递减序列
存在至少一个最优解，使得最终非递减序列中的每一个数值，都来自于原始序列
## 证明
假设某个最优解序列 $B$ 中出现了一个数值 $v$，而 $v$ 不在原序列 $A$ 中。我们可以尝试微调 $v$ 的值，看看代价函数如何变化：

* 设所有在 $B$ 中等于 $v$ 的元素下标集合为 $I = \{i, i+1, \dots, j\}$
* 如果我们把这些 $B_k (k \in I)$ 全部增加一个极小的 $\epsilon$ 或减少 $\epsilon$：
  * 只要 $v$ 的左右邻居（$B_{i-1}$ 和 $B_{j+1}$）满足约束，这种移动就是合法的
  * 代价变化：增加 $\epsilon$ 后，代价的变化取决于集合 $I$ 中有多少 $A_k$ 比 $v$ 大，有多少比 $v$ 小
    * 令 $N_{smaller}$ 为 $A_k < v$ 的数量
    * 令 $N_{larger}$ 为 $A_k > v$ 的数量
  * 代价函数 $f(v)$ 在这个区间内是一个线性函数（或者是分段线性凸函数）
* 根据线性函数的性质，最小值一定在“导数”改变的地方取得，或者在约束的边界取得。
  * 如果你向左移动 $v$，代价减小，你就一直移动，直到 $v$ 撞到了 $A$ 中的某个值，或者撞到了 $B_{i-1}$。
  * 这意味着，通过不断地上下移动这些“不属于 $A$”的段，我们总能在不增加总代价的情况下，将 $B$ 中的值“推”到原序列 $A$ 出现过的某个数值上
# 递增序列转换为非递减序列
a为递增序列，b为非递减序列

$b_i = a_i - i$