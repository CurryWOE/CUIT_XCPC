# 常数优化
## 内存访问步长避免是组循环周期的倍数
CPU缓存，也就是L1,L2和L3，每个缓存都采用了组相联映射

内存地址是一个二进制串，中间的一个子串作为组索引

缓存被分组，一个内存地址能存储到缓存的哪个组，取决于组索引

因此两个地址的组索引一致就会冲突，导致读写压力全在一个缓存组上

缓存总容量/相联度=组循环周期 G，表示每隔多少字节，内存地址会重新映射回同一个缓存组

现代计算机，G基本是2的幂，比如L1的G通常是4096字节
### 例子
二维数组 a[N][M]，元素大小为 T，访问形式是第二维不变，只变第一维

判定值 $R=M\times T\ \%\ G$

如果 R==0，那么就一定会发生组索引冲突

如果 R 接近 0 或 G，那么容易冲突

如果 $\gcd(M\times T,G)=Cache\ Line\ Size$，那么最均匀地利用所有缓存组

实际调优，修改M的数值，使得 M*T 是 G 的倍数+1个Cache Line Size
## 空间局部性
把一起使用的数据在内存中安排在一起，使得它们位于一块或者两块缓存行中

因此，数据结构节点信息的首选是结构体，而不是多个数组

在线段树模板题中的实测，array of struct 比 struct of array 略快一点

结构体成员考虑到内存对齐，还需要成员从小到大排列

---
另一种空间局部性是数据地址连续，一个极端的例子是某平衡树模板题，std::vector暴力性能比平衡树还好

---
另一种空间局部性是多维数组，每一维的意义不同，哪一维在前面哪一维在后面，要根据访问的顺序使得访问地址尽量连续，比如ST表
## 时间局部性
让数据在较小时间段内重复访问。比如滚动数组和矩阵分块乘法
##  内存级并行
遍历链表和平衡树是不能并行的，而树状数组和非递归线段树可以并行

内存可以并行的条件是所有的地址都可以直接通过简单算术运算得到，不需要知道指针指向的地址
## 动态获取地址
在竞争性编程中，几乎没有直接使用malloc或new来获取地址

但还是有动态插入的需求，通常是提前开一个大的数组，通过数组索引代替申请内存得到的地址，比如动态开点的线段树，字典树等
## 读取快于写入
现代计算机，写操作代价比读代价高很多

读可以通过多发射流水线实现并行，写必须按序提交到内存

写操作要进入store buffer排队，满了就阻塞CPU流水线清空buffer；读没有这样的代价

写是互斥的，写之前要通过总线通知其他核心失效其缓存；读是共享的

读可以预取，写没有类似操作
### 例子
动态规划想象成有向无环图，点是状态，边是转移

有两种写法，一种是遍历未知点，然后遍历入边求答案，网上称之为填表法；另一种是遍历已知点，然后遍历出边更新别的点的答案，网上称之为刷表法

两种写法的区别在于刷表法的写操作次数更多，所以填表法更快，每个点的边数越多越明显
## 循环展开
通过减少循环次数、增加单次循环内的计算量，来降低循环开销并提升 CPU 的并行执行能力

第一个优化是，不考虑循环体内的操作，循环本身有代价，减少循环次数能降低开销

第二个也是更重要的优化是，提高指令级并行，包括：减少数据依赖使得单核心内的多个运算单元能同时用上；方便指令预取

当循环次数不能整除展开次数，还需要加代码处理余数

如果循环次数不多，全展开也是可以的

循环展开的代价是代码体积变大导致指令缓存溢出，有可能反而降低性能

因此只有确定一个循环是瓶颈，才能使用循环展开，且展开4-8次最佳
### 例子
首先说明，下面这个例子仅供理解什么是循环展开，编译器是可以做到这样的优化，循环展开真正的例子是矩阵乘法，向量点积等

下面的before代码，每次 sum+=a[i] 都依赖于上一次 sum 的结果，形成数据依赖链，CPU必须写回寄存器才能算下一步

下面的after代码，多个临时变量之间没有依赖关系，CPU一个核心有多个运算单元，可以同时计算这四个加法
```cpp
//before
for(int i=0;i<2000;++i)
    sum+=a[i];
//after
int s0=0,s1=0,s2=0,s3=0;
for(int i=0;i<2000;i+=8)
{
    s0+=a[i+0],s1+=a[i+1],s2+=a[i+2],s3+=a[i+3];
    s0+=a[i+4],s1+=a[i+5],s2+=a[i+6],s3+=a[i+7];
}
sum=s0+s1+s2+s3
```
### 自动展开
手写循环展开代码多，且复杂循环体容易写错反而没有性能提升

GCC和Clang支持给循环打个标记

>C++模板函数可以实现循环展开，这里暂且不表
```cpp
#pragma GCC unroll 4
for (int i = 0; i < n; ++i)
    sum += a[i];
```
## 循环融合
将需要访问同一数组的循环融合在一起，减少内存读写次数
### 例子
对数组做两次前缀和
```cpp
//before
for(int i=1;i<n;++i)
    a[i]+=a[i-1];
for(int i=1;i<n;++i)
    a[i]+=a[i-1];
//after
int sum0=0,sum1=0;
for(int i=0;i<n;++i)
{
    sum0+=a[i];
    sum1+=sum0;
    a[i]=sum1;
}
```
## 分支预测
CPP20有 [[likely]] 与 [[unlikely]] 来告诉编译器哪个分支更有可能被执行

现代编译器预测能力非常强，所以分支预测主要用于性能非常敏感且概率非常极端的分支语句
### 例子
此处仅给出if的例子，switch，for，while，和代码块也支持 [[likely]] 与 [[unlikely]]
```cpp
if (condition) [[likely]] {
    // 编译器认为这里大概率执行
    do_something();
} else [[unlikely]] {
    // 编译器认为这里极少执行（例如错误处理）
    handle_error();
}
```
## 分支消除
cmov指令根据条件直接赋值，而不产生分支

分支预测猜错了要清空整条流水线，代价10-20个时钟周期

cmov指令对于只有两个路径的分支，且计算都不复杂，直接两个路径都执行，最后根据条件选择一个，没有路径跳转

简单三目运算符可以生成cmov

std::min,std::max可以生成cmov，手写容易写错导致不生成cmov

---
运算符中的逻辑与和逻辑或会生成分支，如果这个分支不可预测，可以换成位运算按位与和按位或
## 树重新编号
按BFS序给点重新编号，点的父亲fa数组是单调不减的，后续其他操作访问地址更连续

按DFS序给点重新编号，可以快速遍历子树，特别是重链剖分加上此技巧再加上线段树可以支持树链和子树的快速修改查询
## STL
### std::move
如果A容器要赋值为B容器，且B容器后续不再使用，A=std::move(B)
### std::vector
vector是随着插入动态扩容，因此直接插入n个元素是 $O(n\log n)$

reserve(n)将容量增加到大于或等于n的值，使得插入n个元素是 $O(n)$

---
emplace_back，当vector模板参数是另一个容器，此时emplace_back比push_back明显快，一般类型无明显差异
### std::set
iterator erase( iterator pos ); 均摊常数，如果set模板参数可以作为数组index，那么迭代器作为数组元素，就可以均摊 $O(1)$ 删除

iterator insert( iterator pos, const value_type& value ); 如果value插入位置恰好在pos的前一个，那么均摊常数，否则 $O(\log n)$。主要是插入多个元素且已知大小关系可以性能优化
```cpp
auto it=s.insert(x).first;
s.insert(it,x-1);
```
## 取模
模数已知就定义为常量

只要不溢出，不需要频繁取模

加减法用if不用不用求余

无符号比有符号快，因此通过加法保证没有负数可以加速

如果不会溢出，可以用__uint128_t存结果，最后取一次模

顺序取模改成分治取模可以提高并行程度
```cpp
//before
a * b % mod * c % mod * d %mod
//after
auto res1=a*b%mod;
auto res2=c*d%mod;
res1*res2%mod;
```
## 完美存图
vector数组加边慢，邻接表遍历边慢，改变存边顺序即可同时满足两者

统计度数，度数数组做前缀和，把 u 的边放到区间 $[deg_{u-1},d_u)$
```cpp
array<int,2> oriEdge[E];//原始顺序存储的边
int deg[V],e[E*2];//度数，新顺序存储的边
void build(int n,int m)
{
    for(int i=0;i<m;++i)
    {
        ++deg[oriEdge[i][0]];
        ++deg[oriEdge[i][1]];
    }
    for(int i=1;i<=n;++i)
        deg[i]+=deg[i-1];
    for(int i=0;i<m;++i)
    {
        e[--deg[oriEdge[i][0]]]=oriEdge[i][1];
        e[--deg[oriEdge[i][1]]]=oriEdge[i][0];
    }
}
void getEdge(int u)
{
    for(int i=d[u-1];i<d[u];++i)
        cout<<e[i]<<' ';
}
```