#! https://zhuanlan.zhihu.com/p/557877161
# 线段树
如果混用单点修改和区间修改，单点修改时需要下传标记

线段树维护序列区间信息；权值线段树维护值域内数的个数。

静态开点适用于值域小，占用空间大，时间快；动态开点适用于值域大，占用空间小，时间慢。动态开点手算一下空间，能开多大开多大，cf915E离MLE就差一点才能AC。

array of struct 比 struct of array 略快一点

实时计算点的l，r，比存下来去找，快

离散化能把值域变小，但不能完全解决静态开点占用空间大的问题，如果要开很多颗树，只能用动态开点，记录下每棵树根的节点。

非可持久化适用于只查询最新信息；可持久化适用于查询历史信息。

可持久化为了共用树结构，只能是动态开点。

单点修改代码短，时空好；区间修改代码长，时空差。区间修改需要懒标记或标记永久化。

平衡树这样点的相对位置会改变的，只能用懒标记，保证碰到的节点，其信息是最新的，时间慢；可持久化这样一个点有多个父亲的，如果用懒标记，下传标记如果不开新节点会影响前面的树，开新节点容易卡空间，只能用标记永久化，时间快。其他情况用两个都行。

所以满打满算有16种板子：可持久化4种，非可持久化12种。

对于区间覆盖的问题，线段覆盖直接原值乘2后离散化，点覆盖需要离散化之后，相邻点之间插入一个点，再离散化

子树问题可以按照dfs序重排点权后建树，因为一颗子树的dfs序连续

可持久化限制深度的子树可以按照第一关键字深度，第二关键字dfs序，插入可持久化线段树

动态开点，当节点信息为0时，认为其暂时无用，回收该节点的空间，在申请空间时优先使用回收的空间
```cpp
namespace segmentTreeWithMemoryPool
{
    int tot,rt[N];
    struct node
    {
        int l,r,sum;
    }st[M];
    vector<int> memoryPool;
    void newNode(int &id)
    {
        if(memoryPool.empty())
            id=++tot;
        else
        {
            id=memoryPool.back();
            memoryPool.pop_back();
        }
    }
    void delNode(int &id)
    {
        memoryPool.push_back(id);
        id=0;
    }
    void update(int &id, int l, int r,int pos,int val)
    {
        if(!id)
            newNode(id);
        st[id].sum+=val;
        if(l==r)
            return;
        int mid = (l+r)/2;
        if (pos <= mid)
            update(st[id].l,l,mid,pos,val);
        else
            update(st[id].r,mid+1,r,pos,val);
        if(st[id].sum==0)
            delNode(id);
    }
    int query(int id,int segl,int segr,int l, int r)
    {
        if (l <= segl && segr <= r)
            return st[id].sum;
        int mid = (segl + segr)/2,res=0;
        if (l <= mid)
            res+=query(st[id].l,segl,mid,l,r);
        if (r > mid)
            res+=query(st[id].r,mid+1,segr,l,r);
        return res;
    }
};
```
## 时间复杂度
$O(nlogn)$ 预处理

$O(logn)$修改，查询
## 空间复杂度
$O(n)$

空间必须开4倍，因为打表发现，节点数除n，的最大值接近4
## 静态开点，懒标记，线段树
```c++
const int N=1e5+3;
struct SegmentTree
{
    struct node
    {
        ll sum,lz;
    }st[N<<2];
    void pushup(int id)
    {
        st[id].sum=(st[id<<1].sum+st[id<<1|1].sum);
    }
    void pushdown(int id,int lsonlen,int rsonlen)
    {
        if (!st[id].lz)
            return;
        st[id<<1].lz+=st[id].lz;
        st[id<<1|1].lz+=st[id].lz;
        st[id<<1].sum+=st[id].lz*lsonlen;
        st[id<<1|1].sum+=st[id].lz*rsonlen;
        st[id].lz=0;
    }
    void build(int id,int l,int r)
    {
        if (l ==r)
        {
            st[id]={revW[l],0};
            return;
        }
        int mid=(l + r)/2;
        build(id << 1,l,mid);
        build(id<<1|1,mid + 1,r);
        pushup(id);
    }
    void update(int id,int segl,int segr,int l,int r,ll val)
    {
        if (l <=segl && segr <=r)
        {
            st[id].sum+=val*(segr-segl+1);
            st[id].lz+=val;
            return;
        }
        int mid=(segl + segr)/2;
        pushdown(id,mid-segl+1,segr-mid);
        if (l <=mid)
            update(id << 1,segl,mid,l,r,val);
        if (r > mid)
            update(id<<1|1,mid+1,segr,l,r,val);
        pushup(id);
    }
    ll query(int id,int segl,int segr,int l,int r)
    {
        if (l <=segl && segr <=r)
            return st[id].sum;
        int mid=(segl + segr)/2;
        pushdown(id,mid-segl+1,segr-mid);
        ll res=0;
        if (l <=mid)
            res+=query(id << 1,segl,mid,l,r);
        if (r > mid)
            res+=query(id<<1|1,mid+1,segr,l,r);
        return res;
    }
};
st.build(1,1,n);
st.update(1,1,n,l,r,val);
st.query(1,1,n,l,r);
```
## 静态开点，单点修改，线段树
```c++
const int N=1e5+3;
struct SegmentTree
{
    struct node
    {
        ll sum;
    }st[N<<2];
    void build(int id,int l,int r)
    {
        if (l ==r)
        {
            st[id]={a[l]};
            return;
        }
        int mid=(l + r)/2;
        build(id << 1,l,mid);
        build(id<<1|1,mid + 1,r);
        st[id].sum=st[id<<1].sum+st[id<<1|1].sum;
    }
    void update(int id,int segl,int segr,int pos,ll val)
    {
        st[id].sum+=val;
        if (segl==segr)
            return;
        int mid=(segl + segr)/2;
        if (pos<=mid)
            update(id << 1,segl,mid,pos,val);
        else
            update(id<<1|1,mid+1,segr,pos,val);
    }
    ll query(int id,int segl,int segr,int L,int R)
    {
        if (L <=segl && segr <=R)
            return st[id].sum;
        int mid=(segl + segr)/2;
        ll res=0;
        if (L <=mid)
            res+=query(id << 1,segl,mid,L,R);
        if (R > mid)
            res+=query(id<<1|1,mid+1,segr,L,R);
        return res;
    }
};
st.build(1,1,n);
st.update(1,1,n,pos,val);
st.query(1,1,n,l,r);
```
## 动态开点，懒标记，线段树
```cpp
namespace SegmentTree
{
    struct node
    {
        int l,r;
        ll sum,lz;
    }st[N<<6];
    int tot;
    void newNode(int &id,int l,int r)
    {
        if(id)
            return;
        id=++tot;
        /*
        st[id].sum=起始值（懒标记下推会让其变成正确的值）
        */
    }
    void pushup(int id,int l,int r)
    {
        st[id].sum=st[l].sum+st[r].sum;
    }
    void pushdown(int id,int l,int mid,int r)
    {
        if (r-l<=0)
            return;
        newNode(st[id].l,l,mid);
        newNode(st[id].r,mid+1,r);
        if(!st[id].lz)
            return;
        /*
        st[st[id].l].sum=?
        st[st[id].l].lz=?
        st[st[id].r].sum=?
        st[st[id].r].lz=?
        */
        st[id].lz = 0;
    }
    void update(int id,int segl,int segr,int l, int r, ll val)
    {
        if (l <= segl && segr <= r)
        {
            st[id].lz+=val;
            st[id].sum+=val;
            return;
        }
        int mid = (segl + segr)/2;
        pushdown(id,segl,mid,segr);
        if (l <= mid)
            update(st[id].l,segl,mid, l,r, val);
        if (r > mid)
            update(st[id].r,mid+1,segr,l,r, val);
        pushup(id,st[id].l,st[id].r);
    }
    ll query(int id,int segl,int segr,int L, int R)
    {
        if (L <= segl && segr <= R)
            return st[id].sum;
        int mid = (segl + segr)/2;
        pushdown(id,segl,mid,segr);
        ll res = 0;
        if (L <= mid)
            res+=query(st[id].l, segl,mid,L, R);
        if (R > mid)
            res+=query(st[id].r,mid+1,segr, L, R);
        return res;
    }
    void init(int n)
    {
        for(;tot;--tot)
            st[tot]={0,0,0ll,0ll};
        int rt=0;
        newNode(rt,1,n);
    }
};
st::init();
st::update(1,1,n,l,r,x);
st::query(1,1,n,l,r);
```
## 动态开点，单点修改，线段树
```cpp
namespace SegmentTree
{
    struct node
    {
        int l,r;
        ll sum;
    }st[N<<2];
    int tot;
    void update(int &id,int segl,int segr,int pos, ll val)
    {
        if(!id)
            id=++tot;
        st[id].sum+=val;
        if (segl==segr)
            return;
        int mid = (segl + segr)/2;
        if (pos <= mid)
            update(st[id].l,segl,mid,pos,val);
        else
            update(st[id].r,mid+1,segr,pos,val);
    }
    ll query(int id,int segl,int segr,int L, int R)
    {
        if(!id)
            return 0;
        if (L <= segl && segr <= R)
            return st[id].sum;
        int mid = (segl + segr)/2;
        ll res = 0;
        if (L <= mid)
            res+=query(st[id].l, segl,mid,L, R);
        if (R > mid)
            res+=query(st[id].r,mid+1,segr, L, R);
        return res;
    }
    void init()
    {
        for(;tot;--tot)
            st[tot]={0,0,0ll};
    }
};
st::init();
st::update(1,1,n,pos,x);
st::query(1,1,n,l,r);
```

[hdu1166](https://acm.dingbacode.com/showproblem.php?pid=1166)单点加法，区间和

[hdu1754](https://acm.dingbacode.com/showproblem.php?pid=1754)单点变值，区间最大值

[poj3468](http://poj.org/problem?id=3468)区间加法，区间和

[poj2528](http://poj.org/problem?id=2528)区间变值，区间值的个数

[hdu1698](https://acm.dingbacode.com/showproblem.php?pid=1698)区间变值，区间和

[poj3264](http://poj.org/problem?id=3264)区间最大值最小值之差

[hdu4027](https://acm.dingbacode.com/showproblem.php?pid=4027)区间变为原值平方根，区间和

[cf911G](https://codeforces.com/contest/911/problem/G)区间所有满足ai=x的ai赋值为y，求最终数组