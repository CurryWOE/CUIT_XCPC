#! https://zhuanlan.zhihu.com/p/557877161
# 线段树
如果混用单点修改和区间修改，单点修改时需要下传标记
## 时间复杂度
$O(nlogn)$ 预处理

$O(logn)$修改，查询
## 空间复杂度
$O(n)$

空间必须开4倍，因为打表发现，节点数除n，的最大值接近4
## 区间修改，区间查询
```c++
const int N=1e5+3;
struct SegmentTree
{
    int segl[N << 2], segr[N << 2];
    ll st[N << 2], lz[N << 2];
    ll merge1(ll x, ll y) //修改
    {
        return x + y;
    }
    ll merge2(ll x, ll y) //查询
    {
        return x+y;
    }
    void pushup(int id)
    {
        st[id] = merge2(st[id << 1], st[id << 1 | 1]);
    }
    void pushdown(int id)
    {
        if (!lz[id])
            return;
        lz[id << 1] = merge1(lz[id << 1], lz[id]);
        lz[id << 1 | 1] = merge1(lz[id << 1 | 1], lz[id]);
        st[id << 1] = merge1(st[id << 1], lz[id] * (segr[id << 1] - segl[id << 1] + 1));
        st[id << 1 | 1] = merge1(st[id << 1 | 1], lz[id] * (segr[id << 1 | 1] - segl[id << 1 | 1] + 1));
        lz[id] = 0;
    }
    void build(int id, int l, int r)
    {
        segl[id] = l;
        segr[id] = r;
        if (l == r)
        {
            st[id] = a[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(id << 1, l, mid);
        build(id << 1 | 1, mid + 1, r);
        pushup(id);
    }
    void update(int id, int L, int R, ll val)
    {
        if (L <= segl[id] && segr[id] <= R)
        {
            st[id] = merge1(st[id], val * (segr[id] - segl[id] + 1));
            lz[id] = merge1(lz[id], val);
            return;
        }
        int mid = (segl[id] + segr[id]) >> 1;
        pushdown(id);
        if (L <= mid)
            update(id << 1, L, R, val);
        if (R > mid)
            update(id << 1 | 1, L, R, val);
        pushup(id);
    }
    ll query(int id, int L, int R)
    {
        if (L <= segl[id] && segr[id] <= R)
            return st[id];
        int mid = (segl[id] + segr[id]) >> 1;
        pushdown(id);
        ll res = 0;
        if (L <= mid)
            res = merge2(res, query(id << 1, L, R));
        if (R > mid)
            res = merge2(res, query(id << 1 | 1, L, R));
        return res;
    }
    void init(int n)
    {
        memset(lz, 0, sizeof(lz[0]) * (n << 2));
        build(1, 1, n);
    }
} st;
st.init(n);
st.update(1,l,r,val);
st.query(1,l,r);
```
## 单点修改，区间查询
```c++
const int N=1e5+3;
struct SegmentTree
{
    int segL[N<<2],segR[N<<2];
    ll sum[N<<2];
    void pushup(int id)
    {
        sum[id]=sum[id<<1]+sum[id<<1|1];
    }
    void build(int id,int l,int r)
    {
        segL[id]=l;
        segR[id]=r;
        if(l==r)
        {
            sum[id]=a[l];
            return;
        }
        int mid=(l+r)>>1;
        build(id<<1,l,mid);
        build(id<<1|1,mid+1,r);
        pushup(id);
    }
    void update(int id,int pos,ll val)
    {
        if(segL[id]==segR[id])
        {
            sum[id]+=val;
            return;
        }
        if(pos<=((segL[id]+segR[id])>>1))
            update(id<<1,pos,val);
        else
            update(id<<1|1,pos,val);
        pushup(id);
    }
    ll query(int id,int L,int R)
    {
        if(L<=segL[id] && segR[id]<=R)
            return sum[id];
        int mid=(segL[id]+segR[id])>>1;
        ll res=0;
        if(L<=mid)
            res+=query(id<<1,L,R);
        if(R>mid)
            res+=query(id<<1|1,L,R);
        return res;
    }
    void init(int n)
    {
        build(1,1,n);
    }
}st;
st.init(n);
st.update(1,pos,val);
st.query(1,l,r);
```

[hdu1166](https://acm.dingbacode.com/showproblem.php?pid=1166)单点加法，区间和

[hdu1754](https://acm.dingbacode.com/showproblem.php?pid=1754)单点变值，区间最大值

[poj3468](http://poj.org/problem?id=3468)区间加法，区间和

[poj2528](http://poj.org/problem?id=2528)区间变值，区间值的个数

[hdu1698](https://acm.dingbacode.com/showproblem.php?pid=1698)区间变值，区间和

[poj3264](http://poj.org/problem?id=3264)区间最大值最小值之差

[hdu4027](https://acm.dingbacode.com/showproblem.php?pid=4027)区间变为原值平方根，区间和