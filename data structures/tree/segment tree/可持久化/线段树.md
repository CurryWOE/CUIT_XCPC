#! https://zhuanlan.zhihu.com/p/557877596
# 区间修改
```c++
const int N=1e5+3;
struct persistentSegmentTree
{
    int tot,n,rtnum;
    int rt[N];
    struct node
    {
        int l,r;
        ll sum,mk;
    }st[N<<5];
    void build(int &id,int l,int r)
    {
        id=++tot;
        if(l==r)
        {
            st[id]={0,0,a[l],0ll};
            return;
        }
        int mid=(l+r)/2;
        build(st[id].l,l,mid);
        build(st[id].r,mid+1,r);
        st[id].sum=st[st[id].l].sum+st[st[id].r].sum;
    }
    void update(int &id,int pre,int segl,int segr,int l,int r,ll val)
    {
        id=++tot;
        st[id]=st[pre];
        st[id].sum+=val*(min(r,segr)-max(l,segl)+1);
        if(l<=segl && segr<=r)
        {
            st[id].mk+=val;
            return;
        }
        int mid=(segl+segr)/2;
        if(l<=mid && segl<=r)
            update(st[id].l,st[id].l,segl,mid,l,r,val);
        if(l<=segr && mid<r)
            update(st[id].r,st[id].r,mid+1,segr,l,r,val);
    }
    ll query(int id,int segl,int segr,int l,int r,ll mk)
    {
        if(l<=segl && segr<=r)
            return sum[id]+mk*(r-l+1);
        int mid=(segl+segr)/2;
        ll res=0;
        if(l<=mid)
            res+=query(st[id].l,segl,mid,l,r,mk+st[id].mk);
        if(r>mid)
            res+=query(st[id].r,mid+1,segr,l,r,mk+st[id].mk);
        return res;
    }
    void update(int root,int l,int r,ll val)//指定根的区间修改
    {
        update(rt[++rtnum],rt[root],1,n,l,r,val);
    }
    ll query(int root,int l,int r)//指定根的区间查询
    {
        return query(rt[root],1,n,l,r,0ll);
    }
    void init(int n)
    {
        tot=rtnum=0;
        this->n=n;
        build(rt[0],1,n);
    }
}pst;
pst.init(n);
pst.update(l,r,w);
pst.query(l,r,rt);
```
# 单点修改
```c++
const int N=1e5+3;
struct persistentSegmentTree
{
    int tot,n,rtnum;
    int rt[N];
    struct node
    {
        int l,r;
        ll sum;
    }st[N<<5];
    void build(int &id,int l,int r)
    {
        id=++tot;
        if(l==r)
        {
            st[id].sum=a[l];
            return;
        }
        int mid=(l+r)/2;
        build(st[id].l,l,mid);
        build(st[id].r,mid+1,r);
        st[id].sum=st[st[id].l].sum+st[st[id].r].sum;
    }
    void update(int &id,int pre,int l,int r,int pos,ll val)
    {
        id=++tot;
        st[id]=st[pre];
        st[id].sum+=val;
        if(l==r)
            return;
        int mid=(l+r)/2;
        if(pos<=mid)
            update(st[id].l,st[id].l,l,mid,pos,val);
        else
            update(st[id].r,st[id].r,mid+1,r,pos,val);
    }
    ll query(int id,int segl,int segr,int l,int r)
    {
        if(l<=segl && segr<=r)
            return st[id].sum;
        int mid=(segl+segr)/2;
        ll res=0;
        if(l<=mid)
            res+=query(st[id].l,segl,mid,l,r);
        if(r>mid)
            res+=query(st[id].r,mid+1,segr,l,r);
        return res;
    }
    void update(int root,int pos,ll val)//指定根的单点修改
    {
        update(rt[++rtnum],rt[root],1,n,pos,val);
    }
    ll query(int root,int l,int r)//指定根的区间查询
    {
        return query(rt[root],1,n,l,r);
    }
    void init(int n)
    {
        tot=rtnum=0;
        this->n=n;
        build(rt[0],1,n);
    }
}pst;
pst.init(n);
pst.update(rt,pos,val);
pst.query(rt,l,r);
```