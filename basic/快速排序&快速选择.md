# 快速排序
C的std::qsort的性能在任意数据上都劣于CPP的std::sort，最少慢10%，最多慢400%，因此程序设计竞赛中，不需要使用std::qsort
```cpp
void Quicksort(int a[], int low, int high)
{
	if (low >= high)
	{
		return;
	}
	int first = low;
	int last = high;
	int key = a[first];
	while (first<last)
	{
		while (first < last && a[last] >= key)
		{
			--last;
		}
		a[first] = a[last];
		while (first < last && a[first] <= key)
		{
			++first;
		}
		a[last] = a[first];
	}
	a[first] = key;
	Quicksort(a, low, first - 1);
	Quicksort(a, last + 1, high);
}
```

# 快速选择
```cpp
void nth_element<_RAIter>(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)
void nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);
```
该函数可以从某个序列中 $O(n)$ 找到第 k 小的元素 Val，并将 Val 移动到序列中第 k 的位置处。不仅如此，整个序列经过 nth_element() 函数处理后，所有位于 k 之前的元素都比 Val 小，所有位于 k 之后的元素都比 Val 大，在默认的升序排序规则（std::less）的条件下