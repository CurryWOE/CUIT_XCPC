图(Graph)

声明：本文件内容参考OIwiki，删减了一部分过于复杂的公式

文字描述版：

是由若干给定的顶点，及连接两顶点的边所构成的图形，
这种图形通常用来描述某些事物之间的某种特定关系。
顶点用于代表事物，连接两顶点的边则用于表示两个事物间具有这种关系。

数学描述版：

图是一个二元组G=(V,E)
V表示点集(Vertex set)，E表示边集(Edge set)
对于V中的每个元素，我们称其为顶点(Vertex) 或 节点(Node)，简称 点
E为V中各点之间边的集合

常见概念：
概念很多，可以慢慢看
看不下去可以直接跳后面分割线以下图存储
英文一定要记一下，今年很多人不知道DAG啥意思导致错误
比赛是全英文题面，记住了就不用查

有向图(Directed graph)：
边有方向，即可以从a点到b点，但不能从b点到a点
例如你欠我的钱和我欠你的钱是万万不能混淆的。

无向图(Undirected graph)：
边无方向，即可以从a点到b点，又可以从b点到a点

图G的阶(Order)：
V中元素的数量

边权(Edge weight)：
若边被赋予一个数，表示通过该边，会变化多少
例子：
你开车从a地到b地，汽油减少10L，点a到点b的边的边权为10
通常减少为正数，增加为负数
假如中途有加油站，你开车从a地到b地，汽油增加10L，点a到点b的边的边权为-10

度数(Degree)：
与点a相连的边的数量，称之为度
以点a为起点的边的数量，称之为出度(Out-degree)
以点a为终点的边的数量，称之为入度(In-degree)
点a的度数为点集大小-1，称之为支配点(Universal vertex)

k - 正则图 (k-Regular Graph)：
无向图，每个顶点的度数都是一个固定的常数k

自环(Loop)：
对E中的边e=(u,v),若u=v，则e被称为自环

重边(Multiple edge)：
若E中存在两个完全相同的元素e1,e2，则它们被称作重边

简单图(Simple graph)：
若一个图中没有自环和重边，它被称为简单图
注意，
在无向图中(u,v)和(v,u)算一组重边，而在有向图中(u,v)和(v,u)不为重边。
注意，
在题目中，如果没有特殊说明，是可以存在自环和重边的，在做题时需特殊考虑。

子图(Subgraph)：
对一张图G=(V,E)，若存在另一张图H=(V',E')，
满足V'是V的子集且E'是E的子集，则称H是G的子图

下面4个概念帮助理解环，不需要记忆

途径：
将若干个点连接起来的边的集合W

迹：
对于一条途径W，若e1,e2,...,ek两两互不相同，则称W是一条迹

路径(又称简单路径)：
对于一条迹W，若其连接的点的序列中点两两不同，则称W是一条路径

回路：
对于一个迹W，若起点和终点是同一个点，则称是一个回路。

环(Cycle)(又称简单回路(Simple circuit))：
对于一个回路W，若起点和终点是点序列中唯一重复出现的点对，则称W是一个环。

无环图(acyclic graph)：
任意路径都不是环的图

点连通(Connected)：
对于一张图G=(V,E)，存在u,v∈V,
若存在一条途径，使得起点是u，终点是v，
则u和v是连通的

连通图(Connected graph)：
对无向图和有向图定义不一样

无向图：
对于任意两点u,v属于V，都连通

有向图：
若一张有向图的节点两两互相可达，则称这张图是强连通的(Strongly connected)
若一张有向图的边替换为无向边后可以得到一张连通图，则称原来这张有向图是弱连通的(Weakly connected)

连通块/连通分量(Connected component)：
无向图中，不连通的图是由2个或者2个以上的连通子图组成的。这些不相交的连通子图称为图的连通分量

与连通分量类似，
也有 弱连通分量 (Weakly connected component)
和 强连通分量 (Strongly Connected component)

割(cut)：

点上定义：
删掉一部分点以及相连的边

被删掉的点的集合，称之为点割集(Vertex cut)
大小为一的点割集又被称作割点 (Cut vertex)。
图G点集V元素数量>=k+1且不存在大小为K-1的点割集，则称图G是k-点连通的(k-vertex-connected)
而使得上式成立的最大的k被称作图G的点连通度 (Vertex connectivity)

点双连通(Biconnected):
没有割点的连通图是点双连通的
与连通分量类似，也有点双连通分量 (Biconnected component)

边上定义：
删掉一部分边，（点不删，可以孤立存在）

被删掉的边的集合，称之为边割集(Edge cut)
大小为一的边割集又被称作桥 (Bridge)
图G边集E元素数量>=k+1且不存在大小为K-1的点割集，则称图G是k-边连通的(k-edge-connected)
而使得上式成立的最大的k被称作图G的边连通度 (Edge connectivity)

边双连通(2-edge-connected)：
没有桥的连通图是边双连通的。
与连通分量类似，也有边双连通分量

补图(Complement graph)：
点集一样，边集互补，和补集类似

反图(Transpose Graph)：
点集一样，边集反向，仅对于有向图有反图概念

完全图(Complete graph)：
无向简单图G满足任意不同两点间均有边

有向完全图(Complete digraph)：
有向图G满足任意不同两点间都有两条方向不同的边

星图/菊花图(Star graph)：
若无向简单图满足，存在一个点v为支配点，其余点之间没有边相连
这个图常用来卡图论算法

链(Chain/Path Graph)：
无向简单图的所有边恰好构成一条简单路径
这个图常用来卡图论算法
菊花图和链结合以下也能用来卡图论算法

树(Tree)：
无向连通图不含环

森林(Forest)：
多棵树组成

仙人掌(Cactus)：
无向连通图的每条边最多在一个环内

沙漠(desert)：
多棵仙人掌组成

二分图(Bipartite graph)：
图的点集可以被分为两部分，每一部分的内部都没有连边

完全二分图/满二分图(Complete bipartite graph/Biclique)：
二分图中任何两个不在同一部分的点之间都有连边

匹配(Matching)(又叫边独立集 (Independent edge set))：
对于图G，E的子集E'中任意两条不同的边都没有公共的端点，
且E'中任意一条边都不是自环，则E'是图G的一个匹配，
例子：
一夫一妻制，任一丈夫都只有一个妻子，任一妻子都只有一个丈夫

如果一个点是匹配中某条边的一个端点，
则称这个点是 被匹配的 (matched)/饱和的 (saturated)，
否则称这个点是 不被匹配的 (unmatched)。

极大匹配(Maximal matching)：
一个匹配，满足加入任何一条边后都不再是一个匹配

最大匹配(Maximum-cardinality matching)：
边数最多的匹配
最大的极大匹配就是最大匹配

最大权匹配 (Maximum-weight matching)：
边权之和最大的匹配

完美匹配 (Perfect matching)：
一个匹配，满足所有点都是被匹配的

增广路径(Augmenting path)：
一个匹配M，满足一条路径以非匹配点为起点和终点，每相邻两条边的其中一条在匹配中而另一条不在匹配中

--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------
图存储：

1.直接存：
结构体
实现(仅给出关键代码)：

定义：
struct EDGE
{
    int u,v;//表示点u连着点v
}e[1000];
int total;//边的数量
清零：
total=0;
加边：
e[++total]={u,v};
遍历：
for(int i=1;i<=total;++i)
{
    printf("%d %d",e[i].u,e[j].v);
}

2.邻接矩阵：
二维数组，a[i][j]表示点i到点j的边
实现(仅给出关键代码)：

定义：
int a[100][100];//邻接矩阵
清零：
memset(a,0,sizeof(a));
加边：
a[u][v]=1;//表示u和v有边连接
遍历：
for(int i=0;i<n;++i)
{
    for(int j=0;j<n;++j)
    {
        if(a[i][j])
            printf("%d %d\n",i,j);
    }
}

3.邻接表：
vector，e[i]表示点i连接的点,e[i][j]表示点i连接的第j+1条边
vector是c++ STL里的容器
实现(仅给出关键代码)：

定义：
vector<int> e[1000];//邻接表
清零：
for(int i=0;i<n;++i)
    e[i].clear();
加边：
e[u].push_back(v);//表示u和v有边连接
//e[u][0]=v,即点u的第1条边连的点是v
遍历：
for(int i=0;i<n;++i)
{
    int sz=e[i].size();
    for(int j=0;j<sz;++j)
        printf("%d %d\n",i,e[i][j]);
}

4.链式前向星：
结构体，和邻接表类似，head[i]表示点i最近连的一条边的下标
e[i]表示第i条边
实现(仅给出关键代码)：

定义：
struct EDGE
{
    int v;//表示点i连的这条边的对应的点
    int next;//表示点i连的下一条边的下标
}e[1000];
int head[100];
int total;//边的数量
清零：
memset(head,-1,sizeof(head));
total=0;
加边：
e[++total]={v,head[u]};
head[u]=total;
遍历：
for(int i=0;i<n;++i)
{
    for(int j=head[i];j!=-1;j=e[j].next)
        printf("%d %d",i,e[j].v);
}

设点数为V，边数为E
E接近V*V，为稠密图
E接近V，为稀疏图

邻接矩阵适用于稠密图
邻接表和链式前向星适用于稀疏图

构造图方式（持续更新）：

以下内容需思考后再看答案

1.假如你会用边权，但不会点权，现在给你一个有点权的图，如何处理：
点权：
到达该点会变化多少
-------------思考-----------------



拆点：
把一个点变成两个点，入点和出点，点权就变成了边权

2.（区域赛真题）有向图，同一点集合内任意两点边权一样，不同集合间的点边权不一样，如何处理：
-------------思考-----------------



共点：
点集合内增加一个点，集合内其他点到该点边权为该点集合内任意两点边权，该点到集合内其他点边权为0，反之亦可

3.waiting.......