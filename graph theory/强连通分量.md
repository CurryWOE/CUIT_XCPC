#! https://zhuanlan.zhihu.com/p/648828476
# 强连通分量缩点
每个强连内部任意两点连通
```cpp
vector<int> e[N], sta, ne[N];
array<int,2> ed[N];
int dfn[N], low[N], f[N], vis[N],in[N],dfsOrder, sccnum;
void init(int n)
{
    dfsOrder = sccnum = 0;
    for (int i = 1; i <= n; ++i)
        e[i].clear();
    sta.clear();
    memset(vis, 0, sizeof(int) * (n + 1));
    memset(dfn,0,sizeof(int)*(n+1));
    memset(in,0,sizeof(int)*(n+1));
}
void tarjan(int u)
{
    dfn[u] = low[u] = ++dfsOrder;
    sta.push_back(u);
    vis[u] = 1;
    for (auto &v : e[u])
    {
        if (!dfn[v])
        {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (vis[v])
            low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] != low[u])
        return;
    ++sccnum;
    vector<int>::iterator it=(--sta.end());
    for(f[u]=sccnum,vis[u]=0;*it!=u;--it)
        f[*it]=sccnum,vis[*it]=0;
    sta.erase(it,sta.end());
}
void makeNewMap(int n,int m)
{
    for(int i=1;i<=n;++i)
        if(!in[i])
            tarjan(i);
    for(int i=1;i<=n;++i)
        if(!dfn[i])
            tarjan(i);
    for (int i = 0;i<m;++i)
    {
        int u=f[ed[i][0]],v=f[ed[i][1]];
        if(u==v)
            continue;
        ne[u].push_back(v);
    }
}
```