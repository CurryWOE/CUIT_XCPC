#! https://zhuanlan.zhihu.com/p/563138928
# 最小生成树
稠密图用prim,稀疏图用kruskal

但是大部分时候kru就行（

## 时间复杂度
kruskal：$O(ELogE + ELogV)$

prim：$O(V^2)$

## kru
```cpp
const int N = 2e5 + 3;
const int M = 2e6 + 3;
struct Edge
{
    int u, v, w;
    bool operator<(const Edge f) const
    {
        return w < f.w;
    }
};
struct kruskal
{
    Edge e[M];
    int f[N];
    int tot, n;
    int find(int x)
    {
        return f[x] == -1 ? x : (f[x] = find(f[x]));
    }
    void init(int nn)
    {
        n = nn;
        memset(f, -1, sizeof(int) * (n + 1));
        tot = 0;
    }
    void addEdge(int u, int v, int w)
    {
        e[tot++] = {u, v, w};
    }
    int kru
    {
        sort(e, e + tot);
        int u, v, cnt = 0, cost = 0;
        for (int i = 0; i < tot; ++i)
        {
            u = find(e[i].u);
            v = find(e[i].v);
            if (u == v)
                continue;
            cost += e[i].w;
            f[u] = v;
            if (++cnt == n - 1)
                return cost;
        }
        return -1;
    }
};
```